# === config.py ===


# === enums.py ===
from enum import Enum

class Faction(Enum):
    TOWN = "town"
    MAFIA = "mafia"
    NEUTRAL = "neutral" # Reserved for extensibility

class GamePhase(Enum):
    NIGHT = "night"
    DAY_DISCUSSION = "day_discussion"
    VOTING = "voting"
    DEFENSE = "defense" # Optional phase if accusation needs defense
    FINAL_VOTE = "final_vote" # Optional phase for final lynch decision
    GAME_OVER = "game_over"

class VoteType(Enum):
    ACCUSATION = "accusation" # Initial vote during day
    FINAL_GUILTY = "final_guilty" # Vote during final lynch
    FINAL_INNOCENT = "final_innocent" # Vote during final lynch
    SKIP = "skip" # Abstain from voting

# === environment.py ===
# === Updated mafia/environment.py ===
import random
from collections import deque
from typing import Dict, List, Optional, Any, Tuple

# Use correct imports based on unified role system and previous refactoring
from mafia.game_state import GameState
from mafia.player import Player
from mafia.enums import GamePhase, Faction
# Import specific roles if needed for logic (e.g., Cop speaks first)
from mafia.mechanics.roles import Cop
# Assume rewards and token tracking utilities exist
# from mafia.rewards import compute_rewards, assign_vote_reward, ...
# from mafia.utils.token_cost import track_tokens # If using

# Dummy Token Tracker if not implemented
class TokenTracker:
    def __init__(self): self.usage = {}
    def update(self, *args, **kwargs): pass
    def to_dict(self): return self.usage

# Dummy compute_rewards if not implemented
def compute_rewards(state): return {}

class MafiaEnvironment:
    """
    Manages the overall flow, phases, and action resolution of a Mafia game.
    """
    def __init__(self, players: List[Player], config: Dict[str, Any]):
        self.config = config
        # Ensure players list is shuffled initially unless order matters for setup
        # random.shuffle(players)
        self.state = GameState(players=players, game_config=config)
        self.state.initialize()

        # Turn management for day phase
        self._speaker_queue: deque[str] = deque()
        self._question_queue: deque[Tuple[str, str]] = deque() # (Questioner, Questioned) tuples
        self._turns_taken_this_round: Set[str] = set() # Track who spoke in current round-robin
        self._consecutive_passes: int = 0

        # Configuration flags
        self.lynch_defense_enabled: bool = self.config.get("lynch_defense_enabled", True)
        self.cop_speaks_first: bool = self.config.get("cop_speaks_first", False)
        # Add token budget config if using tokens

        self.token_tracker = TokenTracker() # If using

    # --- Core Simulation Interface ---

    def step_phase(self) -> bool:
        """
        Advances the game by one logical phase or step.
        Returns True if the game ended, False otherwise.
        """
        if self.state.game_over:
            return True

        current_phase = self.state.phase

        if current_phase == GamePhase.NIGHT:
            self._resolve_night()
            self._transition_to_day()
        elif current_phase == GamePhase.DAY_DISCUSSION:
            # Day discussion is more complex, managed turn-by-turn
            # The simulation loop should call process_player_action or advance_turn
            # This method might just check if discussion should end and transition
            if self._check_discussion_end():
                self._transition_to_voting() # Or trial if accusation happened
        elif current_phase == GamePhase.VOTING:
            # Logic to handle voting actions if needed, or transition after timer/all voted
            # For simplicity, assume voting logic is handled within _resolve_day/process_player_action
             pass # Voting might resolve as part of day discussion end
        elif current_phase == GamePhase.DEFENSE:
            # Handle defense turn
            self._run_defense() # Let accused speak
            self._transition_to_final_vote()
        elif current_phase == GamePhase.FINAL_VOTE:
            # Handle final lynch votes
            self._resolve_lynch() # Use final votes
            self._transition_to_night()
        # Add other phases if necessary

        # Check for game end after phase actions
        return self.state.check_game_end()


    def get_current_player_name(self) -> Optional[str]:
        """Returns the name of the player whose turn it is to act."""
        return self.state.current_player_turn

    def get_observation(self, player_name: str) -> Dict[str, Any]:
        """Generates the observation for the specified player."""
        return self.state.get_player_observation(player_name)

    def advance_turn(self):
        """Advances to the next player's turn during the day discussion."""
        if self.state.phase != GamePhase.DAY_DISCUSSION:
            self.state.current_player_turn = None
            return

        # Prioritize question queue
        if self._question_queue:
            questioner, questioned = self._question_queue.popleft()
            # Questioned player speaks next
            self.state.current_player_turn = questioned
            self.state.log_hidden("system", f"Turn advanced to {questioned} (answering {questioner})")
            # We might need state to know they are answering a question
            self.state.turn_context = {"answering_question_from": questioner}
            return

        # If no questions pending, continue normal speaker queue
        self.state.turn_context = None # Clear context
        if not self._speaker_queue:
            # If queue is empty, check if discussion should end or start new round
            if self._check_discussion_end():
                self._transition_to_voting()
                return
            else:
                 # Start a new round-robin
                self._start_new_discussion_round()
                if not self._speaker_queue: # No one left to speak
                     self._transition_to_voting()
                     return

        # Get next speaker from queue
        next_speaker = self._speaker_queue.popleft()
        self.state.current_player_turn = next_speaker
        self.state.turn_number_in_phase += 1 # Increment turn counter
        self.state.log_hidden("system", f"Turn advanced to {next_speaker}")


    def process_player_action(self, player_name: str, action: Dict[str, Any]) -> bool:
        """Processes an action submitted by a player's agent."""
        player = self.state.get_player(player_name)
        if not player or not player.alive or self.state.current_player_turn != player_name:
            self.state.log_hidden(player_name, f"Attempted action {action} but not their turn or dead.")
            return False # Not their turn or player invalid

        action_type = action.get("action")
        target = action.get("target")
        content = action.get("content")
        success = False

        self.state.log_hidden(player_name, f"Received action: {action}")
        self.token_tracker.update(player_name, action_type, content) # Track tokens/action

        # --- Night Actions ---
        if self.state.phase == GamePhase.NIGHT:
            if player.can_act_at_night():
                # Agent should decide target, store it, environment reads it here?
                # Or action dict contains target directly
                player.night_target = target # Store target chosen by agent
                # Submit the *intended* action based on role, Environment resolves later
                intended_action = player.perform_night_action(self.state)
                if intended_action:
                    self.state.register_night_action(player_name, intended_action)
                    success = True
                else:
                     self.state.log_hidden(player_name, "Submitted no valid night action or was blocked.")
                     # Still counts as their turn ending
                     success = True # Turn processed, even if no action
            else:
                 self.state.log_hidden(player_name,"Attempted night action, but role cannot act.")
                 success = True # Turn processed

        # --- Day Discussion Actions ---
        elif self.state.phase == GamePhase.DAY_DISCUSSION:
            self._consecutive_passes = 0 # Reset pass counter on any action other than pass
            if action_type == "pass":
                self.state.log_message(player_name, f"{player_name} passes.")
                self._consecutive_passes += 1
                success = True
            elif action_type == "accuse" and target:
                # Check if an accusation has already happened this day if limiting
                if self.state.player_on_trial:
                     self.state.log_hidden(player_name, "Tried to accuse, but someone is already on trial.")
                else:
                    success = player.accuse(target, self.state)
                    if success:
                        # Accusation successful, potentially triggers voting phase
                        self.state.player_on_trial = target
                        # Don't transition immediately, let round finish? Or transition now?
                        # Let's transition after the action completes.
            elif action_type == "vote" and target:
                 # Allow voting during discussion phase
                 success = player.vote_for(target, self.state)
            elif action_type == "question" and target and content:
                 # Limit questions per player per day? Assume 1 for now.
                 if player.questions_asked_today.get(target, 0) < 1 :
                     success = player.question(target, content, self.state)
                     if success:
                         # Add questioned player to the question queue
                         self._question_queue.append((player_name, target))
                         self.state.log_hidden("system", f"{target} added to question queue by {player_name}")
                         # Questioner gets another turn immediately after questioned?
                         # Per description: "person who questioned is able to then respond"
                         # Let's add questioner after questioned in queue
                         self._question_queue.append((player_name, player_name)) # Special tuple marker?

                 else:
                      self.state.log_hidden(player_name, f"Attempted to question {target} again, limit reached.")
            elif action_type == "predict" and target and content:
                 success = player.predict_role(target, content, self.state)
            elif action_type == "whisper" and target and content:
                 success = player.whisper(target, content, self.state)
                 # Need to ensure whisper content gets to target's next observation
            else:
                 # Default speak action / generic message
                 if content:
                     self.state.log_message(player_name, content)
                     success = True
                 else: # Invalid action format
                      self.state.log_hidden(player_name, f"Submitted invalid action format: {action}")

            # Mark turn as taken for this round-robin cycle
            self._turns_taken_this_round.add(player_name)

        # --- Voting Phase Actions ---
        elif self.state.phase == GamePhase.VOTING:
             if action_type == "vote" and target == self.state.player_on_trial:
                  # Allow voting only for the player on trial
                  success = player.vote_for(target, self.state)
                  # Might need separate vote tally: self.state.votes_for_lynch[player_name] = True/False?
                  # Or stick with player.vote attribute? Let's use dedicated dict for final lynch
                  is_guilty_vote = action.get("vote_type") == VoteType.FINAL_GUILTY # Assuming action includes this
                  self.state.votes_for_lynch[player_name] = is_guilty_vote
                  success = True # Mark action processed
             else:
                  self.state.log_hidden(player_name, f"Invalid action {action} during Voting phase.")


        # --- Defense Phase Action ---
        elif self.state.phase == GamePhase.DEFENSE:
             if player_name == self.state.player_on_trial and content:
                 self.state.log_message(player_name, f"(Defense): {content}")
                 success = True
             else:
                 self.state.log_hidden(player_name, f"Tried to speak during defense, but not on trial.")


        # --- Final Vote Phase Action ---
        elif self.state.phase == GamePhase.FINAL_VOTE:
             if action_type == "vote":
                 vote_type_str = action.get("vote_type", "").lower()
                 if vote_type_str == "final_guilty":
                     self.state.votes_for_lynch[player_name] = True
                     self.state.log_message(player_name, f"votes GUILTY on {self.state.player_on_trial}.")
                     success = True
                 elif vote_type_str == "final_innocent":
                     self.state.votes_for_lynch[player_name] = False
                     self.state.log_message(player_name, f"votes INNOCENT on {self.state.player_on_trial}.")
                     success = True
                 else:
                      self.state.log_hidden(player_name, f"Invalid vote type '{vote_type_str}' during final vote.")
             else:
                 self.state.log_hidden(player_name, f"Invalid action {action} during Final Vote phase.")


        # --- Post-Action ---
        if success:
            # Advance turn only if action was successful and in discussion phase
            if self.state.phase == GamePhase.DAY_DISCUSSION:
                 # Check if accusation triggers immediate phase change
                 if self.state.player_on_trial and action_type == "accuse":
                     self._transition_to_voting() # Or defense if enabled
                 else:
                     self.advance_turn()
        else:
            self.state.log_hidden(player_name, f"Action {action} failed processing.")
            # Do not advance turn if action failed? Or advance anyway? Let's advance.
            if self.state.phase == GamePhase.DAY_DISCUSSION:
                 self.advance_turn()

        return success


    # --- Private Phase Logic Methods ---

    def _resolve_night(self):
        """Resolves all submitted night actions according to standard order."""
        self.state.log_message("system", "Night ends. Resolving actions...")
        self.state.night_action_results.clear() # Clear previous results
        submitted_actions = self.state.night_actions_submitted

        # --- Action Resolution Order ---
        # 1. Roleblocks / Disruptions (e.g., Blackmailer blocks speaking)
        roleblocked_players: Set[str] = set()
        blackmailed_players: Set[str] = set()
        # TODO: Add Roleblocker role and logic
        # for actor, action in submitted_actions.items():
        #     if action.get("type") == "roleblock" and self.state.is_alive(actor):
        #         target = action.get("target")
        #         if self.state.is_alive(target):
        #             roleblocked_players.add(target)
        #             self.state.log_hidden(actor, f"Roleblocked {target}")
        #     elif action.get("type") == "blackmail" # ... etc ...

        # Apply roleblocks to players
        for rb_target in roleblocked_players:
             player = self.state.get_player(rb_target)
             if player: player.is_roleblocked = True

        # Apply other effects like blackmail
        # for bm_target in blackmailed_players: ... player.can_speak_today = False ...


        # 2. Protections (e.g., Doctor)
        protected_players: Dict[str, str] = {} # target -> protector_name
        for actor, action in submitted_actions.items():
            if not self.state.is_alive(actor) or actor in roleblocked_players: continue # Dead or blocked
            if action.get("type") == "protect":
                target = action.get("target")
                if self.state.is_alive(target):
                    # Allow multiple protects? For now, last one counts or first? Let's say first.
                    if target not in protected_players:
                         protected_players[target] = actor
                         # Store who protected them on the player object
                         target_player = self.state.get_player(target)
                         if target_player: target_player.protected_by = actor
                         self.state.log_hidden(actor, f"Successfully protected {target}")

        # 3. Kills (e.g., Mafia Godfather)
        kill_attempts: List[Tuple[str, str]] = [] # (killer_name, target_name)
        for actor, action in submitted_actions.items():
             if not self.state.is_alive(actor) or actor in roleblocked_players: continue
             if action.get("type") == "kill":
                  target = action.get("target")
                  if self.state.is_alive(target):
                      kill_attempts.append((actor, target))
                      self.state.log_hidden(actor, f"Attempting kill on {target}")

        # Resolve kills vs protections
        successful_kills: Set[str] = set()
        for killer, target in kill_attempts:
            if target not in protected_players:
                 successful_kills.add(target)
                 self.state.log_hidden(killer, f"Kill on {target} successful (not protected).")
            else:
                 protector = protected_players[target]
                 self.state.log_hidden(killer, f"Kill on {target} failed (protected by {protector}).")
                 self.state.log_hidden(protector, f"Your protection on {target} worked!")
                 # Optionally notify killer / protector in results

        # Apply kills
        deaths_this_night = []
        for target_to_die in successful_kills:
             if self.state.is_alive(target_to_die): # Check again in case multiple kills target same person
                  self.state.kill_player(target_to_die, reason="killed during night")
                  deaths_this_night.append(target_to_die)


        # 4. Investigations (e.g., Cop, Consigliere)
        # Note: Results were already stored in player memory during perform_night_action
        # This step is mainly for logging or cross-referencing if needed.
        for actor, action in submitted_actions.items():
             if not self.state.is_alive(actor) or actor in roleblocked_players: continue
             if action.get("type") == "investigate":
                  target = action.get("target")
                  result = action.get("result") # Get result stored earlier
                  self.state.log_hidden(actor, f"Investigation result for {target}: {result}")
                  # Store in night_action_results for environment access if needed
                  self.state.night_action_results[actor] = action


        # 5. Other Night Actions (e.g., Consigliere role check, Blackmailer)


        # Announce deaths
        if deaths_this_night:
             # Sort for consistent output
             announce_deaths = ", ".join(sorted(deaths_this_night))
             self.state.log_message("system", f"The sun rises. The following people were found dead: {announce_deaths}.")
        else:
             self.state.log_message("system", "The sun rises. Miraculously, everyone survived the night!")


    def _transition_to_day(self):
        """Resets night states and prepares for the day phase."""
        self.state.log_hidden("system", "Transitioning to Day phase.")
        # Reset player night states AFTER resolution but before day starts
        for player in self.state.players:
            player.reset_night_state() # Clears roleblock status etc. for next night

        self.state.phase = GamePhase.DAY_DISCUSSION
        self.state.day_count += 1
        self.state.reset_day_phase_state() # Clear votes, trial status, etc.
        self._start_new_discussion_round() # Setup speaker queue
        self.state.log_message("system", f"Day {self.state.day_count} begins. Discuss and vote!")


    def _start_new_discussion_round(self):
        """Sets up the speaker queue for a round of discussion."""
        self.state.log_hidden("system", "Starting new discussion round.")
        self._speaker_queue.clear()
        self._turns_taken_this_round.clear()
        self._question_queue.clear() # Clear pending questions? Or let them persist? Let's clear.
        self.state.turn_context = None
        self._consecutive_passes = 0

        # Get list of alive players, potentially ordered
        alive_player_names = sorted(list(self.state.alive_players)) # Sort for consistency

        # Optional: Cop speaks first
        if self.cop_speaks_first:
             cop_player = None
             for name in alive_player_names:
                 player = self.state.get_player(name)
                 if player and isinstance(player.role, Cop):
                     cop_player = name
                     break
             if cop_player:
                 alive_player_names.remove(cop_player)
                 alive_player_names.insert(0, cop_player)
                 self.state.log_hidden("system", f"Cop ({cop_player}) will speak first.")

        self._speaker_queue.extend(alive_player_names)
        self.state.turn_number_in_phase = 0 # Reset turn count for new round
        self.advance_turn() # Set the first speaker

    def _check_discussion_end(self) -> bool:
        """Checks if the discussion phase should end."""
        # Condition 1: Everyone alive has passed consecutively
        if self._consecutive_passes >= len(self.state.alive_players):
            self.state.log_hidden("system", "Discussion ending: Everyone passed.")
            return True

        # Condition 2: Everyone alive has had a turn this round and queue is empty
        # (Avoids infinite loop if someone leaves mid-round? Check count vs set size)
        if not self._speaker_queue and not self._question_queue and len(self._turns_taken_this_round) >= len(self.state.alive_players):
             self.state.log_hidden("system", "Discussion ending: Round complete, queues empty.")
             return True

        # Condition 3: Accusation successful (handled in process_player_action)
        if self.state.player_on_trial:
             # This state means discussion ended due to accusation
             self.state.log_hidden("system", f"Discussion ended: {self.state.player_on_trial} was accused.")
             return True

        # Condition 4: Timer / Max Turns / Token Budget (TODO)
        # if self.state.turn_number_in_phase >= self.config.get("max_day_turns", 20): ...

        return False


    def _transition_to_voting(self):
         """Moves from discussion to voting on the accused player."""
         if not self.state.player_on_trial:
             # If discussion ended without accusation (everyone passed), skip to night
             self.state.log_message("system", "No one was put on trial today.")
             self._transition_to_night()
             return

         self.state.log_message("system", f"{self.state.player_on_trial} is on trial!")
         self.state.votes_for_lynch.clear() # Clear final lynch votes

         if self.lynch_defense_enabled:
             self.state.phase = GamePhase.DEFENSE
             self.state.current_player_turn = self.state.player_on_trial # Accused speaks
             self.state.log_message("system", f"{self.state.player_on_trial}, you may make your defense.")
         else:
             # Skip defense, go directly to final vote
             self._transition_to_final_vote()


    def _run_defense(self):
        """Placeholder for logic during the defense phase (mostly waiting for the accused agent)."""
        # The simulation loop needs to call process_player_action for the accused player.
        # Once they submit their defense (or pass), we transition.
        # For now, assume defense happens instantly or is handled by simulation loop tick.
        self.state.log_hidden("system", f"Defense phase for {self.state.player_on_trial}.")
        # After defense speech (or pass):
        # _transition_to_final_vote() will be called


    def _transition_to_final_vote(self):
        """Moves to the final guilty/innocent voting phase."""
        self.state.phase = GamePhase.FINAL_VOTE
        self.state.current_player_turn = None # Or iterate through voters? Assume simultaneous for now
        self.state.votes_for_lynch.clear() # Ensure votes are fresh for final decision
        self.state.log_message("system", f"Final voting begins for {self.state.player_on_trial}. Vote Guilty or Innocent.")
        # The simulation loop needs to collect votes from all alive players in this phase.


    def _resolve_lynch(self):
        """Tally final votes and execute the lynch if majority guilty."""
        if not self.state.player_on_trial:
            self.state.log_hidden("system", "Lynch resolution skipped: No player on trial.")
            return

        votes = self.state.votes_for_lynch
        guilty_votes = sum(1 for is_guilty in votes.values() if is_guilty)
        innocent_votes = len(votes) - guilty_votes # Assumes everyone voted
        total_alive = len(self.state.alive_players)
        needed_for_guilty = total_alive // 2 + 1

        self.state.log_message("system", f"Vote Results for {self.state.player_on_trial}: Guilty={guilty_votes}, Innocent={innocent_votes} (Need {needed_for_guilty} for guilty)")
        self.state.log_hidden("system", f"Final votes: {votes}")

        if guilty_votes >= needed_for_guilty:
            target = self.state.player_on_trial
            self.state.log_message("system", f"The town has decided to lynch {target}!")
            self.state.kill_player(target, reason="lynched")
        else:
            self.state.log_message("system", f"The town has decided to spare {self.state.player_on_trial}.")

        # Reset trial state after resolution
        self.state.player_on_trial = None


    def _transition_to_night(self):
        """Resets day states and prepares for the night phase."""
        self.state.log_hidden("system", "Transitioning to Night phase.")

        # Resolve lynch if it hasn't happened yet (e.g., if skipping phases)
        if self.state.player_on_trial and self.state.phase != GamePhase.NIGHT:
             self._resolve_lynch()

        # Check game end again after potential lynch
        if self.state.check_game_end():
            return

        # Reset states for the upcoming night
        self.state.phase = GamePhase.NIGHT
        self.state.reset_night_phase_state() # Clear submitted actions etc.
        # No specific player turn at night start; agents submit actions simultaneously (conceptually)
        self.state.current_player_turn = None
        self.state.log_message("system", "Night falls. Choose your actions carefully...")

    # --- Utility ---
    # Removed old _process_votes, _process_lynch, act, _get_observations as logic is integrated
    # Removed old step method

    def apply_rewards(self):
        """Computes and potentially stores rewards based on the current state."""
        # Placeholder: Actual reward calculation might happen at specific events or end of game
        rewards = compute_rewards(self.state)
        self.state.log_hidden("system", f"Computed rewards (not stored): {rewards}")
        # Store rewards in state or return them if needed by simulation runner

# === export.py ===
# export.py
import os
import json

def collect_python_files(root_dir: str) -> dict:
    file_structure = {}

    for dirpath, _, filenames in os.walk(root_dir):
        for file in filenames:
            if file.endswith('.py'):
                full_path = os.path.join(dirpath, file)
                rel_path = os.path.relpath(full_path, root_dir)
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                file_structure[rel_path] = content

    return file_structure

def export_to_json(output_path="code_snapshot.json", root="mafia"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(all_files, f, indent=2)

def export_to_text(output_path="code_snapshot.txt", root="mafia"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        for path, content in all_files.items():
            f.write(f"# === {path} ===\n")
            f.write(content + "\n\n")

if __name__ == "__main__":
    export_to_json()
    export_to_text()
    print("âœ… Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'")


# === game_state.py ===
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Any
# Use correct imports based on unified role system
from mafia.enums import GamePhase, Faction
from mafia.player import Player
# Import specific role classes only if needed for specific logic (like promotion)
from mafia.mechanics.roles import Goon, Godfather, get_role_class # Added get_role_class
import uuid

@dataclass
class GameState:
    players: List[Player]
    game_config: Dict[str, Any] = field(default_factory=dict) # For rules like godfather_detectable
    phase: GamePhase = GamePhase.NIGHT
    day_count: int = 0
    turn_number_in_phase: int = 0 # Track turns within day/night
    current_player_turn: Optional[str] = None # Whose turn it is to act

    alive_players: Set[str] = field(default_factory=set)
    dead_players: Set[str] = field(default_factory=set)

    messages: List[Dict[str, Any]] = field(default_factory=list) # Store message dicts, not just strings
    hidden_log: List[Dict[str, Any]] = field(default_factory=list)

    # Day phase state
    votes_for_accusation: Dict[str, str] = field(default_factory=dict) # voter -> target
    accusation_counts: Dict[str, int] = field(default_factory=dict) # target -> count
    player_on_trial: Optional[str] = None
    votes_for_lynch: Dict[str, bool] = field(default_factory=dict) # voter -> guilty (True) or innocent (False)

    # Discussion state
    discussion_token_budgets: Dict[str, int] = field(default_factory=dict) # Optional

    # Night phase state
    # Stores chosen actions before resolution: player_name -> {"action_type": "kill", "target": "PlayerB", ...}
    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    # Stores resolved outcomes of actions: player_name -> {"action_type": "investigate", "result": "mafia", ...}
    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)


    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    game_over: bool = False
    winner: Optional[Faction] = None # Store winning Faction enum
    final_player_roles: Dict[str, str] = field(default_factory=dict) # player_name -> role_name

    def initialize(self):
        """Called at game start to set up."""
        self.alive_players = {p.name for p in self.players}
        self.dead_players = set()
        self.day_count = 0
        self.phase = GamePhase.NIGHT # Start at night
        self.game_over = False
        self.winner = None
        self.messages.clear()
        self.hidden_log.clear()
        self.final_player_roles.clear()

        # Initialize player states
        for player in self.players:
            player.reset_for_new_game()
            # Set initial token budgets based on config if needed
            # self.discussion_token_budgets[player.name] = self.game_config.get("initial_tokens", 0)

        self.log_message("system", "Game started.")
        self.log_hidden("system", f"Game ID: {self.game_id}")
        self.log_hidden("system", f"Initial Roles: { {p.name: p.role.name for p in self.players} }")


    def get_player(self, name: str) -> Optional[Player]:
        for p in self.players:
            if p.name == name:
                return p
        return None

    def is_alive(self, name: str) -> bool:
        return name in self.alive_players

    def kill_player(self, name: str, reason: str = "killed"):
        """Marks a player as dead and handles consequences like GF promotion."""
        if name not in self.alive_players:
            return # Already dead or invalid

        player = self.get_player(name)
        if not player: return # Should not happen

        self.alive_players.discard(name)
        self.dead_players.add(name)
        player.alive = False
        self.log_message("system", f"{name} ({player.role.name}) has died ({reason}).")
        self.log_hidden("system", f"{name} died. Reason: {reason}")

        # Check for Godfather death and promote a Goon
        if isinstance(player.role, Godfather):
            # Find the first alive Goon to promote
            promoted_goon: Optional[Player] = None
            for p in self.players:
                 # Check using isinstance and ensure they are alive
                if p.name in self.alive_players and isinstance(p.role, Goon):
                    promoted_goon = p
                    break

            if promoted_goon:
                # Change the role object of the promoted player
                new_role = Godfather()
                promoted_goon.role = new_role
                promoted_goon.faction = new_role.faction # Ensure faction is updated if needed
                msg = f"{promoted_goon.name} has been promoted to Godfather!"
                self.log_message("system", msg)
                self.log_hidden(promoted_goon.name, f"Promoted to Godfather after {name}'s death")
            else:
                 self.log_hidden("system", f"Godfather {name} died, but no Goons available to promote.")

        # Check for game end after death
        self.check_game_end()


    def reset_night_phase_state(self):
        self.night_actions_submitted.clear()
        self.night_action_results.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            player = self.get_player(p_name)
            if player: player.reset_night_state()


    def reset_day_phase_state(self):
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None # Or set to first speaker
        for p_name in self.alive_players:
            player = self.get_player(p_name)
            if player: player.reset_day_state()

    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):
        """Updates accusation counts when a vote changes."""
        if old_target and old_target in self.accusation_counts:
            self.accusation_counts[old_target] -= 1
            if self.accusation_counts[old_target] <= 0:
                del self.accusation_counts[old_target]

        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1
        self.votes_for_accusation[voter] = new_target


    def register_night_action(self, actor_name: str, action: Dict[str, Any]):
        """Stores the intended night action from a player."""
        if not self.is_alive(actor_name): return
        self.night_actions_submitted[actor_name] = action
        self.log_hidden(actor_name, f"Submitted night action: {action}")

    # resolve_night_actions is now primarily handled by the Environment

    def check_game_end(self) -> bool:
        """Checks if a win condition has been met."""
        if self.game_over: return True # Already ended

        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}
        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}
        # Add other factions (Neutral) if they exist

        winner = None
        if not mafia_alive:
            winner = Faction.TOWN # Town wins if all Mafia are dead
        elif len(mafia_alive) >= len(town_alive):
            # Mafia wins if they equal or outnumber Town (or if only Mafia remain)
            winner = Faction.MAFIA

        # Add neutral win conditions here if applicable

        if winner:
            self.game_over = True
            self.winner = winner
            self.phase = GamePhase.GAME_OVER
            self.log_message("system", f"Game Over! Winner: {winner.value.upper()}")
            self.final_player_roles = {p.name: p.role.name for p in self.players}
            self.log_hidden("system", f"Final Roles: {self.final_player_roles}")
            return True

        return False

    def log_message(self, sender: str, content: str, recipients: Optional[List[str]] = None):
        """Logs a message to the public game log."""
        # Recipients = None means public message
        msg = {"sender": sender, "content": content, "recipients": recipients, "phase": self.phase, "day": self.day_count}
        self.messages.append(msg)

    def log_hidden(self, actor: str, info: str):
        """Logs information relevant to a specific actor or system process."""
        log_entry = {
            "actor": actor,
            "info": info,
            "phase": self.phase,
            "day": self.day_count,
            "turn": self.turn_number_in_phase
        }
        self.hidden_log.append(log_entry)

    def get_player_observation(self, player_name: str) -> Dict[str, Any]:
         """Generates the observation dictionary for a specific player."""
         player = self.get_player(player_name)
         if not player or not player.alive:
             return {} # Or return a specific "you are dead" state

         # Filter messages visible to this player
         visible_messages = []
         for msg in self.messages:
             # Public messages or whispers sent to/by the player
             is_recipient = msg["recipients"] is None or player_name in msg["recipients"]
             is_sender = msg["sender"] == player_name and msg["recipients"] is not None # Show own whispers
             if is_recipient or is_sender:
                 # Maybe format message differently if whisper?
                 if msg["recipients"] and len(msg["recipients"]) == 1 and is_recipient and not is_sender:
                     formatted_content = f"(Whisper from {msg['sender']}): {msg['content']}"
                 elif is_sender:
                     formatted_content = f"(Whisper to {msg['recipients'][0]}): {msg['content']}"
                 else:
                      formatted_content = f"{msg['sender']}: {msg['content']}"
                 visible_messages.append(formatted_content)

         # Include relevant game state info
         obs = {
             "game_id": self.game_id,
             "player_name": player.name,
             "role": player.role.name,
             "role_description": player.role.get_role_description(),
             "faction": player.faction.value,
             "phase": self.phase.name,
             "day": self.day_count,
             "turn": self.turn_number_in_phase,
             "is_current_turn": self.current_player_turn == player.name,
             "alive_players": sorted(list(self.alive_players)),
             "dead_players": sorted(list(self.dead_players)),
             # Provide recent messages
             "messages": visible_messages[-20:], # Limit history size
             "can_speak": player.can_speak(),
             "can_act_tonight": player.can_act_at_night() and self.phase == GamePhase.NIGHT,
             "player_on_trial": self.player_on_trial,
             "votes_for_accusation": self.votes_for_accusation, # {voter: target}
             "accusation_counts": self.accusation_counts,     # {target: count}
             # "token_budget": self.discussion_token_budgets.get(player.name, 0), # If using tokens
             "memory": player.memory, # Include cop results, etc.
             "is_roleblocked": player.is_roleblocked, # Let player know if blocked last night
             "protected_by": player.protected_by, # Let player know if protected last night
         }
         return obs

# === player.py ===
from typing import Optional, Dict, List, Any
# Import the base Role class and Faction enum
from mafia.mechanics.roles import Role
from mafia.enums import Faction
# Import GameState for type hinting only to avoid circular dependency
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from mafia.game_state import GameState


class Player:
    # Role hint uses the class, not the enum
    def __init__(self, name: str, role: Role):
        self.name: str = name
        self.role: Role = role
        # Faction comes directly from the role object
        self.faction: Faction = self.role.faction
        self.alive: bool = True

        # Night action state
        self.night_target: Optional[str] = None # Who the player chose to target
        self.is_roleblocked: bool = False
        self.protected_by: Optional[str] = None # Who protected this player (e.g., Doctor's name)

        # Day state
        self.vote: Optional[str] = None
        self.discussion_tokens: int = 0 # Handled by environment/config
        self.can_speak_today: bool = True # For effects like Blackmailer

        # Action tracking & Memory
        self.has_accused_today: bool = False
        self.predictions: Dict[str, str] = {} # target_name -> predicted_role_name
        self.questions_asked_today: Dict[str, int] = {} # target_name -> count
        self.whispers_sent_today: Dict[str, str] = {} # target_name -> last_whisper_content
        # Memory for roles like Cop
        self.memory: List[Dict[str, Any]] = []

    def reset_for_new_game(self):
        """Resets player state for the start of a new game."""
        self.alive = True
        self.reset_night_state()
        self.reset_day_state()
        self.memory.clear()
        self.predictions.clear()
        # Role is assigned at init, faction derives from it

    def reset_night_state(self):
        """Resets state relevant to the night phase."""
        self.night_target = None
        self.is_roleblocked = False
        self.protected_by = None

    def reset_day_state(self):
        """Resets state relevant to the day phase."""
        self.vote = None
        # discussion_tokens might be reset by environment based on config
        self.has_accused_today = False
        self.questions_asked_today.clear()
        self.whispers_sent_today.clear()
        self.can_speak_today = True # Reset blacklist effect

    def can_act_at_night(self) -> bool:
        """Check if player is alive and their role has a night action."""
        return self.alive and self.role.can_act_at_night()

    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:
        """
        Performs the player's role-specific night action.
        Assumes self.night_target has been set by the agent.
        Returns the action dict or None.
        """
        if not self.can_act_at_night() or self.is_roleblocked:
            if self.is_roleblocked:
                 self.log_hidden(game_state, "Tried to act but was roleblocked.")
            return None
        # Pass the chosen target to the role's action method
        return self.role.night_action(self, game_state, self.night_target)

    def can_speak(self) -> bool:
        # Add check for blacklist/mute effects
        return self.alive and self.can_speak_today # Add token check if using budgets: and self.discussion_tokens > 0

    # --- Day Actions ---
    # Note: These methods now mostly validate and log,
    # the core logic resides in the Environment or GameState update methods.

    def accuse(self, target: str, game_state: 'GameState'):
        if not self.can_speak() or self.has_accused_today:
            self.log_hidden(game_state, f"Attempted to accuse {target} but couldn't (already accused or cannot speak).")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to accuse {target} but they are dead or invalid.")
            return False

        # Logic to handle accusation (e.g., trigger voting phase) should be in Environment/GameState
        self.log_hidden(game_state, f"Accused {target}")
        game_state.messages.append(f"{self.name} accuses {target}!")
        self.has_accused_today = True # Limit accusations if desired
        return True

    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState'):
        # Prediction is mainly for agent's internal state or analysis
        if not self.alive: return False
        target_player = game_state.get_player(target)
        if not target_player: return False # Predict only existing players

        self.predictions[target] = predicted_role_name
        self.log_hidden(game_state, f"Predicted {target} as {predicted_role_name}")
        # Optional: Public message? game_state.messages.append(f"{self.name} predicts {target} is a {predicted_role_name}.")
        return True

    def question(self, target: str, question_text: str, game_state: 'GameState'):
        if not self.can_speak():
             self.log_hidden(game_state, f"Attempted to question {target} but cannot speak.")
             return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to question {target} but they are dead or invalid.")
            return False

        # Actual questioning/response logic handled by environment turn manager + agents
        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1
        # self.discussion_tokens -= 1 # Decrement if using token budgets
        self.log_hidden(game_state, f"Asked {target}: {question_text}")
        game_state.messages.append(f"{self.name} asks {target}: \"{question_text}\"")
        return True

    def whisper(self, target: str, whisper_text: str, game_state: 'GameState'):
        # Whispering might have specific rules (e.g., only Mafia, limits)
        if not self.alive: return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to whisper {target} but they are dead or invalid.")
            return False

        # Check game rules for whisper permissions if needed
        # e.g., if self.faction != Faction.MAFIA and not game_state.config.allow_all_whispers: return False

        self.whispers_sent_today[target] = whisper_text
        self.log_hidden(game_state, f"Whispered to {target}: {whisper_text}")
        # Add to messages, but potentially filtered based on recipient
        # Using a dedicated messaging system is better here. Assume game_state.messages is public for now.
        game_state.messages.append(f"[WHISPER] {self.name} to {target}") # Content hidden in public log
        # Need a way for target agent to see the whisper content in their observation
        return True

    def vote_for(self, target: str, game_state: 'GameState'):
        if not self.alive: return False
        # Allow voting for dead players? Assume no for now.
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
             self.log_hidden(game_state, f"Attempted to vote for {target} but they are dead or invalid.")
             return False

        # Actual vote tallying happens in GameState/Environment
        old_vote = self.vote
        self.vote = target
        if old_vote and old_vote != target:
            log_msg = f"Changed vote from {old_vote} to {target}"
            public_msg = f"{self.name} changed vote to {target}."
        elif not old_vote:
            log_msg = f"Voted for {target}"
            public_msg = f"{self.name} voted for {target}."
        else: # Voted for same person again
            return True # No change needed

        self.log_hidden(game_state, log_msg)
        game_state.messages.append(public_msg)
        # Signal environment to update vote counts
        game_state.update_vote_counts(self.name, old_vote, target)
        return True

    def log_hidden(self, game_state: 'GameState', info: str):
        """Logs information to the game's hidden log associated with this player."""
        # Ensure game_state has this method or handle logging directly
        game_state.log_hidden(self.name, info)


    def __repr__(self):
        status = 'Dead' if not self.alive else 'Alive'
        return f"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>"


# === rewards.py ===
# mafia/rewards.py
from typing import Dict
from mafia.enums import Faction


def assign_endgame_rewards(game_state) -> Dict[str, float]:
    """
    Assign final rewards to agents based on game outcome.
    Town agents get +1 for town win, -1 otherwise. Same for mafia.
    """
    rewards = {}
    for player in game_state.players:
        if player.faction.value == game_state.winner:
            rewards[player.name] = 1.0
        else:
            rewards[player.name] = -1.0
    return rewards


def assign_predict_role_reward(predicted: str, actual: str) -> float:
    return 0.5 if predicted == actual else -0.25


def assign_vote_reward(voter, target, game_state) -> float:
    """
    +1 if town correctly votes out mafia
    -1 if town votes town
    +0.5 if mafia avoids being voted
    """
    if not game_state.is_alive(target):  # Lynched
        if voter.faction == Faction.TOWN:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return 1.0
            else:
                return -1.0
        elif voter.faction == Faction.MAFIA:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return -1.0
            else:
                return 0.5
    return 0.0


def assign_speaking_reward(agent_name: str, token_used: int) -> float:
    """
    Optional: Reward for verbosity, or penalize excess verbosity.
    For now, neutral. Could be tuned.
    """
    return 0.0


def assign_question_reward(asker, target, game_state) -> float:
    """
    +0.2 for engaging others; could scale if target is mafia and asker is town
    """
    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:
        return 0.4
    return 0.2


# === simulation.py ===
import os
import json
from tqdm import tqdm
# Use correct Environment class name
from mafia.environment import MafiaEnvironment
# Import role classes and helper
from mafia.mechanics.roles import get_role_class, Role
from mafia.player import Player
# Keep TokenTracker import, assume it exists or create dummy
# from mafia.utils.token_cost import TokenTracker # If using
# Import agent classes
from mafia.agents.rule_agent import RuleBasedAgent # Assuming this will exist
from mafia.agents.llm_agent import LLMAPIClientAgent # Import the LLM agent
from typing import Dict, List
import uuid

# Dummy Token Tracker if needed
class TokenTracker:
    def __init__(self): self.usage = {}
    def update(self, *args, **kwargs): pass
    def to_dict(self): return self.usage

def create_players_from_config(config: Dict) -> List[Player]:
    """Creates Player objects based on a configuration dictionary."""
    players = []
    roles_config = config.get("roles", []) # e.g., [{"name": "Player1", "role": "Cop"}, ...]
    if not roles_config: # Fallback to default if config is empty/missing roles
        roles_setup = [
            ("Player1", "Cop"), ("Player2", "Doctor"), ("Player3", "Villager"),
            ("Player4", "Godfather"), ("Player5", "Goon")
        ]
        print("Warning: Using default 5-player role setup.")
    else:
        roles_setup = [(p_cfg["name"], p_cfg["role"]) for p_cfg in roles_config]

    for name, role_name in roles_setup:
        RoleClass = get_role_class(role_name)
        if not RoleClass:
             raise ValueError(f"Unknown role name '{role_name}' in configuration.")
        role_instance = RoleClass()
        player = Player(name=name, role=role_instance)

        # --- Agent Assignment ---
        # Example: Assign agents based on config or default to RuleBased
        agent_type = config.get("agent_mapping", {}).get(name, "rule") # Default to rule-based

        if agent_type.lower() == "llm":
            # TODO: Get model name, system prompt from config
            model_name = config.get("llm_config", {}).get("model", "gpt-4") # Example default
            system_prompt_key = config.get("llm_config", {}).get("system_prompt_key", "default_mafia")
            # Need a way to load system prompts based on key
            system_prompt = f"You are {name}, playing Mafia as {role_instance.name}. {role_instance.get_role_description()}" # Basic example
            agent = LLMAPIClientAgent(name=name, model=model_name, system_prompt=system_prompt)
            print(f"Assigning LLM Agent ({model_name}) to {name}")
        else: # Default to RuleBasedAgent
             # RuleBasedAgent needs to be implemented
            agent = RuleBasedAgent(name=name, player_role=role_instance.name)
            print(f"Assigning Rule Agent to {name}")

        # Link agent to player (though environment might manage this)
        player.agent = agent # Store agent reference if needed directly by player, otherwise managed by env/runner
        players.append(player)

    return players


def run_simulation(game_config: Dict, agent_config: Dict) -> Dict:
    """Runs a single game simulation and returns the final state."""
    print(f"\n--- Starting Simulation Game ID: {game_config.get('game_id', 'N/A')} ---")

    # Combine configs or pass separately
    full_config = {**game_config, "agents": agent_config} # Example merge

    # Create players based on combined config
    players = create_players_from_config(full_config) # Pass merged config

    # Initialize environment
    # Pass game_config to environment if it needs rules like GF detectability
    env = MafiaEnvironment(players=players, config=full_config)
    token_tracker = TokenTracker() # Initialize token tracker if used

    # --- Game Loop ---
    max_steps = full_config.get("max_steps", 100) # Limit game length
    step_count = 0
    while not env.state.game_over and step_count < max_steps:
        step_count += 1
        print(f"\n=== Day {env.state.day_count} | Phase: {env.state.phase.name} | Turn: {env.state.turn_number_in_phase} ===")
        current_player_name = env.get_current_player_name() # Needs implementation in Env

        if not current_player_name:
            # Environment handles transition or phase resolution automatically
             print("Environment resolving phase...")
             env.step_phase() # Needs implementation in Env
             continue # Go to next loop iteration to check game state

        player = env.state.get_player(current_player_name)
        if not player or not player.alive:
             print(f"Skipping turn for {current_player_name} (dead or invalid).")
             env.advance_turn() # Needs implementation in Env
             continue

        agent = player.agent # Get agent associated with the player

        # Get observation for the current player
        observation = env.get_observation(current_player_name) # Needs implementation in Env

        # Agent decides action
        print(f"--- {current_player_name}'s Turn ({agent.__class__.__name__}) ---")
        action = agent.act(observation) # Agent returns action dict
        print(f"Action chosen: {action}")

        # Environment processes action
        success = env.process_player_action(current_player_name, action) # Needs implementation in Env
        if not success:
            print(f"Action {action} failed or was invalid.")

        # Optional: Track tokens
        # token_tracker.update(current_player_name, observation, action)

        # Environment potentially advances turn or phase based on action
        # This might happen inside process_player_action or require a separate env.advance() call

    print(f"\n--- Game Over ---")
    print(f"Winner: {env.state.winner.value if env.state.winner else 'Draw/Timeout'}")
    print(f"Ended on Day {env.state.day_count}, Phase {env.state.phase.name}")

    # Log final state and return results
    final_state_summary = log_game_summary(env.state) # Use analysis function
    final_state_summary["tokens_used"] = token_tracker.to_dict() # Add token info if tracked
    return final_state_summary


def run_multiple_simulations(num_games=10, config_path="config/default_game.json", save_dir="data/episodes"):
    """Runs multiple simulations based on a config file."""
    os.makedirs(save_dir, exist_ok=True)

    # Load base configuration (needs implementation)
    # base_game_config = load_config_from_file(config_path)
    # base_agent_config = base_game_config.get("agent_config", {}) # Separate agent config if needed
    base_game_config = {"roles": [ # Example default config
             {"name": "Player1", "role": "Cop"}, {"name": "Player2", "role": "Doctor"},
             {"name": "Player3", "role": "Villager"}, {"name": "Player4", "role": "Godfather"},
             {"name": "Player5", "role": "Goon"}
         ],
        "agent_mapping": {"Player1": "llm", "Player4": "llm"}, # P1 & P4 are LLMs
        "llm_config": {"model": "gpt-3.5-turbo"} # Example LLM config
     }
    base_agent_config = {} # Agent specific settings if needed


    game_results = []
    for i in tqdm(range(num_games), desc="Simulating Games"):
        game_id = str(uuid.uuid4())
        current_game_config = {**base_game_config, "game_id": game_id}
        # Add variations here if doing experiments (e.g., change roles, prompts)

        try:
            result = run_simulation(current_game_config, base_agent_config)
            game_results.append(result)

            # Save individual game logs as JSONL
            log_path = os.path.join(save_dir, "games_log.jsonl")
            with open(log_path, "a") as f:
                json.dump(result, f)
                f.write("\n")

        except Exception as e:
            print(f"\n!!!!!! Error during simulation {game_id} !!!!!!")
            print(f"Error: {e}")
            # Log error state if possible
            error_info = {"game_id": game_id, "status": "error", "error_message": str(e)}
            log_path = os.path.join(save_dir, "games_log.jsonl")
            with open(log_path, "a") as f:
                json.dump(error_info, f)
                f.write("\n")


    print(f"\n--- Simulation Run Complete ---")
    print(f"Saved {len(game_results)} game logs to {os.path.join(save_dir, 'games_log.jsonl')}")

    # --- Optional: Compute and print aggregate metrics ---
    # win_rates = compute_win_rate(game_results)
    # avg_tokens = compute_average_tokens(game_results)
    # avg_accuracy = compute_average_role_accuracy(game_results)
    # print("\nAggregate Metrics:")
    # print(f"Win Rates: {win_rates}")
    # print(f"Avg Tokens: {avg_tokens}")
    # print(f"Avg Role Accuracy: {avg_accuracy}")


# Helper for loading config (placeholder)
def load_config_from_file(path: str) -> Dict:
     print(f"Warning: Config loading not implemented. Using defaults. Tried path: {path}")
     # Implement actual JSON/YAML loading here
     return {}


# Need log_game_summary, compute_* from evaluation module
# Placeholder if not implemented yet
def log_game_summary(game_state): return {"game_id": game_state.game_id, "winner": game_state.winner.value if game_state.winner else None, "final_roles": game_state.final_player_roles}
# def compute_win_rate(results): return {}
# def compute_average_tokens(results): return {}
# def compute_average_role_accuracy(results): return 0.0


if __name__ == "__main__":
    # Example of how to run
    run_multiple_simulations(num_games=5, save_dir="output/sim_results")


# === __init__.py ===


# === agents\base.py ===
# mafia/agents/base.py
from abc import ABC, abstractmethod

class BaseAgent(ABC):
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def act(self, observation: dict) -> dict:
        """
        Returns an action dict like {"action": "accuse", "target": "Player3"}
        """
        pass


# === agents\llm_agent.py ===
# mafia/agents/llm_agent.py
import os
import openai
from mafia.agents.base import BaseAgent
from mafia.prompts.mafia_template import format_prompt, parse_response

class LLMAPIClientAgent(BaseAgent):
    def __init__(self, name: str, model: str = "gpt-4", system_prompt: str = None):
        super().__init__(name)
        self.model = model
        self.system_prompt = system_prompt or "You are playing the game Mafia. Reason carefully."
        self.client = openai.ChatCompletion  # Can be monkey-patched for DeepSeek etc.

    def act(self, observation: dict) -> dict:
        prompt = format_prompt(self.name, observation)
        messages = [
            {"role": "system", "content": self.system_prompt},
            {"role": "user", "content": prompt}
        ]
        response = self.client.create(
            model=self.model,
            messages=messages,
            temperature=0.7,
        )
        raw = response.choices[0].message.content.strip()
        return parse_response(raw)


# === agents\rule_agent.py ===


# === agents\__init__.py ===


# === evaluation\analysis.py ===
# mafia/evaluation/analysis.py
from typing import List, Dict

def log_game_summary(game_state) -> Dict:
    """
    Logs key metrics and summary data from a completed game.
    Returns a structured dictionary with faction, winners, predictions, etc.
    """
    summary = {
        "game_id": game_state.game_id,
        "winner": game_state.winner,
        "day_count": game_state.day_count,
        "players": [],
        "predictions": [],
        "votes": [],
        "whispers": [],
        "questions": [],
        "accusations": [],
    }

    for player in game_state.players:
        summary["players"].append({
            "name": player.name,
            "role": player.role.name,
            "faction": player.faction.value,
            "alive": player.alive,
        })

        for target, role in player.predicted_roles.items():
            summary["predictions"].append({
                "predictor": player.name,
                "target": target,
                "predicted_role": role
            })

        if player.vote:
            summary["votes"].append({
                "voter": player.name,
                "voted_for": player.vote
            })

        for target, whisper_text in player.whispers_sent.items():
            summary["whispers"].append({
                "from": player.name,
                "to": target,
                "content": whisper_text
            })

        for target, count in player.questions_asked.items():
            summary["questions"].append({
                "asker": player.name,
                "target": target,
                "times": count
            })

        if player.has_accused:
            summary["accusations"].append(player.name)

    return summary


# === evaluation\metrics.py ===
# mafia/evaluation/metrics.py
from collections import defaultdict
from typing import Dict, List


def compute_win_rate(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the win rate for each faction based on finished games.
    """
    results = defaultdict(int)
    for game in games:
        results[game["winner"]] += 1
    total = sum(results.values())
    return {faction: wins / total for faction, wins in results.items()}


def compute_average_tokens(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the average number of tokens used by each agent across games.
    """
    token_totals = defaultdict(int)
    token_counts = defaultdict(int)
    for game in games:
        for agent, tokens in game["tokens"].items():
            token_totals[agent] += tokens.get("input", 0) + tokens.get("output", 0)
            token_counts[agent] += 1
    return {
        agent: token_totals[agent] / token_counts[agent]
        for agent in token_totals
    }


def compute_average_role_accuracy(games: List[Dict]) -> float:
    """
    Computes how often role predictions were correct.
    """
    correct = 0
    total = 0
    for game in games:
        for entry in game["hidden_log"]:
            if "Predicted" in entry["info"]:
                # Format: "Predicted X as Y"
                parts = entry["info"].split()
                predicted_role = parts[-1]
                target = parts[1]
                actual_role = None
                for player in game["players"]:
                    if player["name"] == target:
                        actual_role = player["role"]
                        break
                if actual_role:
                    total += 1
                    if predicted_role == actual_role:
                        correct += 1
    return correct / total if total else 0.0


# === mechanics\messaging.py ===
# mafia/mechanics/messaging.py
from typing import Dict, List, Optional, Tuple
from mafia.enums import Phase

class Message:
    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):
        self.sender = sender              # Who sent the message
        self.content = content            # What was said (raw text or structured)
        self.target = target              # If whispering or targeting another player
        self.private = private            # Whisper if True, public otherwise

    def render(self) -> str:
        if self.private:
            return f"[WHISPER] {self.sender} â†’ {self.target}: {self.content}"
        elif self.target:
            return f"{self.sender} â†’ {self.target}: {self.content}"
        return f"{self.sender}: {self.content}"


class MessagingSystem:
    def __init__(self):
        self.history: List[Message] = []

    def send_public(self, sender: str, content: str):
        msg = Message(sender=sender, content=content)
        self.history.append(msg)
        return msg

    def send_private(self, sender: str, recipient: str, content: str):
        msg = Message(sender=sender, content=content, target=recipient, private=True)
        self.history.append(msg)
        return msg

    def get_visible_messages(self, player_name: str, phase: Phase) -> List[str]:
        visible = []
        for msg in self.history:
            if not msg.private:
                visible.append(msg.render())
            elif msg.private and (msg.sender == player_name or msg.target == player_name):
                visible.append(msg.render())
        return visible

    def get_all_messages(self) -> List[str]:
        return [msg.render() for msg in self.history]

    def clear(self):
        self.history.clear()

    def get_log_data(self) -> List[Dict]:
        return [{
            "sender": msg.sender,
            "target": msg.target,
            "private": msg.private,
            "content": msg.content
        } for msg in self.history]


# === mechanics\roles.py ===
from abc import ABC, abstractmethod
# Corrected import path assuming roles.py is inside mechanics
from mafia.enums import Faction
from typing import Optional, TYPE_CHECKING, Dict, Any

# Avoid circular import for type hinting
if TYPE_CHECKING:
    from mafia.player import Player
    from mafia.game_state import GameState


class Role(ABC):
    def __init__(self, name: str, faction: Faction):
        self.name = name
        self.faction = faction
        # Add alignment based on faction for consistency if needed elsewhere
        self.alignment = faction # Simple mapping for now

    @abstractmethod
    def get_role_description(self) -> str:
        """Return a string describing the role's abilities and goals."""
        pass

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Executes the role's night action.
        Target selection logic is handled by the Agent/Player, passed via target_name.
        Returns a dictionary representing the action taken or None.
        """
        return None # Default: No night action

    def can_act_at_night(self) -> bool:
        """Checks if the role has a meaningful night action."""
        # Check if the night_action method is overridden from the base class
        return self.__class__.night_action != Role.night_action

    def __repr__(self):
        # Use self.faction directly as it's an attribute
        return f"<{self.faction.value}:{self.name}>"

# ------------------- TOWN ROLES -------------------

class Villager(Role):
    def __init__(self):
        # Use direct value for consistency, or reference an enum if preferred
        super().__init__("Villager", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are a Villager. You have no special abilities. Find and lynch the Mafia."

    # night_action is inherited as None

class Cop(Role):
    def __init__(self):
        super().__init__("Cop", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia)."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        target_player = game_state.get_player(target_name) if target_name else None

        if target_player and target_player.alive:
            # Simplified: Godfather reads as Town unless detectable=True (add later)
            is_mafia = target_player.role.faction == Faction.MAFIA
            # Handle Godfather detection rule here if needed
            # Example: if isinstance(target_player.role, Godfather) and not game_state.config.get("godfather_detectable", False):
            #     result_faction = Faction.TOWN
            # else:
            result_faction = Faction.MAFIA if is_mafia else Faction.TOWN

            result_info = f"Investigated {target_player.name}: Result {result_faction.value}"
            player.log_hidden(game_state, f"\uD83D\uDD0E {result_info}")
            # Store result in player's memory
            player.memory.append({
                "type": "investigation_result",
                "day": game_state.day_count,
                "target": target_player.name,
                "result": result_faction.value
            })
            # Action registered for logging/tracking, actual info given via memory
            return {"type": "investigate", "target": target_player.name, "result": result_faction.value}
        elif target_name:
             player.log_hidden(game_state, f"\uD83D\uDD0E Tried to investigate {target_name}, but they were not found or dead.")
        return None

class Doctor(Role):
    def __init__(self):
        super().__init__("Doctor", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Doctor. Each night, you can choose one player to protect from death."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        target_player = game_state.get_player(target_name) if target_name else None

        if target_player and target_player.alive:
            # Protection handled centrally in night resolution based on this action
            player.log_hidden(game_state, f"\uD83E\uDE78 Protected {target_player.name}")
            return {"type": "protect", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83E\uDE78 Tried to protect {target_name}, but they were not found or dead.")
        return None

# ------------------- MAFIA ROLES -------------------

class Goon(Role):
    def __init__(self):
        super().__init__("Goon", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day."

    # night_action is inherited as None (kill decision by Godfather)

class Godfather(Role):
    def __init__(self):
        super().__init__("Godfather", Faction.MAFIA)
        self.appears_as = Faction.TOWN # To cops, unless detectable

    def get_role_description(self) -> str:
        return ("You are the Godfather. You appear as Town to the Cop. "
                "Each night, choose a target for the Mafia to kill. "
                "If you die, a Goon will be promoted.")

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        target_player = game_state.get_player(target_name) if target_name else None

        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83D\uDD2A Ordered kill on {target_player.name}")
            # Action registered, actual kill resolved centrally
            return {"type": "kill", "target": target_player.name}
        elif target_name:
             player.log_hidden(game_state, f"\uD83D\uDD2A Tried to order kill on {target_name}, but they were not found or dead.")
        return None

# Add other roles (RoleBlocker, Consigliere, etc.) here following the pattern...

# Helper function to get a role class from its name string (used in simulation setup)
# Place this at the end of the file or in a separate utility file
ROLE_CLASS_MAP = {
    "villager": Villager,
    "cop": Cop,
    "doctor": Doctor,
    "goon": Goon,
    "godfather": Godfather,
    # Add other roles here...
}

def get_role_class(role_name: str) -> Optional[type[Role]]:
    return ROLE_CLASS_MAP.get(role_name.lower())

# === mechanics\voting.py ===
# mafia/mechanics/voting.py
from typing import Dict, Optional
from mafia.enums import Phase
from mafia.game_state import GameState


def cast_vote(game_state: GameState, voter: str, target: str) -> None:
    """Player casts or changes vote for someone."""
    if game_state.phase != Phase.DAY or voter not in game_state.alive_players:
        return

    # Remove old vote if it exists
    if voter in game_state.voting_targets:
        prev_target = game_state.voting_targets[voter]
        if prev_target != target:
            game_state.messages.append(f"{voter} changed their vote from {prev_target} to {target}.")
    else:
        game_state.messages.append(f"{voter} has voted for {target}.")

    game_state.voting_targets[voter] = target
    check_accusation_threshold(game_state)


def retract_vote(game_state: GameState, voter: str) -> None:
    """Player retracts their vote."""
    if voter in game_state.voting_targets:
        prev = game_state.voting_targets.pop(voter)
        game_state.messages.append(f"{voter} retracted their vote on {prev}.")


def check_accusation_threshold(game_state: GameState, threshold: float = 0.5) -> None:
    """Automatically trigger accusation if a player reaches vote threshold."""
    vote_counts: Dict[str, int] = {}
    for target in game_state.voting_targets.values():
        vote_counts[target] = vote_counts.get(target, 0) + 1

    total_voters = len(game_state.alive_players)
    for target, count in vote_counts.items():
        if count / total_voters >= threshold and game_state.accused_player != target:
            game_state.accused_player = target
            game_state.messages.append(f"{target} has been accused and must now defend themselves.")


def confirm_lynch_vote(game_state: GameState, voter: str, confirm: bool) -> None:
    """Player confirms or denies the lynch after accusation."""
    if game_state.phase != Phase.DAY or not game_state.accused_player:
        return

    game_state.lynch_confirm_votes[voter] = confirm
    yes_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if vote)
    no_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if not vote)

    total_voters = len(game_state.alive_players)
    if yes_votes > total_voters // 2:
        game_state.messages.append(f"{game_state.accused_player} has been lynched by majority vote.")
        game_state.kill_player(game_state.accused_player)
        game_state.reset_votes()
    elif no_votes >= total_voters // 2:
        game_state.messages.append(f"{game_state.accused_player} has survived the vote.")
        game_state.reset_votes()


# --------------------------
# Whisper Mechanics
# --------------------------

def whisper(game_state: GameState, sender: str, recipient: str, message: str) -> None:
    """Send a whisper from one player to another. Hidden from all other agents."""
    if sender not in game_state.alive_players or recipient not in game_state.alive_players:
        return

    # Track hidden message to sender and recipient
    for player in game_state.players:
        if player.name in {sender, recipient}:
            player.log_hidden(game_state, f"[WHISPER] {sender} â†’ {recipient}: {message}")
        else:
            player.log_hidden(game_state, f"[WHISPER] {sender} â†’ {recipient}: <hidden>")

    # Log public metadata
    game_state.messages.append(f"{sender} whispered to {recipient}.")


# --------------------------
# Voting Visibility
# --------------------------

def get_vote_visibility(game_state: GameState) -> Dict[str, str]:
    """Return a dict of current votes (publicly visible for now)."""
    return {voter: target for voter, target in game_state.voting_targets.items()}


# === mechanics\__init__.py ===


# === prompts\mafia_template.py ===
def format_prompt(name: str, obs: dict) -> str:
    # Format as readable context for the agent
    lines = [f"Day {obs['day']} | Phase: {obs['phase']}"]
    lines.append("Alive: " + ", ".join(obs["alive"]))
    lines.append("Dead: " + ", ".join(obs["dead"]))
    lines.append("Messages:")
    lines.extend(obs["messages"])
    lines.append("What do you do next? Choose one action:")
    return "\n".join(lines)

def parse_response(response: str) -> dict:
    """
    Expects LLM to return something like:
    <action> accuse </action> <target> Player3 </target>
    """
    import re
    act = re.search(r"<action>(.*?)</action>", response)
    tgt = re.search(r"<target>(.*?)</target>", response)
    return {
        "action": act.group(1).strip().lower() if act else "pass",
        "target": tgt.group(1).strip() if tgt else None
    }


# === utils\token_cost.py ===


