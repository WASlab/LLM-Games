# === mafia\config.py ===


# === mafia\enums.py ===
from enum import Enum

class Faction(Enum):
    TOWN = "town"
    MAFIA = "mafia"
    NEUTRAL = "neutral" # Reserved for extensibility

class GamePhase(Enum):
    NIGHT = "night"
    DAY_DISCUSSION = "day_discussion"
    VOTING = "voting"
    DEFENSE = "defense" # Optional phase if accusation needs defense
    FINAL_VOTE = "final_vote" # Optional phase for final lynch decision
    GAME_OVER = "game_over"

class VoteType(Enum):
    ACCUSATION = "accusation" # Initial vote during day
    FINAL_GUILTY = "final_guilty" # Vote during final lynch
    FINAL_INNOCENT = "final_innocent" # Vote during final lynch
    SKIP = "skip" # Abstain from voting

# === mafia\environment.py ===
# === mafia/environment.py ===

import random
from collections import deque
from typing import Dict, List, Optional, Any, Tuple, Set

# Core project imports (ensure they match your directory structure)
from llm_games.mafia.game_state import GameState, GameMessage
from llm_games.mafia.player import Player
from llm_games.mafia.enums import GamePhase, Faction, VoteType
from llm_games.mafia.mechanics.roles import Cop, Godfather, RoleBlocker,Doctor
# If you have a RoleBlocker or Blackmailer, import them similarly:
# from llm_games.mafia.mechanics.roles import RoleBlocker, Blackmailer

# from llm_games.mafia.rewards import compute_rewards  # If/when using a reward system
# from llm_games.mafia.utils.token_cost import track_tokens  # If/when tracking token budgets

# Dummy placeholders if those modules are not yet implemented:
def compute_rewards(state) -> Dict[str, float]:
    """Placeholder if you have not implemented rewards yet."""
    return {}

class TokenTracker:
    """Placeholder if you want to track tokens or verbosity budgets."""
    def __init__(self):
        self.usage = {}

    def update(self, *args, **kwargs):
        pass

    def to_dict(self):
        return dict(self.usage)


class MafiaEnvironment:
    """
    Manages the overall flow, phases, action resolution, and messaging for a Mafia game.

    Key Features:
      - Night action resolution with roleblock → protect → kill → investigate ordering
      - Day discussion with round-robin speaking, optional questioning, accusations
      - Voting phases, including defense and final vote
      - Tie votes or lack of majority → no lynch → transition to Night
      - Basic checks for valid night targets (e.g., Godfather cannot target a fellow Mafia)
    """

    def __init__(self, players: List[Player], config: Dict[str, Any]):
        """
        :param players: Pre-created list of Player objects with assigned roles.
        :param config:  Dictionary of configuration options (e.g. 'lynch_defense_enabled', etc.).
        """
        self.config = config

        # Initialize the game state
        self.state = GameState(players=players, game_config=config)
        self.state.initialize()

        # Token/budget tracking if desired
        self.token_tracker = TokenTracker()

        # Various environment configs
        self.lynch_defense_enabled: bool = self.config.get("lynch_defense_enabled", True)
        self.cop_speaks_first: bool = self.config.get("cop_speaks_first", False)

        # Day phase tracking
        self._speaker_queue: deque[str] = deque()
        # Queue of (questioner, questioned) to handle immediate back-and-forth:
        self._question_queue: deque[Tuple[str, str]] = deque()
        self._turns_taken_this_round: Set[str] = set()
        self._consecutive_passes: int = 0

    # ----------------------------------------------------------------
    # Public Methods for Simulation Loop
    # ----------------------------------------------------------------

    def step_phase(self) -> bool:
        """
        Advances the game by one phase (e.g., from Night → Day or running the defense → final vote).
        Returns True if the game has ended, False otherwise.
        """
        if self.state.game_over:
            return True

        current_phase = self.state.phase

        if current_phase == GamePhase.NIGHT:
            self._resolve_night()
            self._transition_to_day()

        elif current_phase == GamePhase.DAY_DISCUSSION:
            # The discussion-phase turns are advanced by process_player_action or advance_turn.
            # step_phase can check if we need to end discussion automatically.
            if self._check_discussion_end():
                self._transition_to_voting()

        elif current_phase == GamePhase.VOTING:
            # In a simpler design, voting might be resolved automatically or by some timer logic.
            # Often, you transition out of VOTING once everyone has voted, but that can be
            # handled in process_player_action or an external runner. So we just do a no-op here.
            pass

        elif current_phase == GamePhase.DEFENSE:
            # Let the accused speak; then move on to final vote.
            self._run_defense()
            self._transition_to_final_vote()

        elif current_phase == GamePhase.FINAL_VOTE:
            # Once final votes are in (or forced), resolve lynch.
            self._resolve_lynch()
            self._transition_to_night()

        return self.state.check_game_end()

    def get_current_player_name(self) -> Optional[str]:
        """Returns the name of the player whose turn it is to act (during DAY_DISCUSSION)."""
        return self.state.current_player_turn

    def get_observation(self, player_name: str) -> Dict[str, Any]:
        """Returns an observation dict for the specified player (public messages, private info, etc.)."""
        return self.state.get_player_observation(player_name)

    def process_player_action(self, player_name: str, action: Dict[str, Any]) -> bool:
        """
        The main method for handling actions from a player's agent.
        Returns True if the action was processed successfully, False if invalid.
        """
        player = self.state.get_player(player_name)
        if not player or not player.alive:
            self.state.log_hidden(player_name, f"Ignored action {action}; player is dead or invalid.")
            return False

        # Check if it is actually this player's turn (in discussion) or if we allow free actions
        if self.state.phase == GamePhase.DAY_DISCUSSION:
            if self.state.current_player_turn != player_name:
                self.state.log_hidden(
                    player_name, 
                    f"Attempted action {action} but it is not {player_name}'s turn."
                )
                return False

        # Log the attempt
        self.state.log_hidden(player_name, f"Received action: {action}")
        action_type = action.get("action")
        target = action.get("target")
        content = action.get("content")
        self.token_tracker.update(player_name, action_type, content)

        success = False

        # ----------------------------------------------------------------
        # NIGHT ACTIONS
        # ----------------------------------------------------------------
        if self.state.phase == GamePhase.NIGHT:
            if player.can_act_at_night():
                # The player's role logic typically sets a night_action dict or returns None if invalid.
                player.night_target = target
                intended_action = player.perform_night_action(self.state)

                # Optionally, we enforce extra checks (e.g., Godfather cannot target mafia).
                intended_action = self._validate_night_action(player, intended_action)

                if intended_action:
                    self.state.register_night_action(player_name, intended_action)
                success = True  # We treat it as a valid "turn" even if no action is performed.
            else:
                self.state.log_hidden(player_name, "Tried to act at night but this role has no night action.")
                success = True

        # ----------------------------------------------------------------
        # DAY ACTIONS - Discussion Phase
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.DAY_DISCUSSION:
            success = self._process_day_discussion_action(player, action_type, target, content)

            # If the action was valid, move to next speaker (unless an immediate phase transition happens).
            if success and not self.state.player_on_trial:
                # If an accusation occurs, we transition to voting within the same turn, so skip advance_turn
                self.advance_turn()
            

        # ----------------------------------------------------------------
        # VOTING PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.VOTING:
            success = self._process_voting_phase_action(player, action_type, target, content)

        # ----------------------------------------------------------------
        # DEFENSE PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.DEFENSE:
            if player_name == self.state.player_on_trial:
                # The accused can make a statement (content) or pass
                if content:
                    self.state.log_message(player_name, f"(Defense) {content}")
                else:
                    self.state.log_message(player_name, "(Defense) [No statement provided]")
                success = True
            else:
                self.state.log_hidden(player_name, f"Not on trial; ignoring defense action.")
                success = False

        # ----------------------------------------------------------------
        # FINAL VOTE PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.FINAL_VOTE:
            success = self._process_final_vote_action(player, action)

        # ----------------------------------------------------------------
        # If action was valid but the day discussion is still ongoing, 
        # we might want to continue or see if we transition to next phase.
        # ----------------------------------------------------------------
        if not success:
            self.state.log_hidden(player_name, f"Action {action} could not be processed.")
        return success

    def advance_turn(self):
        """
        Advances to the next person's turn in the DAY_DISCUSSION phase,
        respecting any question queue ordering (the questioned player, then questioner’s response).
        """
        if self.state.phase != GamePhase.DAY_DISCUSSION:
            self.state.current_player_turn = None
            return

        # If we have a question queue, that takes priority
        if self._question_queue:
            questioner, questioned = self._question_queue.popleft()
            # The questioned player goes first
            self.state.current_player_turn = questioned
            self.state.turn_context = {"answering_question_from": questioner}

            # Then queue the questioner as next (a short follow-up), unless questioner == questioned
            if questioner != questioned:
                self._question_queue.appendleft((questioner, questioner))
            return

        # If the main speaker queue is empty, check discussion end or start a new round
        if not self._speaker_queue or self._consecutive_passes >= len(self.state.alive_players):
            self._transition_to_voting()
            return

        next_speaker = self._speaker_queue.popleft()
        self.state.current_player_turn = next_speaker
        self.state.turn_number_in_phase += 1
        self.state.turn_context = None

    # ----------------------------------------------------------------
    # Internal / Private Helpers
    # ----------------------------------------------------------------

    def _resolve_night(self):
        """Resolves all players' night actions in the correct order (roleblock, protect, kill, investigate, etc.)."""
        self.state.log_message("system", "Night ends. Resolving all night actions...")
        self.state.night_action_results.clear()
        submitted_actions = self.state.night_actions_submitted

        # 1. Roleblocks
        roleblocked_players: Set[str] = set()
        # 2. Blackmail
        blackmailed_players: Set[str] = set()

        for actor, action_dict in submitted_actions.items():
            if not self.state.is_alive(actor):
                continue  # Actor died mid-night somehow

            # e.g. if action_dict["type"] == "roleblock": ...
            # Example placeholder:
            if action_dict.get("type") == "roleblock":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    roleblocked_players.add(target)
                    self.state.log_hidden(
                        actor, f"Roleblocked {target} for the night."
                    )
            elif action_dict.get("type") == "blackmail":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    blackmailed_players.add(target)
                    self.state.log_hidden(actor, f"Blackmailed {target} for the day.")

        # Mark roleblocked players
        for blocked in roleblocked_players:
            p = self.state.get_player(blocked)
            if p:
                p.is_roleblocked = True

        # Mark blackmailed players so they can't speak tomorrow
        for bm in blackmailed_players:
            p = self.state.get_player(bm)
            if p:
                p.can_speak_today = False

        # 3. Protections
        protected: Dict[str, str] = {}
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "protect":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    # If multiple doctors protect the same target, the first or last might "win."
                    # Here we allow the first to stand; you can choose whichever convention you like.
                    if target not in protected:
                        protected[target] = actor
                        # For debug or future logic
                        target_p = self.state.get_player(target)
                        if target_p:
                            target_p.protected_by = actor
                        self.state.log_hidden(
                            actor, f"Protected {target} this night."
                        )

        # 4. Kills
        kills_attempted: List[Tuple[str, str]] = []
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "kill":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    kills_attempted.append((actor, target))
                    self.state.log_hidden(actor, f"Attempting kill on {target}.")

        successful_kills: Set[str] = set()
        for (killer, target) in kills_attempted:
            if target not in protected:
                successful_kills.add(target)
                self.state.log_hidden(killer, f"Kill on {target} succeeded.")
            else:
                doc = protected[target]
                self.state.log_hidden(killer, f"Kill on {target} failed (protected by {doc}).")
                self.state.log_hidden(doc, f"You successfully protected {target} from a kill.")

        # Apply kills
        deaths = []
        for victim in successful_kills:
            if self.state.is_alive(victim):
                self.state.kill_player(victim, reason="killed during night")
                deaths.append(victim)

        # 5. Investigations
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "investigate":
                target = action_dict.get("target")
                result = action_dict.get("result")
                # Cop/Consigliere logic typically updates the player's memory. 
                # We also store it in environment logs.
                self.state.log_hidden(
                    actor, f"Investigation result on {target}: {result}"
                )
                self.state.night_action_results[actor] = action_dict

        if deaths:
            # Alphabetical or by order of kills
            self.state.log_message(
                "system",
                f"The sun rises. The following were found dead: {', '.join(sorted(deaths))}."
            )
        else:
            self.state.log_message("system", "The sun rises. Miraculously, nobody died last night!")

    def _transition_to_day(self):
        """Moves the game into DAY_DISCUSSION, resetting relevant flags and re-initializing speaker queues."""
        self.state.log_hidden("system", "Transitioning to Day phase.")
        # Clear roleblock statuses, etc.
        for p in self.state.players:
            p.reset_night_state()

        # Switch to day
        self.state.phase = GamePhase.DAY_DISCUSSION
        self.state.day_count += 1
        self.state.reset_day_phase_state()

        # Start a fresh speaking queue
        self._start_new_discussion_round()
        self.state.log_message("system", f"Day {self.state.day_count} begins. Discuss and vote!")

    def _start_new_discussion_round(self):
        """Initializes or re-initializes the round-robin talk queue for the day discussion phase."""
        self._speaker_queue.clear()
        self._question_queue.clear()
        self._turns_taken_this_round.clear()
        self._consecutive_passes = 0
        self.state.turn_context = None
        self.state.turn_number_in_phase = 0

        alive_names = sorted(self.state.alive_players)
        # If config demands Cop speak first
        if self.cop_speaks_first:
            for name in alive_names:
                pl = self.state.get_player(name)
                if pl and isinstance(pl.role, Cop):
                    alive_names.remove(name)
                    alive_names.insert(0, name)
                    self.state.log_hidden("system", f"Cop ({name}) will speak first today.")
                    break

        self._speaker_queue.extend(alive_names)
        # Force the environment to choose the first speaker
        self.advance_turn()

    def _check_discussion_end(self) -> bool:
        alive_count = len(self.state.alive_players)
        # Set minimum turns: 1 turn each for Day 0, 2 for later days.
        min_turns = self.config.get("min_discussion_turns", 2)
        if self.state.day_count == 0:
            min_turns = 1

        # Count turns from the hidden log for each player during DAY_DISCUSSION.
        player_turn_counts = {p: 0 for p in self.state.alive_players}
        for entry in self.state.hidden_log:
            if entry.get("phase") == GamePhase.DAY_DISCUSSION.name and entry.get("actor") in player_turn_counts:
                player_turn_counts[entry["actor"]] += 1

        self.state.log_hidden("system", f"Discussion turn counts: {player_turn_counts}")

        # End discussion if all players have met the minimum turns.
        if all(count >= min_turns for count in player_turn_counts.values()):
            self.state.log_hidden("system", f"All players completed {min_turns} discussion turns. Ending discussion.")
            return True

        # Alternatively, if everyone passes consecutively.
        if self._consecutive_passes >= alive_count:
            self.state.log_hidden("system", "All players passed consecutively. Ending discussion.")
            return True

        return False


    def _transition_to_voting(self):
        """
        Day discussion → Voting on the accused (or skipping to night if no accusations).
        """
        if not self.state.player_on_trial:
            self.state.log_message("system", "No one was put on trial today.")
            self._transition_to_night()
            return

        self.state.log_message("system", f"{self.state.player_on_trial} is on trial!")
        self.state.votes_for_lynch.clear()

        if self.lynch_defense_enabled:
            self.state.phase = GamePhase.DEFENSE
            self.state.current_player_turn = self.state.player_on_trial
            self.state.log_message(
                "system",
                f"{self.state.player_on_trial}, you may speak in your defense."
            )
        else:
            # Skip defense and go directly to final vote
            self._transition_to_final_vote()

    def _run_defense(self):
        """
        A placeholder hook for the defense phase. 
        The simulation typically calls process_player_action(...) so the accused can make a statement.
        """
        self.state.log_hidden("system", f"Defense phase for {self.state.player_on_trial}.")

    def _transition_to_final_vote(self):
        """
        Moves from DEFENSE → FINAL_VOTE. 
        All alive players can vote guilty/innocent simultaneously or in a loop if you prefer.
        """
        self.state.phase = GamePhase.FINAL_VOTE
        self.state.current_player_turn = None
        self.state.votes_for_lynch.clear()
        self.state.log_message(
            "system",
            f"Final voting begins for {self.state.player_on_trial}. Vote GUILTY or INNOCENT."
        )

    def _resolve_lynch(self):
        """
        After the final vote, count how many guilty vs. innocent votes. 
        Majority (strictly >= half+1) => lynch. Otherwise, no lynch.
        """
        if not self.state.player_on_trial:
            self.state.log_hidden("system", "No player on trial, skipping lynch resolution.")
            return

        votes = self.state.votes_for_lynch
        guilty = sum(1 for is_guilty in votes.values() if is_guilty)
        innocent = len(votes) - guilty
        total_alive = len(self.state.alive_players)
        needed_for_lynch = (total_alive // 2) + 1

        self.state.log_message(
            "system",
            f"Vote Results for {self.state.player_on_trial}: "
            f"Guilty={guilty}, Innocent={innocent}. Need {needed_for_lynch} to lynch."
        )
        self.state.log_hidden("system", f"Final Votes: {votes}")

        if guilty >= needed_for_lynch:
            self.state.log_message("system", f"The town has decided to lynch {self.state.player_on_trial}!")
            self.state.kill_player(self.state.player_on_trial, reason="lynched")
        else:
            self.state.log_message("system", f"The vote is inconclusive, sparing {self.state.player_on_trial}.")

        self.state.player_on_trial = None

    def _transition_to_night(self):
        """
        Resets day state and transitions to NIGHT, unless the game has ended.
        Typically called after lynch resolution or if no trial occurred.
        """
        self.state.log_hidden("system", "Transitioning to Night phase.")
        if self.state.player_on_trial and self.state.phase != GamePhase.NIGHT:
            # If for some reason we haven't resolved the lynch yet, do it now
            self._resolve_lynch()

        if self.state.check_game_end():
            return  # If game ended from a lynch, stop here

        self.state.phase = GamePhase.NIGHT
        self.state.reset_night_phase_state()
        self.state.current_player_turn = None
        self.state.log_message("system", "Night falls. Mafia members, choose your targets...")

    def apply_rewards(self):
        """
        Optional: If you have a reward system, call it here to store or return
        partial or final rewards for each player/agent.
        """
        rewards = compute_rewards(self.state)
        self.state.log_hidden("system", f"Computed rewards (not saved): {rewards}")
        # Optionally store them in the GameState or return them

    # ----------------------------------------------------------------
    # Day-Phase Action Helpers
    # ----------------------------------------------------------------

    def _process_day_discussion_action(
        self, 
        player: Player, 
        action_type: str, 
        target: Optional[str], 
        content: Optional[str]
    ) -> bool:
        """
        Handle actions that can occur specifically in the DAY_DISCUSSION phase.
        Returns True if valid, False otherwise.
        """
        # Reset consecutive passes only if the action is not a "pass"
        if action_type == "pass":
            self._consecutive_passes += 1
            self.state.log_message(player.name, f"{player.name} passes.")
            # Mark that the player has taken a turn
            self._turns_taken_this_round.add(player.name)
            return True
        elif action_type == "accuse" and target:
            if self.state.day_count == 0:
                self.state.log_hidden(player.name, "Accusations are not allowed on Day 0.")
                return False
            success = player.accuse(target, self.state)
            if success:
                self.state.player_on_trial = target
            self._turns_taken_this_round.add(player.name)
            return success
        else:
            # They did something, so reset the pass counter
            self._consecutive_passes = 0

        # Accuse
        if action_type == "accuse" and target:
            if self.state.player_on_trial:
                self.state.log_hidden(player.name, "Cannot accuse; someone is already on trial.")
                return False
            success = player.accuse(target, self.state)
            if success:
                self.state.player_on_trial = target
            self._turns_taken_this_round.add(player.name)
            return success

        # Vote (during discussion, not final vote)
        elif action_type == "vote" and target:
            success = player.vote_for(target, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Question
        elif action_type == "question" and target and content:
            # Possibly limit # of questions per day, per target
            times_asked = player.questions_asked_today.get(target, 0)
            if times_asked >= 1:
                self.state.log_hidden(player.name, f"Question limit reached for {target}.")
                return False
            success = player.question(target, content, self.state)
            if success:
                player.questions_asked_today[target] = times_asked + 1
                # Add the Q&A flow to the question queue
                self._question_queue.append((player.name, target))
                # Then the questioner is scheduled to respond
                self._question_queue.append((player.name, player.name))
            self._turns_taken_this_round.add(player.name)
            return success

        # Predict role
        elif action_type == "predict" and target and content:
            success = player.predict_role(target, content, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Whisper
        elif action_type == "whisper" and target and content:
            success = player.whisper(target, content, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Generic talk
        elif action_type == "speak":
            if content:
                self.state.log_message(player.name, content)
                self._turns_taken_this_round.add(player.name)
                return True
            else:
                self.state.log_hidden(player.name, "Tried to speak but no content was provided.")
                return False

        # If none of the above matched, treat as invalid or a default "speak"
        if content:
            self.state.log_message(player.name, content)
            self._turns_taken_this_round.add(player.name)
            return True

        self.state.log_hidden(player.name, f"Invalid or unrecognized day action: {action_type}")
        return False

    def _process_voting_phase_action(
        self,
        player: Player,
        action_type: str,
        target: Optional[str],
        content: Optional[str]
    ) -> bool:
        """
        Handle standard voting phase (pre-defense or a simpler immediate-voting system).
        If you prefer all final votes to happen in FINAL_VOTE, you can keep this minimal.
        """
        if action_type == "vote" and target == self.state.player_on_trial:
            # If the environment merges "voting" and "final vote," you could do a direct guilty/innocent.
            # Otherwise, you might track 'vote_for_lynch' in the state, or do a simpler approach.
            player.vote_for(target, self.state)
            self.state.log_message(player.name, f"votes to lynch {target} in the standard voting phase.")
            return True

        # You can add logic for 'skip' or 'abstain' as well:
        elif action_type == "skip":
            self.state.log_message(player.name, f"{player.name} decides not to vote right now.")
            return True

        self.state.log_hidden(player.name, f"Invalid or mismatched action {action_type} in VOTING phase.")
        return False

    def _process_final_vote_action(self, player: Player, action: Dict[str, Any]) -> bool:
        """
        In FINAL_VOTE phase, each player declares GUILTY or INNOCENT (or possibly abstains).
        action might look like {"action": "vote", "vote_type": "final_guilty"}
        """
        action_type = action.get("action")
        vote_type_str = action.get("vote_type", "").lower()

        # Must be a "vote" action
        if action_type != "vote":
            self.state.log_hidden(player.name, f"Expected a vote action in FINAL_VOTE, got {action_type}.")
            return False

        if vote_type_str == "final_guilty":
            self.state.votes_for_lynch[player.name] = True
            self.state.log_message(
                player.name,
                f"votes GUILTY on {self.state.player_on_trial}."
            )
            return True
        elif vote_type_str == "final_innocent":
            self.state.votes_for_lynch[player.name] = False
            self.state.log_message(
                player.name,
                f"votes INNOCENT on {self.state.player_on_trial}."
            )
            return True
        elif vote_type_str == "abstain":
            self.state.log_message(player.name, f"abstains from voting.")
            return True
        else:
            self.state.log_hidden(
                player.name,
                f"Invalid final vote type: {vote_type_str} (expected 'final_guilty' or 'final_innocent')."
            )
            return False

    # ----------------------------------------------------------------
    # Night Action Validation
    # ----------------------------------------------------------------

    def _validate_night_action(self, player: Player, action_dict: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Optional: Enforces certain constraints on night actions:
          - Godfather cannot kill themselves or a fellow Mafia
          - Cop cannot investigate themselves
          - Roleblocker cannot block themselves
          - ...
        Return the action_dict if valid, or None if invalid.
        """
        if not action_dict:
            return None

        action_type = action_dict.get("type")
        target = action_dict.get("target")

        # Basic checks: must have a target
        if not target:
            self.state.log_hidden(player.name, "No target specified for night action.")
            return None

        # Cop cannot investigate self
        if action_type == "investigate" and target == player.name:
            self.state.log_hidden(player.name, "Cop tried to investigate themselves; invalid.")
            return None

        # Godfather can't kill themselves or mafia
        if action_type == "kill" and isinstance(player.role, Godfather):
            target_p = self.state.get_player(target)
            if target_p:
                if target_p.faction == Faction.MAFIA or target_p.name == player.name:
                    self.state.log_hidden(
                        player.name,
                        "Godfather tried to kill themselves or a fellow Mafia, invalid action."
                    )
                    return None

        # Roleblocker cannot block themselves (if you have a RoleBlocker role)
        if action_type == "roleblock" and isinstance(player.role, RoleBlocker):
            if target == player.name:
                self.state.log_hidden(player.name, "RoleBlocker tried to block themselves, invalid.")
                return None

        return action_dict


# === mafia\export.py ===
# export.py
import os
import json

def collect_python_files(root_dir: str) -> dict:
    file_structure = {}

    for dirpath, _, filenames in os.walk(root_dir):
        for file in filenames:
            if file.endswith('.py'):
                full_path = os.path.join(dirpath, file)
                rel_path = os.path.relpath(full_path, root_dir)
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                file_structure[rel_path] = content

    return file_structure

def export_to_json(output_path="code_snapshot.json", root="mafia"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(all_files, f, indent=2)

def export_to_text(output_path="code_snapshot.txt", root="llm_games"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        for path, content in all_files.items():
            f.write(f"# === {path} ===\n")
            f.write(content + "\n\n")

if __name__ == "__main__":
    export_to_json()
    export_to_text()
    print("✅ Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'")


# === mafia\game_state.py ===
# === mafia/game_state.py ===

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Any, Union
import uuid

# Core references to your enums, players, and roles:
from llm_games.mafia.enums import GamePhase, Faction
from llm_games.mafia.player import Player
from llm_games.mafia.mechanics.roles import Goon, Godfather, get_role_class

# -------------------------------------------------------------------
# Define the "type" of a single logged message, for clarity.
# Feel free to expand or rename these categories.
# -------------------------------------------------------------------
MESSAGE_TYPES = (
    "system",            # Internal system or phase announcements
    "public",            # Publicly spoken messages
    "whisper",           # Private whisper from A→B
    "vote",              # Voting or accusation messages
    "death_announcement" # Messages triggered on death
    # ... add "debug", "accusation", etc. as you see fit
)

@dataclass
class GameMessage:
    """Structured record of a single game message."""
    msg_type: str       # e.g. 'system', 'public', 'whisper', ...
    sender: str         # 'system' or player_name
    content: str
    recipients: Optional[List[str]] = None  # None means public
    phase: GamePhase = GamePhase.NIGHT
    day: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a serializable dict (helpful if you store logs as JSON)."""
        return {
            "type": self.msg_type,
            "sender": self.sender,
            "content": self.content,
            "recipients": self.recipients,
            "phase": self.phase.name,
            "day": self.day
        }


@dataclass
class GameState:
    """
    Central data store for a Mafia game:
      - Keeps track of players, alive/dead sets, messages, day/night transitions
      - Contains methods for logging and checking endgame
    """

    # ------------------------------
    # Core game setup
    # ------------------------------
    players: List[Player]
    game_config: Dict[str, Any] = field(default_factory=dict)  # e.g. "lynch_required": True, etc.

    # ------------------------------
    # Phase & Turn Tracking
    # ------------------------------
    phase: GamePhase = GamePhase.NIGHT
    day_count: int = 0
    turn_number_in_phase: int = 0
    current_player_turn: Optional[str] = None

    # Keep track of which players are alive or dead
    alive_players: Set[str] = field(default_factory=set)
    dead_players: Set[str] = field(default_factory=set)

    # ------------------------------
    # Logging
    # ------------------------------
    # Public and private logs
    messages: List[GameMessage] = field(default_factory=list)
    hidden_log: List[Dict[str, Any]] = field(default_factory=list)

    # ------------------------------
    # Accusation / Voting (Day)
    # ------------------------------
    # E.g. for a pre-trial voting system if you use it
    votes_for_accusation: Dict[str, str] = field(default_factory=dict)  # voter -> target
    accusation_counts: Dict[str, int] = field(default_factory=dict)     # target -> count

    # Which player is currently on trial (if any)
    player_on_trial: Optional[str] = None

    # Final-lunch votes: None = abstain, True = Guilty, False = Innocent
    votes_for_lynch: Dict[str, Optional[bool]] = field(default_factory=dict)

    # Token budgets for controlling how much players can speak (optional)
    discussion_token_budgets: Dict[str, int] = field(default_factory=dict)

    # ------------------------------
    # Night Phase Action Tracking
    # ------------------------------
    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)

    # ------------------------------
    # Game Identity & Completion
    # ------------------------------
    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    game_over: bool = False
    winner: Optional[Faction] = None
    final_player_roles: Dict[str, str] = field(default_factory=dict)  # e.g. "Alice": "Godfather"

    # Optional: track transitions or time-based info
    phase_history: List[Dict[str, Any]] = field(default_factory=list)

    # ----------------------------------------------------------------
    # Initialization & Setup
    # ----------------------------------------------------------------

    def initialize(self):
        """Called once at game start to populate initial states."""
        self.alive_players = {p.name for p in self.players}
        self.dead_players.clear()
        self.day_count = 0
        self.phase = GamePhase.NIGHT
        self.game_over = False
        self.winner = None
        self.messages.clear()
        self.hidden_log.clear()
        self.final_player_roles.clear()
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()

        # Reset each player's personal state
        for player in self.players:
            player.reset_for_new_game()
            # Optionally set token budgets if using
            # initial_tokens = self.game_config.get("initial_tokens", 999)
            # self.discussion_token_budgets[player.name] = initial_tokens

        # Example: record the start of the initial phase
        self.record_phase_start()

        # Log game creation
        self.log_message("system", "Game started.", msg_type="system")
        self.log_hidden("system", f"Game ID: {self.game_id}")
        self.log_hidden("system", f"Initial Roles: { {p.name: p.role.name for p in self.players} }")

    # ----------------------------------------------------------------
    # Player & Survival
    # ----------------------------------------------------------------

    def get_player(self, name: str) -> Optional[Player]:
        return next((p for p in self.players if p.name == name), None)

    def is_alive(self, name: str) -> bool:
        return name in self.alive_players

    def kill_player(self, name: str, reason: str = "killed"):
        """
        Officially kills a player:
          - Removes from alive_players
          - Logs death message
          - Checks if Godfather died => Goon promotion
          - Triggers check_game_end
        """
        if name not in self.alive_players:
            return  # Already dead or invalid

        player = self.get_player(name)
        if not player:
            return

        self.alive_players.remove(name)
        self.dead_players.add(name)
        player.alive = False

        self.log_message(
            "system",
            f"{name} ({player.role.name}) has died ({reason}).",
            msg_type="death_announcement"
        )
        self.log_hidden("system", f"{name} died. Reason: {reason}")

        # Check for Godfather death => Promote a Goon
        if isinstance(player.role, Godfather):
            self._promote_goon_to_gf(dead_gf_name=name)

        self.check_game_end()

    def _promote_goon_to_gf(self, dead_gf_name: str):
        """Promote the first alive Goon to Godfather upon GF death."""
        promoted_goon: Optional[Player] = None
        for p in self.players:
            if p.name in self.alive_players and isinstance(p.role, Goon):
                promoted_goon = p
                break

        if promoted_goon:
            new_role = Godfather()
            promoted_goon.role = new_role
            promoted_goon.faction = new_role.faction
            self.log_message(
                "system",
                f"{promoted_goon.name} has been promoted to Godfather!",
                msg_type="system"
            )
            self.log_hidden(
                promoted_goon.name,
                f"Promoted to Godfather after {dead_gf_name}'s death"
            )
        else:
            self.log_hidden("system", f"No Goon available to promote after {dead_gf_name} died.")

    # ----------------------------------------------------------------
    # Phase State Management
    # ----------------------------------------------------------------

    def reset_night_phase_state(self):
        """Clears any leftover actions/results from the previous night phase."""
        self.night_actions_submitted.clear()
        self.night_action_results.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            p = self.get_player(p_name)
            if p:
                p.reset_night_state()

    def reset_day_phase_state(self):
        """Clears day-specific data like accusations, lynch votes, and resets turn tracking."""
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            p = self.get_player(p_name)
            if p:
                p.reset_day_state()

    # ----------------------------------------------------------------
    # Accusation & Voting Threshold
    # ----------------------------------------------------------------

    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):
        """
        If your day logic uses an 'accuse to put on trial' mechanism,
        track each player's accusation and count how many times each target was accused.
        """
        if old_target and old_target in self.accusation_counts:
            self.accusation_counts[old_target] -= 1
            if self.accusation_counts[old_target] <= 0:
                del self.accusation_counts[old_target]

        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1
        self.votes_for_accusation[voter] = new_target

    def get_accusation_threshold(self) -> int:
        """
        Returns how many votes are needed to put someone on trial during discussion.
        By default, we use a majority threshold if not explicitly set.

        e.g. threshold = floor(#alive / 2) + 1
        """
        if "accusation_threshold" in self.game_config:
            return int(self.game_config["accusation_threshold"])
        # Default to simple majority
        return (len(self.alive_players) // 2) + 1

    def accusation_threshold_reached(self, target: str) -> bool:
        """Check if the accused has enough votes to start a trial."""
        needed = self.get_accusation_threshold()
        return self.accusation_counts.get(target, 0) >= needed

    # ----------------------------------------------------------------
    # Night Actions
    # ----------------------------------------------------------------

    def register_night_action(self, actor_name: str, action: Dict[str, Any]):
        """Stores the intended night action from a player. The environment resolves them later."""
        if not self.is_alive(actor_name):
            return
        self.night_actions_submitted[actor_name] = action
        self.log_hidden(actor_name, f"Submitted night action: {action}")

    # ----------------------------------------------------------------
    # Endgame Conditions
    # ----------------------------------------------------------------

    def check_game_end(self) -> bool:
        """
        Checks if the game has ended by evaluating basic Town vs Mafia logic (and optionally expansions).
        If a winner is found, we finalize the game and store final roles.
        """
        if self.game_over:
            return True  # Already ended

        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}
        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}
        # If you want to handle neutrals or special roles, do so here

        winner: Optional[Faction] = None

        # Example: Town wins if no mafia remain
        if not mafia_alive:
            winner = Faction.TOWN
        # Mafia wins if mafia >= town or the config-based rule
        elif len(mafia_alive) >= len(town_alive):
            winner = Faction.MAFIA

        # Add any additional conditions or neutrals logic here

        if winner:
            self.game_over = True
            self.winner = winner
            self.phase = GamePhase.GAME_OVER

            # Final role record
            self.final_player_roles = {p.name: p.role.name for p in self.players}

            self.log_message(
                "system",
                f"Game Over! Winner: {winner.value.upper()}",
                msg_type="system"
            )
            self.log_hidden("system", f"Final Roles: {self.final_player_roles}")
            return True

        return False

    # ----------------------------------------------------------------
    # Logging
    # ----------------------------------------------------------------

    def log_message(self,
                    sender: str,
                    content: str,
                    recipients: Optional[List[str]] = None,
                    msg_type: str = "public"):
        """
        Logs a message to the main game log with a specified type (system, whisper, etc.).
        If 'recipients' is None, it's public for all. Otherwise, only the given recipients can see it.
        """
        if msg_type not in MESSAGE_TYPES:
            msg_type = "public"  # fallback if unknown

        self.messages.append(
            GameMessage(
                msg_type=msg_type,
                sender=sender,
                content=content,
                recipients=recipients,
                phase=self.phase,
                day=self.day_count
            )
        )

    def log_hidden(self, actor: str, info: str):
        """
        Logs details that only certain debugging or hidden channels should see.
        Often used for debugging or system clarifications.
        """
        entry = {
            "actor": actor,
            "info": info,
            "phase": self.phase.name,
            "day": self.day_count,
            "turn": self.turn_number_in_phase
        }
        self.hidden_log.append(entry)

    # ----------------------------------------------------------------
    # Observations
    # ----------------------------------------------------------------

    def get_player_observation(self, player_name: str) -> Dict[str, Any]:
        """
        Generates a viewpoint for one player, including:
        - Visible public (and relevant private) messages.
        - A list of all players with appended status tags:
            * [DEAD]  if the player is eliminated.
            * [On Trial]  if the player is currently on trial.
            * [Mafia] (only visible to mafia players) if the player belongs to the mafia.
        - Other information about the game state.
        """
        player = self.get_player(player_name)
        if not player or not player.alive:
            return {
                "game_id": self.game_id,
                "player_name": player_name,
                "alive": False,
                "message": "You are no longer in the game."
            }

        # Prepare visible messages as before.
        visible_messages: List[str] = []
        for msg_obj in self.messages:
            # Validate the message object type.
            if not isinstance(msg_obj, GameMessage):
                self.log_hidden(player_name, f"Invalid message object (type={type(msg_obj)}): {msg_obj}")
                continue
            is_recip_private = (msg_obj.recipients is not None and player_name in msg_obj.recipients)
            is_sender_private = (msg_obj.sender == player_name and msg_obj.recipients is not None)
            if (msg_obj.recipients is None) or is_recip_private or is_sender_private:
                if msg_obj.msg_type == "whisper":
                    if is_sender_private:
                        visible_messages.append(f"(Whisper to {msg_obj.recipients[0]}) {msg_obj.content}")
                    elif is_recip_private:
                        visible_messages.append(f"(Whisper from {msg_obj.sender}) {msg_obj.content}")
                    else:
                        visible_messages.append(f"{msg_obj.sender}: {msg_obj.content}")
                else:
                    visible_messages.append(f"{msg_obj.sender}: {msg_obj.content}")

        # Create a formatted player list with status indicators.
        player_list = []
        for p in self.players:
            status_tags = []
            # Append [DEAD] if the player is not alive.
            if not p.alive:
                status_tags.append("DEAD")
            # Append [On Trial] if p is the player on trial.
            if self.player_on_trial == p.name:
                status_tags.append("On Trial")
            # If the observing player is Mafia, they see their own team tags.
            observer = self.get_player(player_name)
            if observer.faction == Faction.MAFIA and p.faction == Faction.MAFIA:
                status_tags.append("Mafia")
            # Combine the status tags.
            status_str = " [" + ", ".join(status_tags) + "]" if status_tags else ""
            player_list.append(f"{p.name}{status_str}")

        # Build the final observation dict.
        obs = {
            "game_id": self.game_id,
            "player_name": player.name,
            "role": player.role.name,
            "role_description": player.role.get_role_description(),
            "faction": player.faction.value,
            "phase": self.phase.name,
            "day": self.day_count,
            "turn": self.turn_number_in_phase,
            "is_current_turn": (self.current_player_turn == player.name),
            "alive_players": sorted(list(self.alive_players)),
            "dead_players": sorted(list(self.dead_players)),
            "player_list": player_list,  # Our new formatted player list with statuses
            "messages": visible_messages[-20:],  # Most recent 20 messages
            "can_speak": player.can_speak(),
            "can_act_tonight": (player.can_act_at_night() and self.phase == GamePhase.NIGHT),
            "player_on_trial": self.player_on_trial,
            "votes_for_accusation": dict(self.votes_for_accusation),
            "accusation_counts": dict(self.accusation_counts),
            "memory": list(player.memory),
            "is_roleblocked": player.is_roleblocked,
            "protected_by": player.protected_by,
            "lynch_votes": {voter: val for voter, val in self.votes_for_lynch.items()},
        }
        return obs


    # ----------------------------------------------------------------
    # Optional: Phase Tracking for Debug or Time-Aware Agents
    # ----------------------------------------------------------------

    def record_phase_start(self):
        """
        Record the beginning of a new phase for debugging or analysis.
        You might store timestamps, etc.
        """
        entry = {
            "phase": self.phase.name,
            "day": self.day_count,
            "turn_start": self.turn_number_in_phase,
            "timestamp": None  # set to datetime.now() if you want
        }
        self.phase_history.append(entry)

    def record_phase_end(self):
        """Mark the end of the current phase, e.g. to track how long each phase lasted."""
        if self.phase_history:
            self.phase_history[-1]["turn_end"] = self.turn_number_in_phase
            self.phase_history[-1]["end_timestamp"] = None  # if storing actual time

    # ----------------------------------------------------------------
    # Auditing / Debugging Tools
    # ----------------------------------------------------------------

    def get_game_summary(self) -> Dict[str, Any]:
        """
        Returns a structured summary of the game’s final state or current state.
        Useful for logs, testing, or replay.
        """
        summary = {
            "game_id": self.game_id,
            "phase": self.phase.name,
            "day_count": self.day_count,
            "game_over": self.game_over,
            "winner": self.winner.value if self.winner else None,
            "alive_players": sorted(list(self.alive_players)),
            "dead_players": sorted(list(self.dead_players)),
            "final_player_roles": dict(self.final_player_roles),
            "messages_count": len(self.messages),
            "hidden_log_count": len(self.hidden_log),
            "phase_history": self.phase_history,
        }
        return summary



# === mafia\player.py ===
from typing import Optional, Dict, List, Any
# Import the base Role class and Faction enum
from llm_games.mafia.mechanics.roles import Role
from llm_games.mafia.enums import Faction
from llm_games.mafia.mechanics.messaging import GameMessage
# Import GameState for type hinting only to avoid circular dependency
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from llm_games.mafia.game_state import GameState


class Player:
    def __init__(self, name: str, role: Role):
        self.name: str = name
        self.role: Role = role
        # Faction comes directly from the role object
        self.faction: Faction = self.role.faction
        self.alive: bool = True

        # Night action state
        self.night_target: Optional[str] = None  # Who the player chose to target
        self.is_roleblocked: bool = False
        self.protected_by: Optional[str] = None  # Who protected this player (e.g., Doctor's name)

        # Day state
        self.vote: Optional[str] = None  # For initial vote (e.g., accusation target)
        self.trial_vote: Optional[bool] = None  # For final trial vote (True=Guilty, False=Innocent, None=Abstain)
        self.discussion_tokens: int = 0  # Handled by environment/config
        self.can_speak_today: bool = True  # For effects like Blackmailer

        # Action tracking & Memory
        self.has_accused_today: bool = False
        self.predictions: Dict[str, str] = {}  # target_name -> predicted_role_name
        self.questions_asked_today: Dict[str, int] = {}  # target_name -> count
        self.whispers_sent_today: Dict[str, str] = {}  # target_name -> last_whisper_content

        # Memory for roles like Cop (to store investigation results, etc.)
        self.memory: List[Dict[str, Any]] = []

        # Optional: Track messages said/received for advanced agents
        self.messages_said: List[str] = []
        self.messages_received: List[str] = []

    def reset_for_new_game(self):
        """Resets player state for the start of a new game."""
        self.alive = True
        self.reset_night_state()
        self.reset_day_state()
        self.memory.clear()
        self.predictions.clear()
        # Reset message logs if desired
        self.messages_said.clear()
        self.messages_received.clear()

    def reset_night_state(self):
        """Resets state relevant to the night phase."""
        self.night_target = None
        self.is_roleblocked = False
        self.protected_by = None

    def reset_day_state(self):
        """Resets state relevant to the day phase."""
        self.vote = None
        self.trial_vote = None
        # discussion_tokens might be reset by environment based on config
        self.has_accused_today = False
        self.questions_asked_today.clear()
        self.whispers_sent_today.clear()
        self.can_speak_today = True  # Reset mute/blacklist effects

    def can_act_at_night(self) -> bool:
        """Check if player is alive and their role has a night action."""
        return self.alive and self.role.can_act_at_night()

    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:
        """
        Performs the player's role-specific night action.
        Assumes self.night_target has been set by the agent.
        Returns the action dict or None.
        """
        if not self.can_act_at_night() or self.is_roleblocked:
            if self.is_roleblocked:
                self.log_hidden(game_state, "Tried to act but was roleblocked.")
            return None
        return self.role.night_action(self, game_state, self.night_target)

    def can_speak(self) -> bool:
        """
        Returns whether the player is allowed to speak during the day.
        Can incorporate token budgets or mute effects if needed.
        """
        return self.alive and self.can_speak_today

    # --- Day Actions ---

    def accuse(self, target: str, game_state: 'GameState') -> bool:
        if not self.can_speak():
            self.log_hidden(game_state, f"Attempted to accuse {target} but cannot speak.")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to accuse {target} but they are dead or invalid.")
            return False

        # Allow re‑accusation: simply log the new accusation
        if self.has_accused_today:
            self.log_hidden(game_state, f"Re‑accusing: updating previous accusation to {target}.")
            # Optionally, update vote counts here if needed (via game_state.update_vote_counts)
        else:
            self.has_accused_today = True

        # Instead of appending a raw string, create a GameMessage.
        game_state.messages.append(GameMessage(
            msg_type="public",
            sender=self.name,
            content=f"{self.name} accuses {target}!",
            recipients=None,
            phase=game_state.phase,
            day=game_state.day_count
        ))
        return True


    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState') -> bool:
        """
        Predicts a player's role for internal analysis. Can be used to compare against actual role later.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player:
            return False

        self.predictions[target] = predicted_role_name
        self.log_hidden(game_state, f"Predicted {target} as {predicted_role_name}")
        return True

    def question(self, target: str, question_text: str, game_state: 'GameState') -> bool:
        """
        Sends a question to another player. The environment typically handles the Q&A flow.
        """
        if not self.can_speak():
            self.log_hidden(game_state, f"Attempted to question {target} but cannot speak.")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to question {target} but they are dead or invalid.")
            return False

        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1
        self.log_hidden(game_state, f"Asked {target}: {question_text}")
        game_state.messages.append(f"{self.name} asks {target}: \"{question_text}\"")
        return True

    def whisper(self, target: str, whisper_text: str, game_state: 'GameState') -> bool:
        """
        Sends a private message to another player. The content is hidden from public logs.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to whisper {target} but they are dead or invalid.")
            return False

        self.whispers_sent_today[target] = whisper_text
        self.log_hidden(game_state, f"Whispered to {target}: {whisper_text}")
        # For simplicity, append a placeholder to public messages (actual content remains hidden)
        game_state.messages.append(f"[WHISPER] {self.name} to {target}")
        return True

    def vote_for(self, target: str, game_state: 'GameState') -> bool:
        """
        Casts or changes a vote during the initial accusation phase.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to vote for {target} but they are dead or invalid.")
            return False

        old_vote = self.vote
        self.vote = target
        if old_vote and old_vote != target:
            log_msg = f"Changed vote from {old_vote} to {target}"
            public_msg = f"{self.name} changed vote to {target}."
        elif not old_vote:
            log_msg = f"Voted for {target}"
            public_msg = f"{self.name} voted for {target}."
        else:
            return True  # No change needed

        self.log_hidden(game_state, log_msg)
        game_state.messages.append(public_msg)
        game_state.update_vote_counts(self.name, old_vote, target)
        return True

    # --- Voting Phase: Final Trial Vote Support ---
    def cast_trial_vote(self, vote_type: str, game_state: 'GameState') -> bool:
        """
        Casts a final vote during the trial phase.
        vote_type should be one of: 'guilty', 'innocent', 'abstain'.
        This vote is stored separately as trial_vote.
        """
        if not self.alive:
            return False

        vt = vote_type.lower()
        if vt == "guilty":
            self.trial_vote = True
        elif vt == "innocent":
            self.trial_vote = False
        elif vt == "abstain":
            self.trial_vote = None
        else:
            self.log_hidden(game_state, f"Invalid trial vote type: {vote_type}")
            return False

        self.log_hidden(game_state, f"Cast final vote: {vote_type.upper()}")
        game_state.messages.append(f"{self.name} casts a final vote: {vote_type.upper()}.")
        return True

    def abstain_from_vote(self, game_state: 'GameState') -> bool:
        """
        Explicitly abstains from voting in the trial phase.
        """
        if not self.alive:
            return False

        self.trial_vote = None
        self.log_hidden(game_state, "Abstained from voting in the trial phase.")
        game_state.messages.append(f"{self.name} abstains from the final vote.")
        return True

    # --- LLM Action Interface ---
    def get_available_actions(self, game_state: 'GameState') -> List[Dict[str, Any]]:
        """
        Returns a structured list of available actions for this player.
        Each action is represented as a dict with a 'type' and optional 'params'.
        This helps LLM agents know what actions they can take.
        """
        if not self.alive:
            return []

        actions = []

        # Actions available during the day if the player can speak
        if self.can_speak():
            actions.append({"type": "speak", "params": ["content"]})
            actions.append({"type": "accuse", "params": ["target"]})
            actions.append({"type": "question", "params": ["target", "question_text"]})
            actions.append({"type": "predict", "params": ["target", "predicted_role"]})
            actions.append({"type": "whisper", "params": ["target", "whisper_text"]})

        # Actions available during night if the role can act
        if game_state.phase == game_state.phase.__class__.NIGHT and self.can_act_at_night():
            actions.append({"type": "night_action", "params": ["target"]})

        # Voting phase actions (both initial vote and trial vote)
        if game_state.phase.name in {"VOTING", "FINAL_VOTE"}:
            actions.append({"type": "vote", "params": ["target"]})
            actions.append({"type": "abstain", "params": []})
        # Final trial voting is separate from initial accusations
        if game_state.phase.name == "FINAL_VOTE":
            actions.append({"type": "cast_trial_vote", "params": ["vote_type (guilty/innocent/abstain)"]})

        return actions

    # --- Debugging / Serialization ---
    def to_dict(self) -> Dict[str, Any]:
        """
        Serializes the player's state into a dictionary for debugging or logging purposes.
        """
        return {
            "name": self.name,
            "role": self.role.name,
            "faction": self.faction.value,
            "alive": self.alive,
            "vote": self.vote,
            "trial_vote": self.trial_vote,
            "night_target": self.night_target,
            "memory": self.memory,
            "predictions": self.predictions,
            "questions_asked_today": self.questions_asked_today,
            "whispers_sent_today": self.whispers_sent_today,
        }

    def log_hidden(self, game_state: 'GameState', info: str):
        """
        Logs hidden information to the game state's hidden log.
        """
        game_state.log_hidden(self.name, info)

    def __repr__(self):
        status = 'Dead' if not self.alive else 'Alive'
        return f"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>"


# === mafia\play_test.py ===
# === mafia/play_test.py ===

# Import the main simulation runner function
from llm_games.mafia.simulation import run_simulation, run_multiple_simulations
import os

# --- Configuration for a Test Game ---
# This game uses 10 players: 1 LLM Cop, 1 LLM Godfather, and 8 RuleAgents.
# RuleAgents have specific strategies to test deception and game mechanics.
test_config = {
    "roles": [
        # Town Roles (7 players)
        {"name": "Alice",   "role": "Cop"},       # LLM Agent
        {"name": "Bob",     "role": "Doctor"},    # Rule Agent
        {"name": "Charlie", "role": "Villager"},  # Rule Agent (Aggressive)
        {"name": "David",   "role": "Villager"},  # Rule Agent
        {"name": "Eve",     "role": "Villager"},  # Rule Agent
        {"name": "Faythe",  "role": "Villager"},  # Rule Agent
        {"name": "Grace",   "role": "Villager"},  # Rule Agent

        # Mafia Roles (3 players)
        {"name": "Heidi",   "role": "Godfather"}, # LLM Agent
        {"name": "Ivan",    "role": "Goon"},      # Rule Agent (Claims Doctor)
        {"name": "Judy",    "role": "Goon"}       # Rule Agent
    ],

    # Agent Mapping: Specify which player gets which agent type
    "agent_mapping": {
        "Alice": "llm",      # Cop is an LLM
        "Bob": "rule",
        "Charlie": "rule",
        "David": "rule",
        "Eve": "rule",
        "Faythe": "rule",
        "Grace": "rule",
        "Heidi": "llm",      # Godfather is an LLM
        "Ivan": "rule",
        "Judy": "rule"
    },

    # --- Agent Configurations ---

    # Global LLM Agent Configuration (applied to Alice and Heidi)
    "llm_agent_config": {
        "backend_type": "dummy",  # IMPORTANT: Change to "openai", "local_api", etc. for real LLMs
        "model_identifier": "dummy-llm",
        # "api_key_env_var": "OPENAI_API_KEY", # Uncomment and set if using OpenAI
        # "local_api_endpoint": "http://localhost:11434/v1/chat/completions", # Example for Ollama
        "use_cot": True,         # Enable Chain-of-Thought prompting for LLMs
        "generation_params": {"temperature": 0.7, "max_tokens": 180}
    },

    # Global Rule Agent Strategy (base strategy for most rule agents)
    "rule_agent_strategy": {
        "always_accuse": False,        # Base rule agents are not overly aggressive
        "always_vote_guilty": False,   # Base rule agents use random voting logic
        "always_vote_innocent": False,
        # Add specific strategies per player below if needed
    },

    # --- Role/Player Specific Agent Overrides ---
    # Example: Override strategy for specific rule agents
    "roles": [
        # ... (previous role definitions) ...
        {"name": "Charlie", "role": "Villager", "agent_strategy": {"always_accuse": True, "always_vote_guilty": True}}, # Aggressive Townie
        {"name": "Ivan",    "role": "Goon",     "agent_strategy": {"claim_role": "Doctor", "always_vote_innocent": True}} # Mafia claiming Doctor
        # Note: The 'claim_role' is a custom strategy key the RuleAgent needs to be programmed to understand.
        #       You'd modify rule_agent.py to handle this. For now, it's illustrative.
    ],


    # --- Environment Configuration ---
    "max_steps": 150,                 # Max simulation steps before timeout
    "lynch_defense_enabled": True,   # Allow accused players to defend themselves
    "cop_speaks_first": False,        # Let discussion order be random initially
    "godfather_detectable": False,   # Godfather appears as Town to Cop
    "doctor_can_self_heal": True,    # Doctor can target themselves

    # Custom game ID for this test run
    "game_id": "test_llm_vs_rules_deception_v1"
}

# --- Main Execution Block ---
if __name__ == "__main__":
    print("=== Running Mafia Test Game: 1 LLM Cop, 1 LLM GF vs. 8 Rule Agents ===")
    print("Rule Agent Strategies:")
    print("  - Charlie (Villager): Always Accuses, Always Votes Guilty")
    print("  - Ivan (Goon): Will attempt to claim Doctor (needs RuleAgent update), Votes Innocent")
    print("  - Others: Standard random/passive rules")
    print("LLM Agents (Alice & Heidi): Using specified backend (currently Dummy) with CoT prompting.")

    # Run a single simulation with the defined test configuration
    # The `agent_config` parameter to run_simulation is less used now,
    # as agent configs are embedded within the main `test_config`.
    summary = run_simulation(game_config=test_config, agent_config=None) # agent_config=None is fine

    print("\n" + "="*20 + " Game Summary " + "="*20)
    if summary.get("status") == "error":
        print("!!! Simulation ended with an error !!!")
        print(f"Error Message: {summary.get('error_message', 'Unknown error')}")
    else:
        # Pretty print the summary dictionary
        for key, value in summary.items():
             if key == "token_usage" and isinstance(value, dict):
                  print(f"{key}:")
                  for agent, tokens in value.items():
                       print(f"  - {agent}: Input={tokens.get('input', 0)}, Output={tokens.get('output', 0)}")
             elif isinstance(value, list):
                  print(f"{key}: {', '.join(map(str, value))}")
             else:
                  print(f"{key}: {value}")

    print("="*54)

    # --- Optional: Run multiple games with this config ---
    # print("\n=== Running 3 simulations with the same test config ===")
    # run_multiple_simulations(
    #     num_games=3,
    #     base_config=test_config, # Use the config directly
    #     save_dir="output/test_llm_vs_rules_multi"
    # )

# === mafia\rewards.py ===
# mafia/rewards.py
from typing import Dict
from llm_games.mafia.enums import Faction


def assign_endgame_rewards(game_state) -> Dict[str, float]:
    """
    Assign final rewards to agents based on game outcome.
    Town agents get +1 for town win, -1 otherwise. Same for mafia.
    """
    rewards = {}
    for player in game_state.players:
        if player.faction.value == game_state.winner:
            rewards[player.name] = 1.0
        else:
            rewards[player.name] = -1.0
    return rewards


def assign_predict_role_reward(predicted: str, actual: str) -> float:
    return 0.5 if predicted == actual else -0.25


def assign_vote_reward(voter, target, game_state) -> float:
    """
    +1 if town correctly votes out mafia
    -1 if town votes town
    +0.5 if mafia avoids being voted
    """
    if not game_state.is_alive(target):  # Lynched
        if voter.faction == Faction.TOWN:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return 1.0
            else:
                return -1.0
        elif voter.faction == Faction.MAFIA:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return -1.0
            else:
                return 0.5
    return 0.0


def assign_speaking_reward(agent_name: str, token_used: int) -> float:
    """
    Optional: Reward for verbosity, or penalize excess verbosity.
    For now, neutral. Could be tuned.
    """
    return 0.0


def assign_question_reward(asker, target, game_state) -> float:
    """
    +0.2 for engaging others; could scale if target is mafia and asker is town
    """
    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:
        return 0.4
    return 0.2


# === mafia\simulation.py ===
# === mafia/simulation.py ===

import os
import json
import uuid
from typing import Dict, List, Optional

from tqdm import tqdm # Keep tqdm for progress bars

# Core project imports
from llm_games.mafia.environment import MafiaEnvironment
from llm_games.mafia.player import Player
from llm_games.mafia.mechanics.roles import get_role_class
from llm_games.mafia.agents.rule_agent import RuleAgent
from llm_games.mafia.agents.llm_agent import LLMAgent # Use the updated LLMAgent
from llm_games.mafia.enums import GamePhase, Faction # Import Faction for logging

# Basic Token Tracker (can be replaced with a more sophisticated one if needed)
class TokenTracker:
    def __init__(self):
        self.usage: Dict[str, Dict[str, int]] = {} # agent_name -> {"input": X, "output": Y}

    def update(self, agent_name: str, input_tokens: int = 0, output_tokens: int = 0):
        if agent_name not in self.usage:
            self.usage[agent_name] = {"input": 0, "output": 0}
        self.usage[agent_name]["input"] += input_tokens
        self.usage[agent_name]["output"] += output_tokens

    def to_dict(self) -> Dict[str, Dict[str, int]]:
        return dict(self.usage)

# Configuration Loading (Simple placeholder)
def load_config_from_file(path: str) -> Dict:
    """Loads game configuration from a JSON file."""
    try:
        with open(path, 'r', encoding='utf-8') as f:
            config = json.load(f)
            print(f"Successfully loaded configuration from {path}")
            return config
    except FileNotFoundError:
        print(f"Warning: Configuration file not found at {path}. Using default settings.")
        return {}
    except json.JSONDecodeError:
        print(f"Warning: Error decoding JSON from {path}. Using default settings.")
        return {}
    except Exception as e:
        print(f"Warning: An unexpected error occurred loading config from {path}: {e}. Using default settings.")
        return {}


def create_players_from_config(config: Dict) -> List[Player]:
    """Creates Player objects with assigned roles and agents based on the config."""
    players: List[Player] = []
    roles_config = config.get("roles", [])

    # Default setup if no roles are specified in config
    if not roles_config:
        print("Warning: No roles specified in config. Using default 5-player setup (Cop, Doctor, Villager, Godfather, Goon).")
        roles_config = [
            {"name": "Player1", "role": "Cop"},
            {"name": "Player2", "role": "Doctor"},
            {"name": "Player3", "role": "Villager"},
            {"name": "Player4", "role": "Godfather"},
            {"name": "Player5", "role": "Goon"}
        ]
        # Default agent mapping if none provided for the default roles
        if "agent_mapping" not in config:
             config["agent_mapping"] = {p["name"]: "rule" for p in roles_config}
             config["agent_mapping"]["Player1"] = "llm" # Example: Make Player1 an LLM by default
             config["agent_mapping"]["Player4"] = "llm" # Example: Make Player4 an LLM by default

    # Create players and assign agents
    agent_mapping = config.get("agent_mapping", {})
    llm_agent_config = config.get("llm_agent_config", {}) # Global LLM agent config
    rule_agent_strategy = config.get("rule_agent_strategy", {}) # Global Rule agent strategy

    for role_entry in roles_config:
        name = role_entry.get("name")
        role_name = role_entry.get("role")
        if not name or not role_name:
            print(f"Warning: Skipping invalid role entry in config: {role_entry}")
            continue

        RoleClass = get_role_class(role_name)
        if not RoleClass:
            print(f"Error: Unknown role name '{role_name}' for player {name}. Skipping.")
            # Or raise ValueError(f"Unknown role name '{role_name}'...")
            continue
        role_instance = RoleClass()
        player = Player(name=name, role=role_instance) # Create the player first

        # Determine agent type for this player
        agent_type = agent_mapping.get(name, "rule").lower() # Default to rule-based if not specified

        # Create the agent instance
        if agent_type == "llm":
            # Pass the specific player's name and potentially override global LLM config
            agent_specific_config = llm_agent_config.copy() # Start with global config
            agent_specific_config.update(role_entry.get("agent_config", {})) # Layer role-specific config
            # Ensure backend_type is set, default to dummy if needed
            if "backend_type" not in agent_specific_config:
                 agent_specific_config["backend_type"] = "dummy"

            agent = LLMAgent(
                name=name,
                config=agent_specific_config # Pass the combined config
            )
            print(f"  - Assigning LLMAgent ({agent.backend_type}/{agent.model_identifier}) to {name} ({role_name})")
        else: # Default to RuleAgent
            agent_specific_strategy = rule_agent_strategy.copy()
            agent_specific_strategy.update(role_entry.get("agent_strategy", {}))
            agent = RuleAgent(
                name=name,
                role=role_instance.name, # Pass the role name for rule logic
                strategy=agent_specific_strategy
             )
            print(f"  - Assigning RuleAgent to {name} ({role_name})")

        player.agent = agent # Assign the created agent to the player
        players.append(player)

    if not players:
         raise ValueError("No valid players could be created from the configuration.")

    return players


def log_game_summary(game_state, token_tracker: TokenTracker) -> Dict:
    """Creates a dictionary summarizing the completed game's results."""
    summary = {
        "game_id": game_state.game_id,
        "winner": game_state.winner.value if game_state.winner else "UNDECIDED",
        "final_roles": game_state.final_player_roles,
        "day_count": game_state.day_count,
        "total_steps": game_state.turn_number_in_phase, # Or track total steps separately
        "game_over_phase": game_state.phase.name,
        "alive_at_end": sorted(list(game_state.alive_players)),
        "dead_at_end": sorted(list(game_state.dead_players)),
        "token_usage": token_tracker.to_dict(),
        # Consider adding full message log or hidden log if needed for detailed analysis
        # "messages": [msg.to_dict() for msg in game_state.messages],
        # "hidden_log": list(game_state.hidden_log),
    }
    return summary


def run_simulation(game_config: Dict, agent_config: Optional[Dict]=None) -> Dict:
    """Runs a single game simulation from start to finish."""

    # --- Setup ---
    sim_id = game_config.get("game_id", str(uuid.uuid4()))
    print(f"\n--- Starting Mafia Simulation [ID: {sim_id}] ---")

    # Merge game_config and agent_config (agent_config is now primarily for LLMs)
    # The primary way to configure agents is now within the "roles" list in game_config
    # or using global configs like "llm_agent_config" and "rule_agent_strategy".
    combined_config = game_config.copy()
    if agent_config: # For backward compatibility or global overrides
        combined_config["llm_agent_config"] = {**combined_config.get("llm_agent_config", {}), **agent_config}


    print("Creating players and agents...")
    try:
        players = create_players_from_config(combined_config)
    except ValueError as e:
        print(f"Error setting up players: {e}")
        return {"game_id": sim_id, "status": "error", "message": str(e)}

    print("Initializing environment...")
    env = MafiaEnvironment(players=players, config=combined_config)
    env.state.game_id = sim_id # Ensure game state uses the provided ID

    token_tracker = TokenTracker() # Initialize token tracker
    max_steps = combined_config.get("max_steps", 150) # Sensible default max steps
    step_count = 0
    action_log = [] # Store (step, player, action) tuples

    print(f"Game starting... Max steps: {max_steps}")
    env.state.log_message("system", f"Simulation Start. Max steps: {max_steps}", msg_type="system")

    # --- Simulation Loop ---
    while not env.state.game_over and step_count < max_steps:
        step_count += 1
        current_phase = env.state.phase
        current_player_name = env.get_current_player_name() # Might be None

        print(f"\n>>> [Step {step_count}/{max_steps}] Day {env.state.day_count} | Phase: {current_phase.name} | Turn: {env.state.turn_number_in_phase} | Player: {current_player_name or 'System'} <<<")

        # --- Handle Phase Transitions / System Actions ---
        if current_player_name is None and current_phase not in {GamePhase.FINAL_VOTE, GamePhase.GAME_OVER}:
            # Environment needs to resolve something (e.g., night actions) or transition phase
            print("System turn: Resolving phase actions or transitioning...")
            phase_ended_game = env.step_phase() # step_phase advances state and returns True if game ends
            if phase_ended_game:
                 print("Game ended during system resolution.")
                 break
            continue # Move to next step after system action

        # --- Handle Player Actions ---
        active_players_in_phase: List[str] = []
        if current_phase == GamePhase.NIGHT:
             # All players with night actions act 'simultaneously' (submit actions)
             active_players_in_phase = [p.name for p in players if p.alive and p.can_act_at_night()]
             if not active_players_in_phase:
                  print("No players with night actions this night.")
                  env.step_phase() # Resolve night immediately
                  continue
        elif current_phase == GamePhase.FINAL_VOTE:
             # All alive players vote
             active_players_in_phase = list(env.state.alive_players)
             if not active_players_in_phase:
                  print("No alive players to conduct final vote.")
                  env.step_phase()
                  continue
        elif current_phase == GamePhase.DEFENSE:
             # Only the player on trial acts
             if env.state.player_on_trial and env.state.is_alive(env.state.player_on_trial):
                  active_players_in_phase = [env.state.player_on_trial]
             else:
                   print(f"Player on trial ({env.state.player_on_trial}) not available for defense.")
                   env.step_phase() # Move to final vote
                   continue
        elif current_phase == GamePhase.DAY_DISCUSSION:
             # Only the current player acts
             if current_player_name and env.state.is_alive(current_player_name):
                 active_players_in_phase = [current_player_name]
             elif current_player_name:
                  print(f"Skipping turn for {current_player_name} (dead or invalid).")
                  env.advance_turn() # Advance to next speaker
                  continue
             else: # Should have been caught earlier, but safety check
                  print("Error: Day discussion but no current player turn.")
                  env.step_phase() # Try to recover
                  continue
        elif current_phase == GamePhase.VOTING:
             # Handle initial voting if implemented - assuming merged into discussion/final vote for now
             print("Standard voting phase - assuming handled by accusation/final vote logic.")
             env.step_phase() # Skip this phase if logic isn't distinct
             continue
        else: # Game Over or unexpected state
              print(f"Phase {current_phase.name} does not require player actions or is unexpected.")
              break # Exit loop if game over

        # --- Process Actions for Active Players ---
        actions_processed_this_step = 0
        for p_name in active_players_in_phase:
            player = env.state.get_player(p_name)
            if not player or not player.alive:
                print(f"Skipping action for {p_name} (not found or dead).")
                continue

            # Get observation for the player
            observation = env.get_observation(p_name)

            # Agent decision
            agent = player.agent
            if not agent:
                 print(f"Error: Player {p_name} has no assigned agent!")
                 action = {"action": "pass", "content": "Agent missing."}
            else:
                 agent.observe(observation) # Agent sees the state
                 action = agent.act() # Agent decides action

            print(f"  - {p_name} ({player.role.name} / {player.faction.value}) chose: {action}")
            action_log.append((step_count, p_name, action)) # Log the chosen action

            # Environment processes the action
            success = env.process_player_action(p_name, action)
            if not success:
                print(f"    -> Action by {p_name} failed or was invalid.")
                # Optionally, give agent another chance or force pass? For now, just log.
                env.state.log_hidden(p_name, f"Action failed: {action}")

            actions_processed_this_step += 1
            # Note: Token tracking would happen within LLMAgent.act() or via callbacks

        # --- Advance Game State After Actions ---
        if current_phase == GamePhase.NIGHT:
             # After all night actions are submitted, resolve them and transition
             print("Resolving night actions...")
             env.step_phase()
        elif current_phase == GamePhase.FINAL_VOTE:
             # After all votes are cast, resolve the lynch and transition
             print("Resolving final votes...")
             env.step_phase()
        elif current_phase == GamePhase.DEFENSE:
             # After defense statement, transition to final vote
             print("Defense concluded, moving to final vote...")
             env.step_phase()
        elif current_phase == GamePhase.DAY_DISCUSSION:
              # If the action was successful and didn't trigger an immediate phase change (like accusation)
              # advance_turn was likely called within process_player_action or should be called if needed.
              # Check if discussion should end naturally (e.g., everyone passed)
              if env._check_discussion_end():
                   print("Discussion round ended.")
                   env._transition_to_voting() # Check if this leads to game end
                   if env.state.game_over: break
        # No explicit advancement needed for other handled phases (they transition within their logic)


    # --- End of Simulation ---
    print("\n" + "="*15 + " Game Over " + "="*15)
    if step_count >= max_steps:
        print(f"Simulation ended: Reached max steps ({max_steps}).")
        env.state.log_message("system", f"Game ended due to reaching max steps ({max_steps}).", msg_type="system")
        # Ensure game_over is set if not already
        if not env.state.game_over:
            env.state.game_over = True
            env.state.phase = GamePhase.GAME_OVER
            env.state.winner = None # Mark as undecided/timeout

    winner_faction = env.state.winner
    winner_str = winner_faction.value.upper() if winner_faction else "UNDECIDED (Timeout or Draw)"
    print(f"Winner: {winner_str}")
    print(f"Ended on Day {env.state.day_count}, Phase: {env.state.phase.name}")
    print(f"Final Roles: {env.state.final_player_roles}")
    print(f"Final Alive: {sorted(list(env.state.alive_players))}")

    # Generate and return summary
    summary = log_game_summary(env.state, token_tracker)
    # summary["action_log"] = action_log # Optionally include detailed action log

    print(f"--- Simulation Complete [ID: {sim_id}] ---")
    return summary


def run_multiple_simulations(num_games: int = 3, # Reduced default for quicker testing
                             config_path: Optional[str] = None, # Make config path optional
                             base_config: Optional[Dict] = None, # Allow passing config directly
                             save_dir: str = "output/sim_results"):
    """Runs multiple simulations and saves the results."""

    if not config_path and not base_config:
         print("Error: Must provide either a config_path or a base_config dictionary.")
         return

    if config_path and not base_config:
         print(f"Loading base configuration from: {config_path}")
         base_game_config = load_config_from_file(config_path)
         if not base_game_config: # Fallback if loading fails
              print("Using minimal default config for testing.")
              base_game_config = {
                   "roles": [{"name": f"P{i}", "role": "Villager"} for i in range(1, 6)],
                   "agent_mapping": {f"P{i}": "rule" for i in range(1, 6)},
                   "max_steps": 50
              }
    elif base_config:
         print("Using provided base configuration dictionary.")
         base_game_config = base_config
    else: # Both provided, maybe prefer direct config?
         print("Using provided base configuration dictionary (config_path ignored).")
         base_game_config = base_config


    # Ensure save directory exists
    try:
        os.makedirs(save_dir, exist_ok=True)
        log_file = os.path.join(save_dir, "mafia_games_log.jsonl")
        print(f"Results will be saved to: {log_file}")
    except OSError as e:
        print(f"Error creating save directory '{save_dir}': {e}. Results will not be saved.")
        log_file = None


    game_results = []
    error_count = 0

    print(f"\nRunning {num_games} Mafia simulations...")
    for i in tqdm(range(num_games), desc="Simulating Games"):
        game_id = f"sim_{i+1}_{str(uuid.uuid4())[:8]}" # Unique ID for each game run
        current_game_config = {**base_game_config, "game_id": game_id} # Add unique ID
        result = {}
        try:
            # Run the simulation - agent_config is now part of game_config
            result = run_simulation(game_config=current_game_config)
            result["status"] = "completed"
            game_results.append(result)
        except Exception as e:
            print(f"\n!!!!!! Critical Error during simulation {game_id} !!!!!!")
            import traceback
            traceback.print_exc() # Print detailed traceback
            print(f"Error: {e}")
            result = {"game_id": game_id, "status": "error", "error_message": str(e)}
            error_count += 1
            # Optionally save error info
            game_results.append(result) # Add error result to list

        # Save result incrementally to log file if possible
        if log_file:
            try:
                with open(log_file, "a", encoding="utf-8") as f:
                    # Convert Enum members in winner field to string before saving
                    if 'winner' in result and isinstance(result['winner'], Faction):
                         result['winner'] = result['winner'].value
                    json.dump(result, f)
                    f.write("\n")
            except IOError as e:
                 print(f"\nWarning: Could not write to log file {log_file}: {e}")
                 # Maybe disable logging for future iterations if it keeps failing?
                 # log_file = None
            except TypeError as e:
                 print(f"\nWarning: Could not serialize result for {game_id} to JSON: {e}")
                 print(f"Problematic result data: {result}")


    # --- Final Summary ---
    completed_games = len(game_results) - error_count
    print(f"\n=== Multi-Simulation Complete ===")
    print(f"Total Simulations Run: {num_games}")
    print(f"Successfully Completed: {completed_games}")
    print(f"Errors Encountered: {error_count}")
    if log_file and completed_games > 0:
        print(f"Results saved to: {log_file}")
    elif log_file and error_count > 0:
         print(f"Error details saved to: {log_file}")


    # Optional: Basic aggregate stats
    if completed_games > 0:
        winners = [g["winner"] for g in game_results if g.get("status") == "completed" and g.get("winner")]
        if winners:
            from collections import Counter
            win_counts = Counter(winners)
            print("\nFaction Win Distribution:")
            for faction, count in win_counts.items():
                 print(f"  - {faction}: {count} wins ({count/completed_games:.1%})")

def main():
    """Main entry point for running simulations."""
    # Example: Run 3 games using a configuration file
    # Ensure 'config/default_game.json' exists or change the path
    # config_file = "config/default_game.json"
    # if not os.path.exists(config_file):
    #     print(f"Warning: Config file '{config_file}' not found. Create one or use direct config.")
    #     # Minimal config if file doesn't exist
    #     default_config = {
    #         "roles": [{"name": "P1", "role": "Cop", "agent_mapping": "llm"}, {"name": "P2", "role": "Goon", "agent_mapping":"rule"}],
    #         "llm_agent_config": {"backend_type": "dummy"},
    #         "max_steps": 30
    #     }
    #     run_multiple_simulations(num_games=2, base_config=default_config, save_dir="output/test_dummy_sims")
    # else:
    #      run_multiple_simulations(num_games=3, config_path=config_file, save_dir="output/default_sims")

    # Example: Run directly with a config dictionary
    print("\nRunning simulation with direct config...")
    direct_config = {
            "roles": [
                {"name": "Alice",   "role": "Cop"},
                {"name": "Bob",     "role": "Doctor"},
                {"name": "Charlie", "role": "Villager"},
                {"name": "David",   "role": "Villager"},
                {"name": "Eve",     "role": "Villager"},
                {"name": "Heidi",   "role": "Godfather"},
                {"name": "Ivan",    "role": "Goon"},
                {"name": "Judy",    "role": "Goon"}
            ],
            "agent_mapping": { # Make Alice (Cop) and Heidi (GF) LLMs, others rules
                "Alice": "llm", "Bob": "rule", "Charlie": "rule", "David": "rule",
                "Eve": "rule", "Heidi": "llm", "Ivan": "rule", "Judy": "rule"
            },
            "llm_agent_config": { # Config for ALL LLM agents in this game
                 "backend_type": "dummy", # Change to "openai", "local_api" etc.
                 "model_identifier": "dummy-model",
                 #"api_key_env_var": "OPENAI_API_KEY", # If using OpenAI
                 #"local_api_endpoint": "http://localhost:11434/v1/chat/completions", # If using Ollama
                 "use_cot": False, # Enable Chain-of-Thought?
                 "generation_params": {"temperature": 0.6, "max_tokens": 200}
            },
             "rule_agent_strategy": { # Config for ALL Rule agents
                  "always_accuse": False, # Make rules less aggressive
                  "always_vote_guilty": False,
                  "always_vote_innocent": False,
             },
            "max_steps": 100,
            "lynch_defense_enabled": True,
            "cop_speaks_first": True,
        }
    run_multiple_simulations(num_games=1, base_config=direct_config, save_dir="output/direct_config_sim")


if __name__ == "__main__":
    main()

# === mafia\__init__.py ===


# === mafia\agents\base_agent.py ===
# === mafia/agents/base_agent.py ===

from abc import ABC, abstractmethod
from typing import Dict, Any

class BaseAgent(ABC):
    """
    Base abstract agent class for Mafia.
    Each agent must at least implement:
      - observe(observation): to receive environment state
      - act(): to return an action dictionary
      - reset(): optional, if the agent needs to reset between games
    """
    def __init__(self, name: str):
        self.name = name  # The agent’s name (should match player.name, but not strictly required)

    @abstractmethod
    def observe(self, observation: Dict[str, Any]):
        """
        Called by the environment or simulation to present the agent with
        the current game observation (public messages, roles, day/phase info, etc.).
        The agent should store it internally for decision making.
        """
        pass

    @abstractmethod
    def act(self) -> Dict[str, Any]:
        """
        Called after the agent has observed the environment state and must
        produce an action dictionary, e.g. {"action": "accuse", "target": "Alice"}.
        """
        pass

    def reset(self):
        """
        Optional: Clear internal memory or states if needed between episodes/games.
        """
        pass


# === mafia\agents\llm_agent.py ===
# === mafia/agents/llm_agent.py ===

import json
import os # Added for API key loading
from typing import Dict, Any, Optional, List

# Import necessary components from the project
from llm_games.mafia.agents.base_agent import BaseAgent
from llm_games.mafia.enums import GamePhase # Needed for phase-specific prompts

# Placeholder for actual LLM API clients (e.g., OpenAI, Anthropic, local vLLM/Ollama)
# You would replace these comments with actual imports and client initialization
# Example using OpenAI:
from openai import OpenAI
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# Example using a local model via requests:
# import requests
# LOCAL_MODEL_ENDPOINT = "http://localhost:8000/v1/completions" # Example for vLLM/Ollama OpenAI-compatible API

class LLMAgent(BaseAgent):
    """
    An LLM-powered agent that interacts with the environment using various model backends.
    Includes enhanced prompting based on game state and phase.
    """
    def __init__(self,
                 name: str,
                 # model_backend is now simplified, actual logic moved to act/helper
                 config: Optional[Dict[str, Any]] = None):
        """
        :param name: Agent/player name
        :param config: Configuration dictionary containing:
                       - model_identifier: (e.g., "gpt-4", "local_ollama_model")
                       - backend_type: ("openai", "anthropic", "local_api", "dummy")
                       - system_prompt_base: Base system prompt (optional, built dynamically if not provided)
                       - api_key_env_var: Environment variable name for API key (e.g., "OPENAI_API_KEY")
                       - local_api_endpoint: URL for local model inference endpoint
                       - generation_params: Dict of parameters for LLM generation (temperature, max_tokens, etc.)
                       - use_cot: Boolean flag to enable Chain-of-Thought prompting hints
        """
        super().__init__(name)
        self.config = config or {}
        self.last_observation: Optional[Dict[str, Any]] = None
        self.model_identifier = self.config.get("model_identifier", "gpt-3.5-turbo") # Default model
        self.backend_type = self.config.get("backend_type", "dummy") # Default to dummy
        self.api_key_env_var = self.config.get("api_key_env_var")
        self.local_api_endpoint = self.config.get("local_api_endpoint")
        self.generation_params = self.config.get("generation_params", {"temperature": 0.7, "max_tokens": 150})
        self.use_cot = self.config.get("use_cot", False) # Default CoT to false

        # --- Initialize Model Backend Client ---
        # This part needs to be adapted based on the chosen backend_type
        self.model_client = None
        if self.backend_type == "openai":
            # Example: Load OpenAI client
            # api_key = os.environ.get(self.api_key_env_var)
            # if not api_key:
            #     print(f"Warning: OpenAI API key not found in env var '{self.api_key_env_var}' for agent {self.name}")
            # else:
            #     # self.model_client = OpenAI(api_key=api_key)
            #     print(f"OpenAI client initialized for {self.name}")
            print(f"Placeholder: Initialize OpenAI client for {self.name} using model {self.model_identifier}")
        elif self.backend_type == "anthropic":
            # Example: Load Anthropic client
            # api_key = os.environ.get(self.api_key_env_var)
            # if not api_key:
            #     print(f"Warning: Anthropic API key not found in env var '{self.api_key_env_var}' for agent {self.name}")
            # else:
            #     # import anthropic
            #     # self.model_client = anthropic.Anthropic(api_key=api_key)
            #     print(f"Anthropic client initialized for {self.name}")
            print(f"Placeholder: Initialize Anthropic client for {self.name} using model {self.model_identifier}")
        elif self.backend_type == "local_api":
            if not self.local_api_endpoint:
                 print(f"Warning: Local API endpoint not configured for agent {self.name}")
            else:
                 print(f"Placeholder: Using local API endpoint {self.local_api_endpoint} for {self.name}")
        elif self.backend_type == "dummy":
            print(f"Agent {self.name} is using a dummy backend.")
        else:
            print(f"Warning: Unknown backend type '{self.backend_type}' for agent {self.name}. Using dummy.")
            self.backend_type = "dummy"
        # --- End Backend Initialization ---


    def observe(self, observation: Dict[str, Any]):
        """Stores the latest observation from the environment."""
        self.last_observation = observation

    def act(self) -> Dict[str, Any]:
        """Generates an action based on the last observation using the configured LLM backend."""
        if not self.last_observation:
            # Should not happen in normal flow, but good practice
            return {"action": "pass", "content": "No observation received yet."}

        # Build the prompt based on the current game phase and observation
        prompt = self.build_prompt(self.last_observation) # Now uses the enhanced build_prompt

        raw_output = ""
        try:
            # --- Call Appropriate Model Backend ---
            if self.backend_type == "openai" and self.model_client:
                # response = self.model_client.chat.completions.create(
                #     model=self.model_identifier,
                #     messages=[{"role": "system", "content": prompt}], # Simplification, consider history
                #     **self.generation_params
                # )
                # raw_output = response.choices[0].message.content
                raw_output = '{"action": "speak", "content": "Placeholder OpenAI response."}' # Placeholder
            elif self.backend_type == "anthropic" and self.model_client:
                 # response = self.model_client.messages.create(
                 #    model=self.model_identifier,
                 #    system=prompt, # Anthropic uses 'system' parameter
                 #    messages=[{"role": "user", "content": "What is your action?"}], # Example user message
                 #    **self.generation_params
                 # )
                 # raw_output = response.content[0].text
                 raw_output = '{"action": "vote", "target": "Bob", "vote_type": "final_guilty"}' # Placeholder
            elif self.backend_type == "local_api" and self.local_api_endpoint:
                # Example using requests for an OpenAI-compatible local API
                # headers = {"Content-Type": "application/json"}
                # if self.api_key_env_var: # If local API needs a key (e.g., LM Studio)
                #      headers["Authorization"] = f"Bearer {os.environ.get(self.api_key_env_var, 'dummy-key')}"
                # payload = {
                #     "model": self.model_identifier,
                #     "messages": [{"role": "system", "content": prompt}],
                #     **self.generation_params
                # }
                # response = requests.post(self.local_api_endpoint, headers=headers, json=payload)
                # response.raise_for_status() # Raise exception for bad status codes
                # raw_output = response.json()["choices"][0]["message"]["content"]
                 raw_output = '{"action": "night_action", "target": "Charlie"}' # Placeholder
            else: # Dummy backend
                raw_output = '{"action": "pass", "content": "Dummy agent takes a pass."}'
             # --- End Backend Call ---

        except Exception as e:
            print(f"Error during model inference for agent {self.name} (Backend: {self.backend_type}): {e}")
            # Fallback to a safe action like "pass" on error
            raw_output = '{"action": "pass", "content": "Error during generation."}'

        # Parse the LLM's raw output into a structured action dictionary
        action = self.parse_action(raw_output)
        return action

    def _format_player_list(self, obs: Dict[str, Any]) -> List[str]:
        """Formats the player list with status tags based on observation."""
        player_list_str = []
        all_players = obs.get("player_list", []) # Use the pre-formatted list from game_state
        
        # Fallback if player_list isn't provided directly
        if not all_players:
             alive = obs.get("alive_players", [])
             dead = obs.get("dead_players", [])
             on_trial = obs.get("player_on_trial")
             # Note: Mafia visibility would require more logic here if building from scratch
             for p_name in sorted(list(set(alive + dead))):
                  tags = []
                  if p_name in dead: tags.append("DEAD")
                  if p_name == on_trial: tags.append("On Trial")
                  # Mafia tag would need player object access - simplified here
                  status_str = f" [{', '.join(tags)}]" if tags else ""
                  player_list_str.append(f"{p_name}{status_str}")
        else:
            player_list_str = all_players # Use the already formatted list

        return player_list_str


    def build_prompt(self, obs: Dict[str, Any]) -> str:
        """
        Builds a comprehensive system prompt for the LLM agent based on the game state.
        Introduces the game, summarizes role/faction, describes phase logic,
        includes player lists, messages, and memory.
        """
        lines = []

        # --- Game Introduction & Role ---
        lines.append("=== Welcome to the Game of Mafia ===")
        lines.append(f"You are Player: {self.name}")
        lines.append(f"Your Role: {obs.get('role', 'Unknown Role')}")
        lines.append(f"Your Faction: {obs.get('faction', 'Unknown Faction').upper()}")
        lines.append(f"Your Objective: {obs.get('role_description', 'Win with your faction.')}")
        if obs.get('faction', '') == 'mafia' and obs.get('mafia_members', []):
             lines.append(f"Your Mafia Teammates (Alive): {', '.join(obs.get('mafia_members', []))}")

        # --- Current Game State ---
        lines.append("\n=== Current Game State ===")
        current_phase_str = obs.get('phase', 'unknown').replace('_', ' ').title()
        lines.append(f"Current Phase: {current_phase_str} (Day {obs.get('day', 0)})")
        if obs.get('is_current_turn', False):
             lines.append("It is currently YOUR TURN to act.")
        else:
             lines.append(f"It is currently {obs.get('current_player_turn', 'Someone')}'s turn.")

        # --- Player List ---
        lines.append("\n=== Players ===")
        player_list_formatted = self._format_player_list(obs)
        lines.extend([f"- {p}" for p in player_list_formatted])
        if obs.get('player_on_trial'):
            lines.append(f"Player on Trial: {obs.get('player_on_trial')}")


        # --- Recent Messages ---
        lines.append("\n=== Recent Messages (Last 20) ===")
        messages = obs.get("messages", [])
        if messages:
             lines.extend([f"- {msg}" for msg in messages])
        else:
             lines.append("- No messages yet in this phase.")

        # --- Memory / Known Information ---
        # Display investigation results, role peeks, etc.
        memory = obs.get("memory", [])
        if memory:
             lines.append("\n=== Your Private Memory ===")
             for mem_item in memory:
                  if mem_item.get("type") == "investigation_result":
                       lines.append(f"- Day {mem_item.get('day')}: Investigated {mem_item.get('target')} - Faction: {mem_item.get('result').upper()}")
                  elif mem_item.get("type") == "role_peek":
                        lines.append(f"- Day {mem_item.get('day')}: Saw {mem_item.get('target')}'s role - Role: {mem_item.get('role')}")
                  # Add other memory types as needed
                  else:
                       lines.append(f"- {mem_item}") # Generic display

        # --- Phase-Specific Instructions & Action Format ---
        lines.append("\n=== Your Task ===")
        current_phase_enum = GamePhase(obs.get('phase')) if obs.get('phase') in GamePhase._value2member_map_ else None

        # Use helper for phase-specific instructions
        phase_instructions = self._get_phase_instructions(current_phase_enum, obs)
        lines.extend(phase_instructions)

        # Add CoT hint if enabled
        if self.use_cot:
             lines.append("\nThink step-by-step about your goal, the current situation, potential threats/allies, and your best action. Then, provide your final action in the specified JSON format.")

        lines.append("\nOutput ONLY the JSON for your chosen action. Do not include any other text, explanation, or reasoning outside the JSON structure.")
        lines.append('Example JSON format: {"action": "ACTION_TYPE", "target": "PLAYER_NAME", "content": "Your message here", "vote_type": "GUILTY/INNOCENT"}')
        lines.append("Include ONLY the necessary fields for your chosen action type.")

        return "\n".join(lines)


    def _get_phase_instructions(self, phase: Optional[GamePhase], obs: Dict[str, Any]) -> List[str]:
        """ Provides specific instructions based on the current game phase. """
        instructions = []
        alive_players = obs.get("alive_players", [])
        valid_targets = [p for p in alive_players if p != self.name] # General valid targets

        if phase == GamePhase.NIGHT:
            instructions.append("It is Night. Choose your night action if applicable.")
            if obs.get('can_act_tonight', False):
                instructions.append("Select your target from the list of alive players.")
                instructions.append(f"Valid Targets: {', '.join(valid_targets) or 'None'}")
                instructions.append('Action JSON: {"action": "night_action", "target": "PLAYER_NAME"}')
            else:
                instructions.append("You have no action this night.")
                instructions.append('Action JSON: {"action": "pass"}')
        elif phase == GamePhase.DAY_DISCUSSION:
            instructions.append("It is the Day Discussion phase.")
            if obs.get('is_current_turn', False):
                 if obs.get("can_speak", True):
                     instructions.append("It's your turn to speak, accuse, question, or pass.")
                     instructions.append(" - To speak: {'action': 'speak', 'content': 'Your message...'}")
                     # Allow accusation only if no one is on trial and not Day 0
                     if not obs.get("player_on_trial") and obs.get("day", 0) > 0:
                         instructions.append(" - To accuse: {'action': 'accuse', 'target': 'PLAYER_NAME'}")
                     instructions.append(" - To question: {'action': 'question', 'target': 'PLAYER_NAME', 'content': 'Your question...'}")
                     # Add other actions like predict, whisper if implemented fully
                     instructions.append(" - To pass: {'action': 'pass'}")
                     instructions.append(f"Valid Targets for accuse/question: {', '.join(valid_targets) or 'None'}")
                 else:
                     instructions.append("You cannot speak this turn (e.g., blackmailed). You must pass.")
                     instructions.append('Action JSON: {"action": "pass"}')
            else:
                 instructions.append("It is not your turn. You cannot act now.")
                 # Technically agent shouldn't be asked to act if not its turn, but good to handle.
                 instructions.append('Action JSON: {"action": "pass"}') # Default safe action
        elif phase == GamePhase.VOTING:
             # This phase might be skipped or merged depending on config, but handle it
             instructions.append("It is the initial Voting Phase.")
             if obs.get("player_on_trial"):
                 instructions.append(f"You are voting on whether to proceed to a final trial for {obs.get('player_on_trial')}.")
                 instructions.append(" - To vote for trial: {'action': 'vote', 'target': 'PLAYER_ON_TRIAL_NAME'}") # Target is the accused
                 instructions.append(" - To skip/abstain: {'action': 'skip'}")
             else:
                 instructions.append("No one is currently on trial. This phase should transition.")
                 instructions.append('Action JSON: {"action": "pass"}')
        elif phase == GamePhase.DEFENSE:
             instructions.append("It is the Defense Phase.")
             if obs.get("player_on_trial") == self.name:
                 instructions.append("You are on trial! Speak in your defense.")
                 instructions.append('Action JSON: {"action": "speak", "content": "Your defense statement..."}')
             else:
                 instructions.append(f"{obs.get('player_on_trial')} is giving their defense. Wait for the Final Vote.")
                 instructions.append('Action JSON: {"action": "pass"}') # Cannot act if not on trial
        elif phase == GamePhase.FINAL_VOTE:
             instructions.append("It is the Final Vote Phase.")
             accused = obs.get('player_on_trial')
             if accused:
                instructions.append(f"Vote whether {accused} is GUILTY or INNOCENT.")
                instructions.append(" - Vote Guilty: {'action': 'vote', 'vote_type': 'final_guilty'}")
                instructions.append(" - Vote Innocent: {'action': 'vote', 'vote_type': 'final_innocent'}")
                # Optional Abstain:
                # instructions.append(" - Abstain: {'action': 'vote', 'vote_type': 'abstain'}")
             else:
                instructions.append("Error: Final Vote phase but no player on trial.")
                instructions.append('Action JSON: {"action": "pass"}')
        elif phase == GamePhase.GAME_OVER:
             instructions.append("The game is over.")
             winner = obs.get("winner")
             instructions.append(f"Winner: {winner.upper() if winner else 'Undecided'}")
             instructions.append('Action JSON: {"action": "pass"}') # No actions possible
        else: # Fallback
             instructions.append("Unknown game phase. Please pass.")
             instructions.append('Action JSON: {"action": "pass"}')

        return instructions


    def parse_action(self, response: str) -> Dict[str, Any]:
        """
        Attempts to parse the LLM's JSON output.
        Handles potential errors and defaults to a safe 'pass' action.
        """
        try:
            # Clean up potential markdown code blocks or leading/trailing text
            if "```json" in response:
                response = response.split("```json")[1].split("```")[0].strip()
            elif response.startswith("{") and response.endswith("}"):
                 response = response.strip()
            else:
                 # Try to find JSON within the response if it's not clean
                 start = response.find('{')
                 end = response.rfind('}')
                 if start != -1 and end != -1 and end > start:
                      response = response[start:end+1]
                 else:
                      # If still no valid JSON structure found, raise error
                      raise json.JSONDecodeError("No valid JSON object found in the response.", response, 0)


            # Parse the cleaned JSON string
            data = json.loads(response)

            # Basic validation: 'action' field is mandatory
            if "action" not in data or not isinstance(data["action"], str):
                print(f"Warning: LLM response for {self.name} missing 'action' field or invalid type. Raw: {response}")
                return {"action": "pass", "content": "Invalid action format received."}

            # Sanitize action dictionary (e.g., remove unexpected fields if necessary)
            # valid_keys = {"action", "target", "content", "vote_type"}
            # action_data = {k: v for k, v in data.items() if k in valid_keys}

            return data # Return the parsed (and potentially sanitized) action

        except json.JSONDecodeError as e:
            print(f"Error parsing JSON response for agent {self.name}: {e}")
            print(f"Raw response: {response}")
            # Fallback to pass on JSON errors
            return {"action": "pass", "content": "Failed to parse response."}
        except Exception as e: # Catch other potential errors
             print(f"Unexpected error parsing action for {self.name}: {e}")
             print(f"Raw response: {response}")
             return {"action": "pass", "content": "Unexpected error processing response."}

    def reset(self):
        """Resets the agent's state for a new game."""
        self.last_observation = None
        # Potentially clear conversation history if maintained internally
        print(f"Agent {self.name} reset for new game.")

# === mafia\agents\rule_agent.py ===
import random
from typing import Dict, Any, Optional
from llm_games.mafia.agents.base_agent import BaseAgent

class RuleAgent(BaseAgent):
    """
    A deterministic/strategy-based agent for testing.
    Useful for verifying environment correctness before using complex LLM behavior.
    """
    def __init__(self,
                 name: str,
                 role: Optional[str] = None,
                 strategy: Optional[Dict[str, Any]] = None,
                 seed: Optional[int] = None):
        super().__init__(name)
        self.player_role = (role or "").lower()
        self.strategy = strategy or {}
        self.rng = random.Random(seed)
        self.last_observation: Optional[Dict[str, Any]] = None
        self.max_discussion_turns = self.strategy.get("max_discussion_turns", 2)

    def observe(self, observation: Dict[str, Any]):
        self.last_observation = observation

    def act(self) -> Dict[str, Any]:
        if not self.last_observation:
            return {"action": "pass"}
        phase = self.last_observation.get("phase", "").lower()
        if phase == "night":
            return self._night_action()
        elif phase == "day_discussion":
            return self._day_discussion_action()
        elif phase == "defense":
            return self._defense_action()
        elif phase == "final_vote":
            return self._final_vote_action()
        else:
            return self._fallback_action()

    # ---------- Private Phase Logic ----------

    def _night_action(self) -> Dict[str, Any]:
        
        alive = self.last_observation.get("alive_players", [])
        if not alive:
            return {"action": "pass"}

        if self.player_role == "cop":
            target = self._choose_target(alive)
            return {"action": "investigate", "target": target}
        elif self.player_role == "doctor":
            return {"action": "protect", "target": self.name}
        elif self.player_role == "godfather":
            # Use mafia_members from observation (should be provided to mafia agents)
            mafia_members = self.last_observation.get("mafia_members", [])
            target_candidates = [p for p in alive if p not in mafia_members and p != self.name]
            if not target_candidates:
                return {"action": "pass"}
            target = self._choose_target(target_candidates)
            return {"action": "kill", "target": target}
        return {"action": "pass"}

    def _day_discussion_action(self) -> Dict[str, Any]:
        # Do not accuse if someone is already on trial
        if self.last_observation.get("player_on_trial"):
            return {"action": "pass"}

        # With some probability, issue an accusation (if it's our turn)
        if self.last_observation.get("is_current_turn", False) and self.rng.random() < 0.5:
            alive = self.last_observation.get("alive_players", [])
            if alive:
                target = self._choose_target(alive)
                return {"action": "accuse", "target": target}

        # Otherwise, if it's our turn, speak
        if self.last_observation.get("is_current_turn", False):
            return {"action": "speak", "content": f"{self.name} says something insightful."}

        return {"action": "pass"}

    def _defense_action(self) -> Dict[str, Any]:
        if self.last_observation.get("player_on_trial") == self.name:
            return {"action": "speak", "content": f"{self.name} defends themselves."}
        return {"action": "pass"}

    def _final_vote_action(self) -> Dict[str, Any]:
        if self.strategy.get("always_vote_guilty"):
            return {"action": "vote", "vote_type": "final_guilty"}
        elif self.strategy.get("always_vote_innocent"):
            return {"action": "vote", "vote_type": "final_innocent"}
        choice = self.rng.choice(["final_guilty", "final_innocent", "abstain"])
        return {"action": "vote", "vote_type": choice}

    def _fallback_action(self) -> Dict[str, Any]:
        return {"action": "pass"}

    # ---------- Helpers ----------
    def _choose_target(self, candidates: list) -> str:
        if not candidates:
            return self.name
        return self.rng.choice(candidates)

    @property
    def _alive_players(self) -> list:
        obs_alive = self.last_observation.get("alive_players", [])
        return [p for p in obs_alive if p != self.name]


# === mafia\agents\__init__.py ===


# === mafia\evaluation\analysis.py ===
# mafia/evaluation/analysis.py
from typing import List, Dict

def log_game_summary(game_state) -> Dict:
    """
    Logs key metrics and summary data from a completed game.
    Returns a structured dictionary with faction, winners, predictions, etc.
    """
    summary = {
        "game_id": game_state.game_id,
        "winner": game_state.winner,
        "day_count": game_state.day_count,
        "players": [],
        "predictions": [],
        "votes": [],
        "whispers": [],
        "questions": [],
        "accusations": [],
    }

    for player in game_state.players:
        summary["players"].append({
            "name": player.name,
            "role": player.role.name,
            "faction": player.faction.value,
            "alive": player.alive,
        })

        for target, role in player.predicted_roles.items():
            summary["predictions"].append({
                "predictor": player.name,
                "target": target,
                "predicted_role": role
            })

        if player.vote:
            summary["votes"].append({
                "voter": player.name,
                "voted_for": player.vote
            })

        for target, whisper_text in player.whispers_sent.items():
            summary["whispers"].append({
                "from": player.name,
                "to": target,
                "content": whisper_text
            })

        for target, count in player.questions_asked.items():
            summary["questions"].append({
                "asker": player.name,
                "target": target,
                "times": count
            })

        if player.has_accused:
            summary["accusations"].append(player.name)

    return summary


# === mafia\evaluation\metrics.py ===
# mafia/evaluation/metrics.py
from collections import defaultdict
from typing import Dict, List


def compute_win_rate(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the win rate for each faction based on finished games.
    """
    results = defaultdict(int)
    for game in games:
        results[game["winner"]] += 1
    total = sum(results.values())
    return {faction: wins / total for faction, wins in results.items()}


def compute_average_tokens(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the average number of tokens used by each agent across games.
    """
    token_totals = defaultdict(int)
    token_counts = defaultdict(int)
    for game in games:
        for agent, tokens in game["tokens"].items():
            token_totals[agent] += tokens.get("input", 0) + tokens.get("output", 0)
            token_counts[agent] += 1
    return {
        agent: token_totals[agent] / token_counts[agent]
        for agent in token_totals
    }


def compute_average_role_accuracy(games: List[Dict]) -> float:
    """
    Computes how often role predictions were correct.
    """
    correct = 0
    total = 0
    for game in games:
        for entry in game["hidden_log"]:
            if "Predicted" in entry["info"]:
                # Format: "Predicted X as Y"
                parts = entry["info"].split()
                predicted_role = parts[-1]
                target = parts[1]
                actual_role = None
                for player in game["players"]:
                    if player["name"] == target:
                        actual_role = player["role"]
                        break
                if actual_role:
                    total += 1
                    if predicted_role == actual_role:
                        correct += 1
    return correct / total if total else 0.0


# === mafia\mechanics\messaging.py ===
# mafia/mechanics/messaging.py
from typing import Dict, List, Optional, Tuple, Any

from dataclasses import dataclass, field
from llm_games.mafia.enums import GamePhase

@dataclass
class GameMessage:
    """Structured record of a single game message."""
    msg_type: str       # e.g. 'system', 'public', 'whisper', ...
    sender: str         # 'system' or player_name
    content: str
    recipients: Optional[List[str]] = None  # None means public
    phase: GamePhase = GamePhase.NIGHT
    day: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a serializable dict (helpful if you store logs as JSON)."""
        return {
            "type": self.msg_type,
            "sender": self.sender,
            "content": self.content,
            "recipients": self.recipients,
            "phase": self.phase.name,
            "day": self.day
        }
class Message:
    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):
        self.sender = sender              # Who sent the message
        self.content = content            # What was said (raw text or structured)
        self.target = target              # If whispering or targeting another player
        self.private = private            # Whisper if True, public otherwise

    def render(self) -> str:
        if self.private:
            return f"[WHISPER] {self.sender} → {self.target}: {self.content}"
        elif self.target:
            return f"{self.sender} → {self.target}: {self.content}"
        return f"{self.sender}: {self.content}"


class MessagingSystem:
    def __init__(self):
        self.history: List[Message] = []

    def send_public(self, sender: str, content: str):
        msg = Message(sender=sender, content=content)
        self.history.append(msg)
        return msg

    def send_private(self, sender: str, recipient: str, content: str):
        msg = Message(sender=sender, content=content, target=recipient, private=True)
        self.history.append(msg)
        return msg

    def get_visible_messages(self, player_name: str, phase: GamePhase) -> List[str]:
        visible = []
        for msg in self.history:
            if not msg.private:
                visible.append(msg.render())
            elif msg.private and (msg.sender == player_name or msg.target == player_name):
                visible.append(msg.render())
        return visible

    def get_all_messages(self) -> List[str]:
        return [msg.render() for msg in self.history]

    def clear(self):
        self.history.clear()

    def get_log_data(self) -> List[Dict]:
        return [{
            "sender": msg.sender,
            "target": msg.target,
            "private": msg.private,
            "content": msg.content
        } for msg in self.history]


# === mafia\mechanics\roles.py ===
# === mafia/mechanics/roles.py ===

from abc import ABC, abstractmethod
from llm_games.mafia.enums import Faction
from typing import Optional, TYPE_CHECKING, Dict, Any, List

# Avoid circular import for type hinting
if TYPE_CHECKING:
    from llm_games.mafia.player import Player
    from llm_games.mafia.game_state import GameState

class Role(ABC):
    def __init__(self, name: str, faction: Faction):
        self.name = name
        self.faction = faction
        # For now, we use faction as the alignment. Override if needed.
        self.alignment = faction

    @abstractmethod
    def get_role_description(self) -> str:
        """Return a string describing the role's abilities and goals."""
        pass

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Executes the role's night action.
        Target selection logic is handled by the agent/player.
        Returns a dict representing the action taken, or None.
        """
        return None  # Default: No night action

    def can_act_at_night(self) -> bool:
        """Checks if the role has a meaningful night action."""
        return self.__class__.night_action != Role.night_action

    def get_available_targets(self, player: 'Player', game_state: 'GameState') -> List[str]:
        """
        Returns a list of valid target player names.
        Default: any alive player except self.
        Override to add additional filters.
        """
        return [p.name for p in game_state.players if p.alive and p.name != player.name]

    def win_condition_met(self, player: 'Player', game_state: 'GameState') -> Optional[bool]:
        """
        Stub for roles with unique win conditions.
        Returns True if the player's win condition is met,
        False if failed, or None if undecided.
        """
        return None  # Default: rely on faction win

    def get_llm_schema(self) -> Dict[str, Any]:
        """
        Returns a dictionary with structured information about the role,
        useful for prompting LLM-based agents.
        """
        return {
            "name": self.name,
            "faction": self.faction.value,
            "alignment": self.alignment.value,
            "can_act_at_night": str(self.can_act_at_night()),
            "description": self.get_role_description()
        }

    def __repr__(self):
        return f"<{self.faction.value}:{self.name}>"

# ------------------- TOWN ROLES -------------------

class Villager(Role):
    def __init__(self):
        super().__init__("Villager", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are a Villager. You have no special abilities. Find and lynch the Mafia."

    # Inherits default night_action (None)

class Cop(Role):
    def __init__(self):
        super().__init__("Cop", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia)."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent self-investigation
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot investigate yourself.")
            return None

        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            # Handle Godfather detection: if target is a Godfather and game config dictates, appear as Town
            if isinstance(target_player.role, Godfather) and not game_state.game_config.get("godfather_detectable", False):
                result_faction = Faction.TOWN
            else:
                result_faction = target_player.role.faction

            result_info = f"Investigated {target_player.name}: Result {result_faction.value}"
            player.log_hidden(game_state, f"\uD83D\uDD0E {result_info}")
            player.memory.append({
                "type": "investigation_result",
                "day": game_state.day_count,
                "target": target_player.name,
                "result": result_faction.value
            })
            return {"type": "investigate", "target": target_player.name, "result": result_faction.value}
        elif target_name:
            player.log_hidden(game_state, f"\uD83D\uDD0E Tried to investigate {target_name}, but they were not found or dead.")
        return None

class Doctor(Role):
    def __init__(self):
        super().__init__("Doctor", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Doctor. Each night, you can choose one player to protect from death."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Optionally, disallow self-protection based on configuration.
        if target_name == player.name and not game_state.game_config.get("doctor_can_self_heal", True):
            player.log_hidden(game_state, "You cannot protect yourself tonight.")
            return None

        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83E\uDE78 Protected {target_player.name}")
            return {"type": "protect", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83E\uDE78 Tried to protect {target_name}, but they were not found or dead.")
        return None

# ------------------- MAFIA ROLES -------------------

class Goon(Role):
    def __init__(self):
        super().__init__("Goon", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day."

    # Inherits default night_action (None)

class Godfather(Role):
    def __init__(self):
        super().__init__("Godfather", Faction.MAFIA)
        self.appears_as = Faction.TOWN  # To cops, unless detectable

    def get_role_description(self) -> str:
        return ("You are the Godfather. You appear as Town to the Cop. "
                "Each night, choose a target for the Mafia to kill. "
                "If you die, a Goon will be promoted.")

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent self-targeting or targeting fellow Mafia
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot target yourself.")
            return None
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player:
            if target_player.faction == Faction.MAFIA:
                player.log_hidden(game_state, "You cannot order a kill on a fellow Mafia member.")
                return None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83D\uDD2A Ordered kill on {target_player.name}")
            return {"type": "kill", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83D\uDD2A Tried to order kill on {target_name}, but they were not found or dead.")
        return None

# ------------------- NEW ROLES -------------------

class RoleBlocker(Role):
    def __init__(self):
        super().__init__("RoleBlocker", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are the RoleBlocker. Each night, you can block another player's action."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent blocking self
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot roleblock yourself.")
            return None
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"Blocked {target_player.name}'s action")
            return {"type": "roleblock", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"Tried to block {target_name}, but they were not found or dead.")
        return None

class Consigliere(Role):
    def __init__(self):
        super().__init__("Consigliere", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are the Consigliere. Each night, you may learn the exact role of one player."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            role_name = target_player.role.name
            player.log_hidden(game_state, f"Investigated {target_player.name}: Role = {role_name}")
            player.memory.append({
                "type": "role_peek",
                "day": game_state.day_count,
                "target": target_player.name,
                "role": role_name
            })
            return {"type": "consigliere_investigate", "target": target_player.name, "result": role_name}
        elif target_name:
            player.log_hidden(game_state, f"Tried to investigate {target_name}, but they were not found or dead.")
        return None

# ------------------- OPTIONAL HELPER METHODS -------------------

# These can be overridden by individual roles if needed.
# For example, a role may override win_condition_met for unique victory conditions.
def default_win_condition(player: 'Player', game_state: 'GameState') -> Optional[bool]:
    return None

# ------------------- ROLE REGISTRY -------------------

ROLE_CLASS_MAP = {
    "villager": Villager,
    "cop": Cop,
    "doctor": Doctor,
    "goon": Goon,
    "godfather": Godfather,
    "roleblocker": RoleBlocker,
    "consigliere": Consigliere,
    # Add additional roles here...
}

def get_role_class(role_name: str) -> Optional[type[Role]]:
    return ROLE_CLASS_MAP.get(role_name.lower())


# === mafia\mechanics\__init__.py ===


# === mafia\prompts\mafia_template.py ===
def format_prompt(name: str, obs: dict) -> str:
    # Format as readable context for the agent
    lines = [f"Day {obs['day']} | Phase: {obs['phase']}"]
    lines.append("Alive: " + ", ".join(obs["alive"]))
    lines.append("Dead: " + ", ".join(obs["dead"]))
    lines.append("Messages:")
    lines.extend(obs["messages"])
    lines.append("What do you do next? Choose one action:")
    return "\n".join(lines)

def parse_response(response: str) -> dict:
    """
    Expects LLM to return something like:
    <action> accuse </action> <target> Player3 </target>
    """
    import re
    act = re.search(r"<action>(.*?)</action>", response)
    tgt = re.search(r"<target>(.*?)</target>", response)
    return {
        "action": act.group(1).strip().lower() if act else "pass",
        "target": tgt.group(1).strip() if tgt else None
    }


# === mafia\utils\token_cost.py ===


