# === config.py ===


# === enums.py ===
from enum import Enum

class Faction(Enum):
    TOWN = "town"
    MAFIA = "mafia"
    NEUTRAL = "neutral" # Reserved for extensibility

class GamePhase(Enum):
    NIGHT = "night"
    DAY_DISCUSSION = "day_discussion"
    VOTING = "voting"
    DEFENSE = "defense" # Optional phase if accusation needs defense
    FINAL_VOTE = "final_vote" # Optional phase for final lynch decision
    GAME_OVER = "game_over"

class VoteType(Enum):
    ACCUSATION = "accusation" # Initial vote during day
    FINAL_GUILTY = "final_guilty" # Vote during final lynch
    FINAL_INNOCENT = "final_innocent" # Vote during final lynch
    SKIP = "skip" # Abstain from voting

# === environment.py ===
# === mafia/environment.py ===

import random
from collections import deque
from typing import Dict, List, Optional, Any, Tuple, Set

# Core project imports (ensure they match your directory structure)
from mafia.game_state import GameState
from mafia.player import Player
from mafia.enums import GamePhase, Faction, VoteType
from mafia.mechanics.roles import Cop, Godfather, Roleblocker,Doctor
# If you have a RoleBlocker or Blackmailer, import them similarly:
# from mafia.mechanics.roles import RoleBlocker, Blackmailer

# from mafia.rewards import compute_rewards  # If/when using a reward system
# from mafia.utils.token_cost import track_tokens  # If/when tracking token budgets

# Dummy placeholders if those modules are not yet implemented:
def compute_rewards(state) -> Dict[str, float]:
    """Placeholder if you have not implemented rewards yet."""
    return {}

class TokenTracker:
    """Placeholder if you want to track tokens or verbosity budgets."""
    def __init__(self):
        self.usage = {}

    def update(self, *args, **kwargs):
        pass

    def to_dict(self):
        return dict(self.usage)


class MafiaEnvironment:
    """
    Manages the overall flow, phases, action resolution, and messaging for a Mafia game.

    Key Features:
      - Night action resolution with roleblock → protect → kill → investigate ordering
      - Day discussion with round-robin speaking, optional questioning, accusations
      - Voting phases, including defense and final vote
      - Tie votes or lack of majority → no lynch → transition to Night
      - Basic checks for valid night targets (e.g., Godfather cannot target a fellow Mafia)
    """

    def __init__(self, players: List[Player], config: Dict[str, Any]):
        """
        :param players: Pre-created list of Player objects with assigned roles.
        :param config:  Dictionary of configuration options (e.g. 'lynch_defense_enabled', etc.).
        """
        self.config = config

        # Initialize the game state
        self.state = GameState(players=players, game_config=config)
        self.state.initialize()

        # Token/budget tracking if desired
        self.token_tracker = TokenTracker()

        # Various environment configs
        self.lynch_defense_enabled: bool = self.config.get("lynch_defense_enabled", True)
        self.cop_speaks_first: bool = self.config.get("cop_speaks_first", False)

        # Day phase tracking
        self._speaker_queue: deque[str] = deque()
        # Queue of (questioner, questioned) to handle immediate back-and-forth:
        self._question_queue: deque[Tuple[str, str]] = deque()
        self._turns_taken_this_round: Set[str] = set()
        self._consecutive_passes: int = 0

    # ----------------------------------------------------------------
    # Public Methods for Simulation Loop
    # ----------------------------------------------------------------

    def step_phase(self) -> bool:
        """
        Advances the game by one phase (e.g., from Night → Day or running the defense → final vote).
        Returns True if the game has ended, False otherwise.
        """
        if self.state.game_over:
            return True

        current_phase = self.state.phase

        if current_phase == GamePhase.NIGHT:
            self._resolve_night()
            self._transition_to_day()

        elif current_phase == GamePhase.DAY_DISCUSSION:
            # The discussion-phase turns are advanced by process_player_action or advance_turn.
            # step_phase can check if we need to end discussion automatically.
            if self._check_discussion_end():
                self._transition_to_voting()

        elif current_phase == GamePhase.VOTING:
            # In a simpler design, voting might be resolved automatically or by some timer logic.
            # Often, you transition out of VOTING once everyone has voted, but that can be
            # handled in process_player_action or an external runner. So we just do a no-op here.
            pass

        elif current_phase == GamePhase.DEFENSE:
            # Let the accused speak; then move on to final vote.
            self._run_defense()
            self._transition_to_final_vote()

        elif current_phase == GamePhase.FINAL_VOTE:
            # Once final votes are in (or forced), resolve lynch.
            self._resolve_lynch()
            self._transition_to_night()

        return self.state.check_game_end()

    def get_current_player_name(self) -> Optional[str]:
        """Returns the name of the player whose turn it is to act (during DAY_DISCUSSION)."""
        return self.state.current_player_turn

    def get_observation(self, player_name: str) -> Dict[str, Any]:
        """Returns an observation dict for the specified player (public messages, private info, etc.)."""
        return self.state.get_player_observation(player_name)

    def process_player_action(self, player_name: str, action: Dict[str, Any]) -> bool:
        """
        The main method for handling actions from a player's agent.
        Returns True if the action was processed successfully, False if invalid.
        """
        player = self.state.get_player(player_name)
        if not player or not player.alive:
            self.state.log_hidden(player_name, f"Ignored action {action}; player is dead or invalid.")
            return False

        # Check if it is actually this player's turn (in discussion) or if we allow free actions
        if self.state.phase == GamePhase.DAY_DISCUSSION:
            if self.state.current_player_turn != player_name:
                self.state.log_hidden(
                    player_name, 
                    f"Attempted action {action} but it is not {player_name}'s turn."
                )
                return False

        # Log the attempt
        self.state.log_hidden(player_name, f"Received action: {action}")
        action_type = action.get("action")
        target = action.get("target")
        content = action.get("content")
        self.token_tracker.update(player_name, action_type, content)

        success = False

        # ----------------------------------------------------------------
        # NIGHT ACTIONS
        # ----------------------------------------------------------------
        if self.state.phase == GamePhase.NIGHT:
            if player.can_act_at_night():
                # The player's role logic typically sets a night_action dict or returns None if invalid.
                player.night_target = target
                intended_action = player.perform_night_action(self.state)

                # Optionally, we enforce extra checks (e.g., Godfather cannot target mafia).
                intended_action = self._validate_night_action(player, intended_action)

                if intended_action:
                    self.state.register_night_action(player_name, intended_action)
                success = True  # We treat it as a valid "turn" even if no action is performed.
            else:
                self.state.log_hidden(player_name, "Tried to act at night but this role has no night action.")
                success = True

        # ----------------------------------------------------------------
        # DAY ACTIONS - Discussion Phase
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.DAY_DISCUSSION:
            success = self._process_day_discussion_action(player, action_type, target, content)

            # If the action was valid, move to next speaker (unless an immediate phase transition happens).
            if success and not self.state.player_on_trial:
                # If an accusation occurs, we transition to voting within the same turn, so skip advance_turn
                self.advance_turn()

        # ----------------------------------------------------------------
        # VOTING PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.VOTING:
            success = self._process_voting_phase_action(player, action_type, target, content)

        # ----------------------------------------------------------------
        # DEFENSE PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.DEFENSE:
            if player_name == self.state.player_on_trial:
                # The accused can make a statement (content) or pass
                if content:
                    self.state.log_message(player_name, f"(Defense) {content}")
                else:
                    self.state.log_message(player_name, "(Defense) [No statement provided]")
                success = True
            else:
                self.state.log_hidden(player_name, f"Not on trial; ignoring defense action.")
                success = False

        # ----------------------------------------------------------------
        # FINAL VOTE PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.FINAL_VOTE:
            success = self._process_final_vote_action(player, action)

        # ----------------------------------------------------------------
        # If action was valid but the day discussion is still ongoing, 
        # we might want to continue or see if we transition to next phase.
        # ----------------------------------------------------------------
        if not success:
            self.state.log_hidden(player_name, f"Action {action} could not be processed.")
        return success

    def advance_turn(self):
        """
        Advances to the next person's turn in the DAY_DISCUSSION phase,
        respecting any question queue ordering (the questioned player, then questioner’s response).
        """
        if self.state.phase != GamePhase.DAY_DISCUSSION:
            self.state.current_player_turn = None
            return

        # If we have a question queue, that takes priority
        if self._question_queue:
            questioner, questioned = self._question_queue.popleft()
            # The questioned player goes first
            self.state.current_player_turn = questioned
            self.state.turn_context = {"answering_question_from": questioner}

            # Then queue the questioner as next (a short follow-up), unless questioner == questioned
            if questioner != questioned:
                self._question_queue.appendleft((questioner, questioner))
            return

        # If the main speaker queue is empty, check discussion end or start a new round
        if not self._speaker_queue or self._consecutive_passes >= len(self.state.alive_players):
            self._transition_to_voting()
            return

        next_speaker = self._speaker_queue.popleft()
        self.state.current_player_turn = next_speaker
        self.state.turn_number_in_phase += 1
        self.state.turn_context = None

    # ----------------------------------------------------------------
    # Internal / Private Helpers
    # ----------------------------------------------------------------

    def _resolve_night(self):
        """Resolves all players' night actions in the correct order (roleblock, protect, kill, investigate, etc.)."""
        self.state.log_message("system", "Night ends. Resolving all night actions...")
        self.state.night_action_results.clear()
        submitted_actions = self.state.night_actions_submitted

        # 1. Roleblocks
        roleblocked_players: Set[str] = set()
        # 2. Blackmail
        blackmailed_players: Set[str] = set()

        for actor, action_dict in submitted_actions.items():
            if not self.state.is_alive(actor):
                continue  # Actor died mid-night somehow

            # e.g. if action_dict["type"] == "roleblock": ...
            # Example placeholder:
            if action_dict.get("type") == "roleblock":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    roleblocked_players.add(target)
                    self.state.log_hidden(
                        actor, f"Roleblocked {target} for the night."
                    )
            elif action_dict.get("type") == "blackmail":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    blackmailed_players.add(target)
                    self.state.log_hidden(actor, f"Blackmailed {target} for the day.")

        # Mark roleblocked players
        for blocked in roleblocked_players:
            p = self.state.get_player(blocked)
            if p:
                p.is_roleblocked = True

        # Mark blackmailed players so they can't speak tomorrow
        for bm in blackmailed_players:
            p = self.state.get_player(bm)
            if p:
                p.can_speak_today = False

        # 3. Protections
        protected: Dict[str, str] = {}
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "protect":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    # If multiple doctors protect the same target, the first or last might "win."
                    # Here we allow the first to stand; you can choose whichever convention you like.
                    if target not in protected:
                        protected[target] = actor
                        # For debug or future logic
                        target_p = self.state.get_player(target)
                        if target_p:
                            target_p.protected_by = actor
                        self.state.log_hidden(
                            actor, f"Protected {target} this night."
                        )

        # 4. Kills
        kills_attempted: List[Tuple[str, str]] = []
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "kill":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    kills_attempted.append((actor, target))
                    self.state.log_hidden(actor, f"Attempting kill on {target}.")

        successful_kills: Set[str] = set()
        for (killer, target) in kills_attempted:
            if target not in protected:
                successful_kills.add(target)
                self.state.log_hidden(killer, f"Kill on {target} succeeded.")
            else:
                doc = protected[target]
                self.state.log_hidden(killer, f"Kill on {target} failed (protected by {doc}).")
                self.state.log_hidden(doc, f"You successfully protected {target} from a kill.")

        # Apply kills
        deaths = []
        for victim in successful_kills:
            if self.state.is_alive(victim):
                self.state.kill_player(victim, reason="killed during night")
                deaths.append(victim)

        # 5. Investigations
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "investigate":
                target = action_dict.get("target")
                result = action_dict.get("result")
                # Cop/Consigliere logic typically updates the player's memory. 
                # We also store it in environment logs.
                self.state.log_hidden(
                    actor, f"Investigation result on {target}: {result}"
                )
                self.state.night_action_results[actor] = action_dict

        if deaths:
            # Alphabetical or by order of kills
            self.state.log_message(
                "system",
                f"The sun rises. The following were found dead: {', '.join(sorted(deaths))}."
            )
        else:
            self.state.log_message("system", "The sun rises. Miraculously, nobody died last night!")

    def _transition_to_day(self):
        """Moves the game into DAY_DISCUSSION, resetting relevant flags and re-initializing speaker queues."""
        self.state.log_hidden("system", "Transitioning to Day phase.")
        # Clear roleblock statuses, etc.
        for p in self.state.players:
            p.reset_night_state()

        # Switch to day
        self.state.phase = GamePhase.DAY_DISCUSSION
        self.state.day_count += 1
        self.state.reset_day_phase_state()

        # Start a fresh speaking queue
        self._start_new_discussion_round()
        self.state.log_message("system", f"Day {self.state.day_count} begins. Discuss and vote!")

    def _start_new_discussion_round(self):
        """Initializes or re-initializes the round-robin talk queue for the day discussion phase."""
        self._speaker_queue.clear()
        self._question_queue.clear()
        self._turns_taken_this_round.clear()
        self._consecutive_passes = 0
        self.state.turn_context = None
        self.state.turn_number_in_phase = 0

        alive_names = sorted(self.state.alive_players)
        # If config demands Cop speak first
        if self.cop_speaks_first:
            for name in alive_names:
                pl = self.state.get_player(name)
                if pl and isinstance(pl.role, Cop):
                    alive_names.remove(name)
                    alive_names.insert(0, name)
                    self.state.log_hidden("system", f"Cop ({name}) will speak first today.")
                    break

        self._speaker_queue.extend(alive_names)
        # Force the environment to choose the first speaker
        self.advance_turn()

    def _check_discussion_end(self) -> bool:
        """
        Checks if we must end DAY_DISCUSSION:
          - Everyone passes in a row
          - An accusation is made
          - The day discussion round is otherwise complete (all spoke, queue empty)
          - (Optional) A max turn or time-based limit
        """
        # 1. Everyone passes consecutively
        if self._consecutive_passes >= len(self.state.alive_players):
            self.state.log_hidden("system", "All players have consecutively passed. Discussion ending.")
            return True

        # 2. If the queue is empty and every living player has spoken at least once
        if (not self._speaker_queue and not self._question_queue 
                and len(self._turns_taken_this_round) >= len(self.state.alive_players)):
            self.state.log_hidden("system", "Discussion round ended: queue empty, everyone spoke.")
            return True

        # 3. If someone is on trial already (accusation triggered)
        if self.state.player_on_trial:
            self.state.log_hidden("system", f"Discussion ended: {self.state.player_on_trial} was put on trial.")
            return True

        return False

    def _transition_to_voting(self):
        """
        Day discussion → Voting on the accused (or skipping to night if no accusations).
        """
        if not self.state.player_on_trial:
            self.state.log_message("system", "No one was put on trial today.")
            self._transition_to_night()
            return

        self.state.log_message("system", f"{self.state.player_on_trial} is on trial!")
        self.state.votes_for_lynch.clear()

        if self.lynch_defense_enabled:
            self.state.phase = GamePhase.DEFENSE
            self.state.current_player_turn = self.state.player_on_trial
            self.state.log_message(
                "system",
                f"{self.state.player_on_trial}, you may speak in your defense."
            )
        else:
            # Skip defense and go directly to final vote
            self._transition_to_final_vote()

    def _run_defense(self):
        """
        A placeholder hook for the defense phase. 
        The simulation typically calls process_player_action(...) so the accused can make a statement.
        """
        self.state.log_hidden("system", f"Defense phase for {self.state.player_on_trial}.")

    def _transition_to_final_vote(self):
        """
        Moves from DEFENSE → FINAL_VOTE. 
        All alive players can vote guilty/innocent simultaneously or in a loop if you prefer.
        """
        self.state.phase = GamePhase.FINAL_VOTE
        self.state.current_player_turn = None
        self.state.votes_for_lynch.clear()
        self.state.log_message(
            "system",
            f"Final voting begins for {self.state.player_on_trial}. Vote GUILTY or INNOCENT."
        )

    def _resolve_lynch(self):
        """
        After the final vote, count how many guilty vs. innocent votes. 
        Majority (strictly >= half+1) => lynch. Otherwise, no lynch.
        """
        if not self.state.player_on_trial:
            self.state.log_hidden("system", "No player on trial, skipping lynch resolution.")
            return

        votes = self.state.votes_for_lynch
        guilty = sum(1 for is_guilty in votes.values() if is_guilty)
        innocent = len(votes) - guilty
        total_alive = len(self.state.alive_players)
        needed_for_lynch = (total_alive // 2) + 1

        self.state.log_message(
            "system",
            f"Vote Results for {self.state.player_on_trial}: "
            f"Guilty={guilty}, Innocent={innocent}. Need {needed_for_lynch} to lynch."
        )
        self.state.log_hidden("system", f"Final Votes: {votes}")

        if guilty >= needed_for_lynch:
            self.state.log_message("system", f"The town has decided to lynch {self.state.player_on_trial}!")
            self.state.kill_player(self.state.player_on_trial, reason="lynched")
        else:
            self.state.log_message("system", f"The vote is inconclusive, sparing {self.state.player_on_trial}.")

        self.state.player_on_trial = None

    def _transition_to_night(self):
        """
        Resets day state and transitions to NIGHT, unless the game has ended.
        Typically called after lynch resolution or if no trial occurred.
        """
        self.state.log_hidden("system", "Transitioning to Night phase.")
        if self.state.player_on_trial and self.state.phase != GamePhase.NIGHT:
            # If for some reason we haven't resolved the lynch yet, do it now
            self._resolve_lynch()

        if self.state.check_game_end():
            return  # If game ended from a lynch, stop here

        self.state.phase = GamePhase.NIGHT
        self.state.reset_night_phase_state()
        self.state.current_player_turn = None
        self.state.log_message("system", "Night falls. Mafia members, choose your targets...")

    def apply_rewards(self):
        """
        Optional: If you have a reward system, call it here to store or return
        partial or final rewards for each player/agent.
        """
        rewards = compute_rewards(self.state)
        self.state.log_hidden("system", f"Computed rewards (not saved): {rewards}")
        # Optionally store them in the GameState or return them

    # ----------------------------------------------------------------
    # Day-Phase Action Helpers
    # ----------------------------------------------------------------

    def _process_day_discussion_action(
        self, 
        player: Player, 
        action_type: str, 
        target: Optional[str], 
        content: Optional[str]
    ) -> bool:
        """
        Handle actions that can occur specifically in the DAY_DISCUSSION phase.
        Returns True if valid, False otherwise.
        """
        # Reset consecutive passes only if the action is not a "pass"
        if action_type == "pass":
            self._consecutive_passes += 1
            self.state.log_message(player.name, f"{player.name} passes.")
            # Mark that the player has taken a turn
            self._turns_taken_this_round.add(player.name)
            return True
        else:
            # They did something, so reset the pass counter
            self._consecutive_passes = 0

        # Accuse
        if action_type == "accuse" and target:
            if self.state.player_on_trial:
                self.state.log_hidden(player.name, "Cannot accuse; someone is already on trial.")
                return False
            success = player.accuse(target, self.state)
            if success:
                self.state.player_on_trial = target
            self._turns_taken_this_round.add(player.name)
            return success

        # Vote (during discussion, not final vote)
        elif action_type == "vote" and target:
            success = player.vote_for(target, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Question
        elif action_type == "question" and target and content:
            # Possibly limit # of questions per day, per target
            times_asked = player.questions_asked_today.get(target, 0)
            if times_asked >= 1:
                self.state.log_hidden(player.name, f"Question limit reached for {target}.")
                return False
            success = player.question(target, content, self.state)
            if success:
                player.questions_asked_today[target] = times_asked + 1
                # Add the Q&A flow to the question queue
                self._question_queue.append((player.name, target))
                # Then the questioner is scheduled to respond
                self._question_queue.append((player.name, player.name))
            self._turns_taken_this_round.add(player.name)
            return success

        # Predict role
        elif action_type == "predict" and target and content:
            success = player.predict_role(target, content, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Whisper
        elif action_type == "whisper" and target and content:
            success = player.whisper(target, content, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Generic talk
        elif action_type == "speak":
            if content:
                self.state.log_message(player.name, content)
                self._turns_taken_this_round.add(player.name)
                return True
            else:
                self.state.log_hidden(player.name, "Tried to speak but no content was provided.")
                return False

        # If none of the above matched, treat as invalid or a default "speak"
        if content:
            self.state.log_message(player.name, content)
            self._turns_taken_this_round.add(player.name)
            return True

        self.state.log_hidden(player.name, f"Invalid or unrecognized day action: {action_type}")
        return False

    def _process_voting_phase_action(
        self,
        player: Player,
        action_type: str,
        target: Optional[str],
        content: Optional[str]
    ) -> bool:
        """
        Handle standard voting phase (pre-defense or a simpler immediate-voting system).
        If you prefer all final votes to happen in FINAL_VOTE, you can keep this minimal.
        """
        if action_type == "vote" and target == self.state.player_on_trial:
            # If the environment merges "voting" and "final vote," you could do a direct guilty/innocent.
            # Otherwise, you might track 'vote_for_lynch' in the state, or do a simpler approach.
            player.vote_for(target, self.state)
            self.state.log_message(player.name, f"votes to lynch {target} in the standard voting phase.")
            return True

        # You can add logic for 'skip' or 'abstain' as well:
        elif action_type == "skip":
            self.state.log_message(player.name, f"{player.name} decides not to vote right now.")
            return True

        self.state.log_hidden(player.name, f"Invalid or mismatched action {action_type} in VOTING phase.")
        return False

    def _process_final_vote_action(self, player: Player, action: Dict[str, Any]) -> bool:
        """
        In FINAL_VOTE phase, each player declares GUILTY or INNOCENT (or possibly abstains).
        action might look like {"action": "vote", "vote_type": "final_guilty"}
        """
        action_type = action.get("action")
        vote_type_str = action.get("vote_type", "").lower()

        # Must be a "vote" action
        if action_type != "vote":
            self.state.log_hidden(player.name, f"Expected a vote action in FINAL_VOTE, got {action_type}.")
            return False

        if vote_type_str == "final_guilty":
            self.state.votes_for_lynch[player.name] = True
            self.state.log_message(
                player.name,
                f"votes GUILTY on {self.state.player_on_trial}."
            )
            return True
        elif vote_type_str == "final_innocent":
            self.state.votes_for_lynch[player.name] = False
            self.state.log_message(
                player.name,
                f"votes INNOCENT on {self.state.player_on_trial}."
            )
            return True
        elif vote_type_str == "abstain":
            self.state.log_message(player.name, f"abstains from voting.")
            return True
        else:
            self.state.log_hidden(
                player.name,
                f"Invalid final vote type: {vote_type_str} (expected 'final_guilty' or 'final_innocent')."
            )
            return False

    # ----------------------------------------------------------------
    # Night Action Validation
    # ----------------------------------------------------------------

    def _validate_night_action(self, player: Player, action_dict: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Optional: Enforces certain constraints on night actions:
          - Godfather cannot kill themselves or a fellow Mafia
          - Cop cannot investigate themselves
          - Roleblocker cannot block themselves
          - ...
        Return the action_dict if valid, or None if invalid.
        """
        if not action_dict:
            return None

        action_type = action_dict.get("type")
        target = action_dict.get("target")

        # Basic checks: must have a target
        if not target:
            self.state.log_hidden(player.name, "No target specified for night action.")
            return None

        # Cop cannot investigate self
        if action_type == "investigate" and target == player.name:
            self.state.log_hidden(player.name, "Cop tried to investigate themselves; invalid.")
            return None

        # Godfather can't kill themselves or mafia
        if action_type == "kill" and isinstance(player.role, Godfather):
            target_p = self.state.get_player(target)
            if target_p:
                if target_p.faction == Faction.MAFIA or target_p.name == player.name:
                    self.state.log_hidden(
                        player.name,
                        "Godfather tried to kill themselves or a fellow Mafia, invalid action."
                    )
                    return None

        # Roleblocker cannot block themselves (if you have a RoleBlocker role)
        if action_type == "roleblock" and isinstance(player.role, RoleBlocker):
            if target == player.name:
                self.state.log_hidden(player.name, "RoleBlocker tried to block themselves, invalid.")
                return None

        return action_dict


# === export.py ===
# export.py
import os
import json

def collect_python_files(root_dir: str) -> dict:
    file_structure = {}

    for dirpath, _, filenames in os.walk(root_dir):
        for file in filenames:
            if file.endswith('.py'):
                full_path = os.path.join(dirpath, file)
                rel_path = os.path.relpath(full_path, root_dir)
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                file_structure[rel_path] = content

    return file_structure

def export_to_json(output_path="code_snapshot.json", root="mafia"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(all_files, f, indent=2)

def export_to_text(output_path="code_snapshot.txt", root="mafia"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        for path, content in all_files.items():
            f.write(f"# === {path} ===\n")
            f.write(content + "\n\n")

if __name__ == "__main__":
    export_to_json()
    export_to_text()
    print("✅ Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'")


# === game_state.py ===
# === mafia/game_state.py ===

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Any, Union
import uuid

# Core references to your enums, players, and roles:
from mafia.enums import GamePhase, Faction
from mafia.player import Player
from mafia.mechanics.roles import Goon, Godfather, get_role_class

# -------------------------------------------------------------------
# Define the "type" of a single logged message, for clarity.
# Feel free to expand or rename these categories.
# -------------------------------------------------------------------
MESSAGE_TYPES = (
    "system",            # Internal system or phase announcements
    "public",            # Publicly spoken messages
    "whisper",           # Private whisper from A→B
    "vote",              # Voting or accusation messages
    "death_announcement" # Messages triggered on death
    # ... add "debug", "accusation", etc. as you see fit
)

@dataclass
class GameMessage:
    """Structured record of a single game message."""
    msg_type: str       # e.g. 'system', 'public', 'whisper', ...
    sender: str         # 'system' or player_name
    content: str
    recipients: Optional[List[str]] = None  # None means public
    phase: GamePhase = GamePhase.NIGHT
    day: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a serializable dict (helpful if you store logs as JSON)."""
        return {
            "type": self.msg_type,
            "sender": self.sender,
            "content": self.content,
            "recipients": self.recipients,
            "phase": self.phase.name,
            "day": self.day
        }


@dataclass
class GameState:
    """
    Central data store for a Mafia game:
      - Keeps track of players, alive/dead sets, messages, day/night transitions
      - Contains methods for logging and checking endgame
    """

    # ------------------------------
    # Core game setup
    # ------------------------------
    players: List[Player]
    game_config: Dict[str, Any] = field(default_factory=dict)  # e.g. "lynch_required": True, etc.

    # ------------------------------
    # Phase & Turn Tracking
    # ------------------------------
    phase: GamePhase = GamePhase.NIGHT
    day_count: int = 0
    turn_number_in_phase: int = 0
    current_player_turn: Optional[str] = None

    # Keep track of which players are alive or dead
    alive_players: Set[str] = field(default_factory=set)
    dead_players: Set[str] = field(default_factory=set)

    # ------------------------------
    # Logging
    # ------------------------------
    # Public and private logs
    messages: List[GameMessage] = field(default_factory=list)
    hidden_log: List[Dict[str, Any]] = field(default_factory=list)

    # ------------------------------
    # Accusation / Voting (Day)
    # ------------------------------
    # E.g. for a pre-trial voting system if you use it
    votes_for_accusation: Dict[str, str] = field(default_factory=dict)  # voter -> target
    accusation_counts: Dict[str, int] = field(default_factory=dict)     # target -> count

    # Which player is currently on trial (if any)
    player_on_trial: Optional[str] = None

    # Final-lunch votes: None = abstain, True = Guilty, False = Innocent
    votes_for_lynch: Dict[str, Optional[bool]] = field(default_factory=dict)

    # Token budgets for controlling how much players can speak (optional)
    discussion_token_budgets: Dict[str, int] = field(default_factory=dict)

    # ------------------------------
    # Night Phase Action Tracking
    # ------------------------------
    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)

    # ------------------------------
    # Game Identity & Completion
    # ------------------------------
    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    game_over: bool = False
    winner: Optional[Faction] = None
    final_player_roles: Dict[str, str] = field(default_factory=dict)  # e.g. "Alice": "Godfather"

    # Optional: track transitions or time-based info
    phase_history: List[Dict[str, Any]] = field(default_factory=list)

    # ----------------------------------------------------------------
    # Initialization & Setup
    # ----------------------------------------------------------------

    def initialize(self):
        """Called once at game start to populate initial states."""
        self.alive_players = {p.name for p in self.players}
        self.dead_players.clear()
        self.day_count = 0
        self.phase = GamePhase.NIGHT
        self.game_over = False
        self.winner = None
        self.messages.clear()
        self.hidden_log.clear()
        self.final_player_roles.clear()
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()

        # Reset each player's personal state
        for player in self.players:
            player.reset_for_new_game()
            # Optionally set token budgets if using
            # initial_tokens = self.game_config.get("initial_tokens", 999)
            # self.discussion_token_budgets[player.name] = initial_tokens

        # Example: record the start of the initial phase
        self.record_phase_start()

        # Log game creation
        self.log_message("system", "Game started.", msg_type="system")
        self.log_hidden("system", f"Game ID: {self.game_id}")
        self.log_hidden("system", f"Initial Roles: { {p.name: p.role.name for p in self.players} }")

    # ----------------------------------------------------------------
    # Player & Survival
    # ----------------------------------------------------------------

    def get_player(self, name: str) -> Optional[Player]:
        return next((p for p in self.players if p.name == name), None)

    def is_alive(self, name: str) -> bool:
        return name in self.alive_players

    def kill_player(self, name: str, reason: str = "killed"):
        """
        Officially kills a player:
          - Removes from alive_players
          - Logs death message
          - Checks if Godfather died => Goon promotion
          - Triggers check_game_end
        """
        if name not in self.alive_players:
            return  # Already dead or invalid

        player = self.get_player(name)
        if not player:
            return

        self.alive_players.remove(name)
        self.dead_players.add(name)
        player.alive = False

        self.log_message(
            "system",
            f"{name} ({player.role.name}) has died ({reason}).",
            msg_type="death_announcement"
        )
        self.log_hidden("system", f"{name} died. Reason: {reason}")

        # Check for Godfather death => Promote a Goon
        if isinstance(player.role, Godfather):
            self._promote_goon_to_gf(dead_gf_name=name)

        self.check_game_end()

    def _promote_goon_to_gf(self, dead_gf_name: str):
        """Promote the first alive Goon to Godfather upon GF death."""
        promoted_goon: Optional[Player] = None
        for p in self.players:
            if p.name in self.alive_players and isinstance(p.role, Goon):
                promoted_goon = p
                break

        if promoted_goon:
            new_role = Godfather()
            promoted_goon.role = new_role
            promoted_goon.faction = new_role.faction
            self.log_message(
                "system",
                f"{promoted_goon.name} has been promoted to Godfather!",
                msg_type="system"
            )
            self.log_hidden(
                promoted_goon.name,
                f"Promoted to Godfather after {dead_gf_name}'s death"
            )
        else:
            self.log_hidden("system", f"No Goon available to promote after {dead_gf_name} died.")

    # ----------------------------------------------------------------
    # Phase State Management
    # ----------------------------------------------------------------

    def reset_night_phase_state(self):
        """Clears any leftover actions/results from the previous night phase."""
        self.night_actions_submitted.clear()
        self.night_action_results.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            p = self.get_player(p_name)
            if p:
                p.reset_night_state()

    def reset_day_phase_state(self):
        """Clears day-specific data like accusations, lynch votes, and resets turn tracking."""
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            p = self.get_player(p_name)
            if p:
                p.reset_day_state()

    # ----------------------------------------------------------------
    # Accusation & Voting Threshold
    # ----------------------------------------------------------------

    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):
        """
        If your day logic uses an 'accuse to put on trial' mechanism,
        track each player's accusation and count how many times each target was accused.
        """
        if old_target and old_target in self.accusation_counts:
            self.accusation_counts[old_target] -= 1
            if self.accusation_counts[old_target] <= 0:
                del self.accusation_counts[old_target]

        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1
        self.votes_for_accusation[voter] = new_target

    def get_accusation_threshold(self) -> int:
        """
        Returns how many votes are needed to put someone on trial during discussion.
        By default, we use a majority threshold if not explicitly set.

        e.g. threshold = floor(#alive / 2) + 1
        """
        if "accusation_threshold" in self.game_config:
            return int(self.game_config["accusation_threshold"])
        # Default to simple majority
        return (len(self.alive_players) // 2) + 1

    def accusation_threshold_reached(self, target: str) -> bool:
        """Check if the accused has enough votes to start a trial."""
        needed = self.get_accusation_threshold()
        return self.accusation_counts.get(target, 0) >= needed

    # ----------------------------------------------------------------
    # Night Actions
    # ----------------------------------------------------------------

    def register_night_action(self, actor_name: str, action: Dict[str, Any]):
        """Stores the intended night action from a player. The environment resolves them later."""
        if not self.is_alive(actor_name):
            return
        self.night_actions_submitted[actor_name] = action
        self.log_hidden(actor_name, f"Submitted night action: {action}")

    # ----------------------------------------------------------------
    # Endgame Conditions
    # ----------------------------------------------------------------

    def check_game_end(self) -> bool:
        """
        Checks if the game has ended by evaluating basic Town vs Mafia logic (and optionally expansions).
        If a winner is found, we finalize the game and store final roles.
        """
        if self.game_over:
            return True  # Already ended

        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}
        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}
        # If you want to handle neutrals or special roles, do so here

        winner: Optional[Faction] = None

        # Example: Town wins if no mafia remain
        if not mafia_alive:
            winner = Faction.TOWN
        # Mafia wins if mafia >= town or the config-based rule
        elif len(mafia_alive) >= len(town_alive):
            winner = Faction.MAFIA

        # Add any additional conditions or neutrals logic here

        if winner:
            self.game_over = True
            self.winner = winner
            self.phase = GamePhase.GAME_OVER

            # Final role record
            self.final_player_roles = {p.name: p.role.name for p in self.players}

            self.log_message(
                "system",
                f"Game Over! Winner: {winner.value.upper()}",
                msg_type="system"
            )
            self.log_hidden("system", f"Final Roles: {self.final_player_roles}")
            return True

        return False

    # ----------------------------------------------------------------
    # Logging
    # ----------------------------------------------------------------

    def log_message(self,
                    sender: str,
                    content: str,
                    recipients: Optional[List[str]] = None,
                    msg_type: str = "public"):
        """
        Logs a message to the main game log with a specified type (system, whisper, etc.).
        If 'recipients' is None, it's public for all. Otherwise, only the given recipients can see it.
        """
        if msg_type not in MESSAGE_TYPES:
            msg_type = "public"  # fallback if unknown

        self.messages.append(
            GameMessage(
                msg_type=msg_type,
                sender=sender,
                content=content,
                recipients=recipients,
                phase=self.phase,
                day=self.day_count
            )
        )

    def log_hidden(self, actor: str, info: str):
        """
        Logs details that only certain debugging or hidden channels should see.
        Often used for debugging or system clarifications.
        """
        entry = {
            "actor": actor,
            "info": info,
            "phase": self.phase.name,
            "day": self.day_count,
            "turn": self.turn_number_in_phase
        }
        self.hidden_log.append(entry)

    # ----------------------------------------------------------------
    # Observations
    # ----------------------------------------------------------------

    def get_player_observation(self, player_name: str) -> Dict[str, Any]:
        """
        Generates a viewpoint for one player, containing:
          - visible (public + relevant private) messages
          - personal flags (roleblocked, protected, memory)
          - day/phase details
        """
        player = self.get_player(player_name)
        if not player or not player.alive:
            # Alternatively, return a 'You are dead' prompt
            return {
                "game_id": self.game_id,
                "player_name": player_name,
                "alive": False,
                "message": "You are no longer in the game."
            }

        # Gather messages visible to this player
        visible_messages: List[str] = []
        for msg_obj in self.messages:
            is_recip_private = (msg_obj.recipients is not None and player_name in msg_obj.recipients)
            is_sender_private = (msg_obj.sender == player_name and msg_obj.recipients is not None)
            if (msg_obj.recipients is None) or is_recip_private or is_sender_private:
                # Format differently if it's a whisper or if they are the sender
                if msg_obj.msg_type == "whisper":
                    if is_sender_private:
                        # From self to someone else
                        visible_messages.append(
                            f"(Whisper to {msg_obj.recipients[0]}) {msg_obj.content}"
                        )
                    elif is_recip_private:
                        # A whisper from someone else to you
                        visible_messages.append(
                            f"(Whisper from {msg_obj.sender}) {msg_obj.content}"
                        )
                    else:
                        # Shouldn't happen with typed logs, but just in case
                        visible_messages.append(f"{msg_obj.sender}: {msg_obj.content}")
                else:
                    # Normal or system message
                    visible_messages.append(f"{msg_obj.sender}: {msg_obj.content}")

        # Construct final observation
        obs = {
            "game_id": self.game_id,
            "player_name": player.name,
            "role": player.role.name,
            "role_description": player.role.get_role_description(),
            "faction": player.faction.value,
            "phase": self.phase.name,
            "day": self.day_count,
            "turn": self.turn_number_in_phase,
            "is_current_turn": (self.current_player_turn == player.name),
            "alive_players": sorted(self.alive_players),
            "dead_players": sorted(self.dead_players),
            "messages": visible_messages[-20:],  # Limit message history
            "can_speak": player.can_speak(),
            "can_act_tonight": (player.can_act_at_night() and self.phase == GamePhase.NIGHT),
            "player_on_trial": self.player_on_trial,
            "votes_for_accusation": dict(self.votes_for_accusation),
            "accusation_counts": dict(self.accusation_counts),
            "memory": list(player.memory),
            "is_roleblocked": player.is_roleblocked,
            "protected_by": player.protected_by,
            # Example: "token_budget": self.discussion_token_budgets.get(player.name, 0),
            "lynch_votes": {
                voter: val for voter, val in self.votes_for_lynch.items()
            },  # Show final vote states
        }
        return obs

    # ----------------------------------------------------------------
    # Optional: Phase Tracking for Debug or Time-Aware Agents
    # ----------------------------------------------------------------

    def record_phase_start(self):
        """
        Record the beginning of a new phase for debugging or analysis.
        You might store timestamps, etc.
        """
        entry = {
            "phase": self.phase.name,
            "day": self.day_count,
            "turn_start": self.turn_number_in_phase,
            "timestamp": None  # set to datetime.now() if you want
        }
        self.phase_history.append(entry)

    def record_phase_end(self):
        """Mark the end of the current phase, e.g. to track how long each phase lasted."""
        if self.phase_history:
            self.phase_history[-1]["turn_end"] = self.turn_number_in_phase
            self.phase_history[-1]["end_timestamp"] = None  # if storing actual time

    # ----------------------------------------------------------------
    # Auditing / Debugging Tools
    # ----------------------------------------------------------------

    def get_game_summary(self) -> Dict[str, Any]:
        """
        Returns a structured summary of the game’s final state or current state.
        Useful for logs, testing, or replay.
        """
        summary = {
            "game_id": self.game_id,
            "phase": self.phase.name,
            "day_count": self.day_count,
            "game_over": self.game_over,
            "winner": self.winner.value if self.winner else None,
            "alive_players": sorted(list(self.alive_players)),
            "dead_players": sorted(list(self.dead_players)),
            "final_player_roles": dict(self.final_player_roles),
            "messages_count": len(self.messages),
            "hidden_log_count": len(self.hidden_log),
            "phase_history": self.phase_history,
        }
        return summary



# === player.py ===
from typing import Optional, Dict, List, Any
# Import the base Role class and Faction enum
from mafia.mechanics.roles import Role
from mafia.enums import Faction
# Import GameState for type hinting only to avoid circular dependency
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from mafia.game_state import GameState


class Player:
    def __init__(self, name: str, role: Role):
        self.name: str = name
        self.role: Role = role
        # Faction comes directly from the role object
        self.faction: Faction = self.role.faction
        self.alive: bool = True

        # Night action state
        self.night_target: Optional[str] = None  # Who the player chose to target
        self.is_roleblocked: bool = False
        self.protected_by: Optional[str] = None  # Who protected this player (e.g., Doctor's name)

        # Day state
        self.vote: Optional[str] = None  # For initial vote (e.g., accusation target)
        self.trial_vote: Optional[bool] = None  # For final trial vote (True=Guilty, False=Innocent, None=Abstain)
        self.discussion_tokens: int = 0  # Handled by environment/config
        self.can_speak_today: bool = True  # For effects like Blackmailer

        # Action tracking & Memory
        self.has_accused_today: bool = False
        self.predictions: Dict[str, str] = {}  # target_name -> predicted_role_name
        self.questions_asked_today: Dict[str, int] = {}  # target_name -> count
        self.whispers_sent_today: Dict[str, str] = {}  # target_name -> last_whisper_content

        # Memory for roles like Cop (to store investigation results, etc.)
        self.memory: List[Dict[str, Any]] = []

        # Optional: Track messages said/received for advanced agents
        self.messages_said: List[str] = []
        self.messages_received: List[str] = []

    def reset_for_new_game(self):
        """Resets player state for the start of a new game."""
        self.alive = True
        self.reset_night_state()
        self.reset_day_state()
        self.memory.clear()
        self.predictions.clear()
        # Reset message logs if desired
        self.messages_said.clear()
        self.messages_received.clear()

    def reset_night_state(self):
        """Resets state relevant to the night phase."""
        self.night_target = None
        self.is_roleblocked = False
        self.protected_by = None

    def reset_day_state(self):
        """Resets state relevant to the day phase."""
        self.vote = None
        self.trial_vote = None
        # discussion_tokens might be reset by environment based on config
        self.has_accused_today = False
        self.questions_asked_today.clear()
        self.whispers_sent_today.clear()
        self.can_speak_today = True  # Reset mute/blacklist effects

    def can_act_at_night(self) -> bool:
        """Check if player is alive and their role has a night action."""
        return self.alive and self.role.can_act_at_night()

    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:
        """
        Performs the player's role-specific night action.
        Assumes self.night_target has been set by the agent.
        Returns the action dict or None.
        """
        if not self.can_act_at_night() or self.is_roleblocked:
            if self.is_roleblocked:
                self.log_hidden(game_state, "Tried to act but was roleblocked.")
            return None
        return self.role.night_action(self, game_state, self.night_target)

    def can_speak(self) -> bool:
        """
        Returns whether the player is allowed to speak during the day.
        Can incorporate token budgets or mute effects if needed.
        """
        return self.alive and self.can_speak_today

    # --- Day Actions ---

    def accuse(self, target: str, game_state: 'GameState') -> bool:
        """
        Attempts to accuse a target. Only allowed once per day.
        Logs the accusation and appends a public message.
        """
        if not self.can_speak() or self.has_accused_today:
            self.log_hidden(game_state, f"Attempted to accuse {target} but couldn't (already accused or cannot speak).")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to accuse {target} but they are dead or invalid.")
            return False

        self.log_hidden(game_state, f"Accused {target}")
        game_state.messages.append(f"{self.name} accuses {target}!")
        self.has_accused_today = True
        return True

    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState') -> bool:
        """
        Predicts a player's role for internal analysis. Can be used to compare against actual role later.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player:
            return False

        self.predictions[target] = predicted_role_name
        self.log_hidden(game_state, f"Predicted {target} as {predicted_role_name}")
        return True

    def question(self, target: str, question_text: str, game_state: 'GameState') -> bool:
        """
        Sends a question to another player. The environment typically handles the Q&A flow.
        """
        if not self.can_speak():
            self.log_hidden(game_state, f"Attempted to question {target} but cannot speak.")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to question {target} but they are dead or invalid.")
            return False

        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1
        self.log_hidden(game_state, f"Asked {target}: {question_text}")
        game_state.messages.append(f"{self.name} asks {target}: \"{question_text}\"")
        return True

    def whisper(self, target: str, whisper_text: str, game_state: 'GameState') -> bool:
        """
        Sends a private message to another player. The content is hidden from public logs.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to whisper {target} but they are dead or invalid.")
            return False

        self.whispers_sent_today[target] = whisper_text
        self.log_hidden(game_state, f"Whispered to {target}: {whisper_text}")
        # For simplicity, append a placeholder to public messages (actual content remains hidden)
        game_state.messages.append(f"[WHISPER] {self.name} to {target}")
        return True

    def vote_for(self, target: str, game_state: 'GameState') -> bool:
        """
        Casts or changes a vote during the initial accusation phase.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to vote for {target} but they are dead or invalid.")
            return False

        old_vote = self.vote
        self.vote = target
        if old_vote and old_vote != target:
            log_msg = f"Changed vote from {old_vote} to {target}"
            public_msg = f"{self.name} changed vote to {target}."
        elif not old_vote:
            log_msg = f"Voted for {target}"
            public_msg = f"{self.name} voted for {target}."
        else:
            return True  # No change needed

        self.log_hidden(game_state, log_msg)
        game_state.messages.append(public_msg)
        game_state.update_vote_counts(self.name, old_vote, target)
        return True

    # --- Voting Phase: Final Trial Vote Support ---
    def cast_trial_vote(self, vote_type: str, game_state: 'GameState') -> bool:
        """
        Casts a final vote during the trial phase.
        vote_type should be one of: 'guilty', 'innocent', 'abstain'.
        This vote is stored separately as trial_vote.
        """
        if not self.alive:
            return False

        vt = vote_type.lower()
        if vt == "guilty":
            self.trial_vote = True
        elif vt == "innocent":
            self.trial_vote = False
        elif vt == "abstain":
            self.trial_vote = None
        else:
            self.log_hidden(game_state, f"Invalid trial vote type: {vote_type}")
            return False

        self.log_hidden(game_state, f"Cast final vote: {vote_type.upper()}")
        game_state.messages.append(f"{self.name} casts a final vote: {vote_type.upper()}.")
        return True

    def abstain_from_vote(self, game_state: 'GameState') -> bool:
        """
        Explicitly abstains from voting in the trial phase.
        """
        if not self.alive:
            return False

        self.trial_vote = None
        self.log_hidden(game_state, "Abstained from voting in the trial phase.")
        game_state.messages.append(f"{self.name} abstains from the final vote.")
        return True

    # --- LLM Action Interface ---
    def get_available_actions(self, game_state: 'GameState') -> List[Dict[str, Any]]:
        """
        Returns a structured list of available actions for this player.
        Each action is represented as a dict with a 'type' and optional 'params'.
        This helps LLM agents know what actions they can take.
        """
        if not self.alive:
            return []

        actions = []

        # Actions available during the day if the player can speak
        if self.can_speak():
            actions.append({"type": "speak", "params": ["content"]})
            actions.append({"type": "accuse", "params": ["target"]})
            actions.append({"type": "question", "params": ["target", "question_text"]})
            actions.append({"type": "predict", "params": ["target", "predicted_role"]})
            actions.append({"type": "whisper", "params": ["target", "whisper_text"]})

        # Actions available during night if the role can act
        if game_state.phase == game_state.phase.__class__.NIGHT and self.can_act_at_night():
            actions.append({"type": "night_action", "params": ["target"]})

        # Voting phase actions (both initial vote and trial vote)
        if game_state.phase.name in {"VOTING", "FINAL_VOTE"}:
            actions.append({"type": "vote", "params": ["target"]})
            actions.append({"type": "abstain", "params": []})
        # Final trial voting is separate from initial accusations
        if game_state.phase.name == "FINAL_VOTE":
            actions.append({"type": "cast_trial_vote", "params": ["vote_type (guilty/innocent/abstain)"]})

        return actions

    # --- Debugging / Serialization ---
    def to_dict(self) -> Dict[str, Any]:
        """
        Serializes the player's state into a dictionary for debugging or logging purposes.
        """
        return {
            "name": self.name,
            "role": self.role.name,
            "faction": self.faction.value,
            "alive": self.alive,
            "vote": self.vote,
            "trial_vote": self.trial_vote,
            "night_target": self.night_target,
            "memory": self.memory,
            "predictions": self.predictions,
            "questions_asked_today": self.questions_asked_today,
            "whispers_sent_today": self.whispers_sent_today,
        }

    def log_hidden(self, game_state: 'GameState', info: str):
        """
        Logs hidden information to the game state's hidden log.
        """
        game_state.log_hidden(self.name, info)

    def __repr__(self):
        status = 'Dead' if not self.alive else 'Alive'
        return f"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>"


# === rewards.py ===
# mafia/rewards.py
from typing import Dict
from mafia.enums import Faction


def assign_endgame_rewards(game_state) -> Dict[str, float]:
    """
    Assign final rewards to agents based on game outcome.
    Town agents get +1 for town win, -1 otherwise. Same for mafia.
    """
    rewards = {}
    for player in game_state.players:
        if player.faction.value == game_state.winner:
            rewards[player.name] = 1.0
        else:
            rewards[player.name] = -1.0
    return rewards


def assign_predict_role_reward(predicted: str, actual: str) -> float:
    return 0.5 if predicted == actual else -0.25


def assign_vote_reward(voter, target, game_state) -> float:
    """
    +1 if town correctly votes out mafia
    -1 if town votes town
    +0.5 if mafia avoids being voted
    """
    if not game_state.is_alive(target):  # Lynched
        if voter.faction == Faction.TOWN:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return 1.0
            else:
                return -1.0
        elif voter.faction == Faction.MAFIA:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return -1.0
            else:
                return 0.5
    return 0.0


def assign_speaking_reward(agent_name: str, token_used: int) -> float:
    """
    Optional: Reward for verbosity, or penalize excess verbosity.
    For now, neutral. Could be tuned.
    """
    return 0.0


def assign_question_reward(asker, target, game_state) -> float:
    """
    +0.2 for engaging others; could scale if target is mafia and asker is town
    """
    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:
        return 0.4
    return 0.2


# === simulation.py ===
import os
import json
from tqdm import tqdm
# Use correct Environment class name
from mafia.environment import MafiaEnvironment
# Import role classes and helper
from mafia.mechanics.roles import get_role_class, Role
from mafia.player import Player
# Keep TokenTracker import, assume it exists or create dummy
# from mafia.utils.token_cost import TokenTracker # If using
# Import agent classes
from mafia.agents.rule_agent import RuleBasedAgent # Assuming this will exist
from mafia.agents.llm_agent import LLMAPIClientAgent # Import the LLM agent
from typing import Dict, List
import uuid

# Dummy Token Tracker if needed
class TokenTracker:
    def __init__(self): self.usage = {}
    def update(self, *args, **kwargs): pass
    def to_dict(self): return self.usage

def create_players_from_config(config: Dict) -> List[Player]:
    """Creates Player objects based on a configuration dictionary."""
    players = []
    roles_config = config.get("roles", []) # e.g., [{"name": "Player1", "role": "Cop"}, ...]
    if not roles_config: # Fallback to default if config is empty/missing roles
        roles_setup = [
            ("Player1", "Cop"), ("Player2", "Doctor"), ("Player3", "Villager"),
            ("Player4", "Godfather"), ("Player5", "Goon")
        ]
        print("Warning: Using default 5-player role setup.")
    else:
        roles_setup = [(p_cfg["name"], p_cfg["role"]) for p_cfg in roles_config]

    for name, role_name in roles_setup:
        RoleClass = get_role_class(role_name)
        if not RoleClass:
             raise ValueError(f"Unknown role name '{role_name}' in configuration.")
        role_instance = RoleClass()
        player = Player(name=name, role=role_instance)

        # --- Agent Assignment ---
        # Example: Assign agents based on config or default to RuleBased
        agent_type = config.get("agent_mapping", {}).get(name, "rule") # Default to rule-based

        if agent_type.lower() == "llm":
            # TODO: Get model name, system prompt from config
            model_name = config.get("llm_config", {}).get("model", "gpt-4") # Example default
            system_prompt_key = config.get("llm_config", {}).get("system_prompt_key", "default_mafia")
            # Need a way to load system prompts based on key
            system_prompt = f"You are {name}, playing Mafia as {role_instance.name}. {role_instance.get_role_description()}" # Basic example
            agent = LLMAPIClientAgent(name=name, model=model_name, system_prompt=system_prompt)
            print(f"Assigning LLM Agent ({model_name}) to {name}")
        else: # Default to RuleBasedAgent
             # RuleBasedAgent needs to be implemented
            agent = RuleBasedAgent(name=name, player_role=role_instance.name)
            print(f"Assigning Rule Agent to {name}")

        # Link agent to player (though environment might manage this)
        player.agent = agent # Store agent reference if needed directly by player, otherwise managed by env/runner
        players.append(player)

    return players


def run_simulation(game_config: Dict, agent_config: Dict) -> Dict:
    """Runs a single game simulation and returns the final state."""
    print(f"\n--- Starting Simulation Game ID: {game_config.get('game_id', 'N/A')} ---")

    # Combine configs or pass separately
    full_config = {**game_config, "agents": agent_config} # Example merge

    # Create players based on combined config
    players = create_players_from_config(full_config) # Pass merged config

    # Initialize environment
    # Pass game_config to environment if it needs rules like GF detectability
    env = MafiaEnvironment(players=players, config=full_config)
    token_tracker = TokenTracker() # Initialize token tracker if used

    # --- Game Loop ---
    max_steps = full_config.get("max_steps", 100) # Limit game length
    step_count = 0
    while not env.state.game_over and step_count < max_steps:
        step_count += 1
        print(f"\n=== Day {env.state.day_count} | Phase: {env.state.phase.name} | Turn: {env.state.turn_number_in_phase} ===")
        current_player_name = env.get_current_player_name() # Needs implementation in Env

        if not current_player_name:
            # Environment handles transition or phase resolution automatically
             print("Environment resolving phase...")
             env.step_phase() # Needs implementation in Env
             continue # Go to next loop iteration to check game state

        player = env.state.get_player(current_player_name)
        if not player or not player.alive:
             print(f"Skipping turn for {current_player_name} (dead or invalid).")
             env.advance_turn() # Needs implementation in Env
             continue

        agent = player.agent # Get agent associated with the player

        # Get observation for the current player
        observation = env.get_observation(current_player_name) # Needs implementation in Env

        # Agent decides action
        print(f"--- {current_player_name}'s Turn ({agent.__class__.__name__}) ---")
        action = agent.act(observation) # Agent returns action dict
        print(f"Action chosen: {action}")

        # Environment processes action
        success = env.process_player_action(current_player_name, action) # Needs implementation in Env
        if not success:
            print(f"Action {action} failed or was invalid.")

        # Optional: Track tokens
        # token_tracker.update(current_player_name, observation, action)

        # Environment potentially advances turn or phase based on action
        # This might happen inside process_player_action or require a separate env.advance() call

    print(f"\n--- Game Over ---")
    print(f"Winner: {env.state.winner.value if env.state.winner else 'Draw/Timeout'}")
    print(f"Ended on Day {env.state.day_count}, Phase {env.state.phase.name}")

    # Log final state and return results
    final_state_summary = log_game_summary(env.state) # Use analysis function
    final_state_summary["tokens_used"] = token_tracker.to_dict() # Add token info if tracked
    return final_state_summary


def run_multiple_simulations(num_games=10, config_path="config/default_game.json", save_dir="data/episodes"):
    """Runs multiple simulations based on a config file."""
    os.makedirs(save_dir, exist_ok=True)

    # Load base configuration (needs implementation)
    # base_game_config = load_config_from_file(config_path)
    # base_agent_config = base_game_config.get("agent_config", {}) # Separate agent config if needed
    base_game_config = {"roles": [ # Example default config
             {"name": "Player1", "role": "Cop"}, {"name": "Player2", "role": "Doctor"},
             {"name": "Player3", "role": "Villager"}, {"name": "Player4", "role": "Godfather"},
             {"name": "Player5", "role": "Goon"}
         ],
        "agent_mapping": {"Player1": "llm", "Player4": "llm"}, # P1 & P4 are LLMs
        "llm_config": {"model": "gpt-3.5-turbo"} # Example LLM config
     }
    base_agent_config = {} # Agent specific settings if needed


    game_results = []
    for i in tqdm(range(num_games), desc="Simulating Games"):
        game_id = str(uuid.uuid4())
        current_game_config = {**base_game_config, "game_id": game_id}
        # Add variations here if doing experiments (e.g., change roles, prompts)

        try:
            result = run_simulation(current_game_config, base_agent_config)
            game_results.append(result)

            # Save individual game logs as JSONL
            log_path = os.path.join(save_dir, "games_log.jsonl")
            with open(log_path, "a") as f:
                json.dump(result, f)
                f.write("\n")

        except Exception as e:
            print(f"\n!!!!!! Error during simulation {game_id} !!!!!!")
            print(f"Error: {e}")
            # Log error state if possible
            error_info = {"game_id": game_id, "status": "error", "error_message": str(e)}
            log_path = os.path.join(save_dir, "games_log.jsonl")
            with open(log_path, "a") as f:
                json.dump(error_info, f)
                f.write("\n")


    print(f"\n--- Simulation Run Complete ---")
    print(f"Saved {len(game_results)} game logs to {os.path.join(save_dir, 'games_log.jsonl')}")

    # --- Optional: Compute and print aggregate metrics ---
    # win_rates = compute_win_rate(game_results)
    # avg_tokens = compute_average_tokens(game_results)
    # avg_accuracy = compute_average_role_accuracy(game_results)
    # print("\nAggregate Metrics:")
    # print(f"Win Rates: {win_rates}")
    # print(f"Avg Tokens: {avg_tokens}")
    # print(f"Avg Role Accuracy: {avg_accuracy}")


# Helper for loading config (placeholder)
def load_config_from_file(path: str) -> Dict:
     print(f"Warning: Config loading not implemented. Using defaults. Tried path: {path}")
     # Implement actual JSON/YAML loading here
     return {}


# Need log_game_summary, compute_* from evaluation module
# Placeholder if not implemented yet
def log_game_summary(game_state): return {"game_id": game_state.game_id, "winner": game_state.winner.value if game_state.winner else None, "final_roles": game_state.final_player_roles}
# def compute_win_rate(results): return {}
# def compute_average_tokens(results): return {}
# def compute_average_role_accuracy(results): return 0.0


if __name__ == "__main__":
    # Example of how to run
    run_multiple_simulations(num_games=5, save_dir="output/sim_results")


# === __init__.py ===


# === agents\base.py ===
from abc import ABC, abstractmethod
from typing import Dict, Any

class BaseAgent(ABC):
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def observe(self, observation: Dict[str, Any]):
        """Receive an observation from the environment."""
        pass

    @abstractmethod
    def act(self) -> Dict[str, Any]:
        """Produce an action dictionary in response to the last observation."""
        pass

    def reset(self):
        """Reset internal memory/state if needed between games."""
        pass


# === agents\llm_agent.py ===
from typing import Dict, Any
import json
from mafia.agents.base import BaseAgent

class LLMAgent(BaseAgent):
    def __init__(self, name, model_backend, tokenizer=None, config=None):
        super().__init__(name)
        self.model_backend = model_backend  # API or local callable
        self.tokenizer = tokenizer
        self.config = config or {}
        self.last_obs = None

    def observe(self, observation: Dict[str, Any]):
        self.last_obs = observation

    def act(self) -> Dict[str, Any]:
        prompt = self.build_prompt(self.last_obs)
        output = self.model_backend(prompt)
        action = self.parse_action(output)
        return action

    def build_prompt(self, obs: Dict[str, Any]) -> str:
        # Could be JSON, natural language, or both
        return f"<Observation>\n{obs}\n</Observation>\n<Action>"

    def parse_action(self, response: str) -> Dict[str, Any]:
        # Basic parsing with regex or structured JSON output
        try:
            return json.loads(response)
        except:
            return {"action": "pass"}


# === agents\rule_agent.py ===
import random
from typing import Dict, Any, Optional
from mafia.agents.base_agent import BaseAgent

class RuleAgent(BaseAgent):
    def __init__(self, name: str, role: Optional[str] = None, strategy: Optional[Dict[str, Any]] = None, seed: Optional[int] = None):
        super().__init__(name)
        self.role = role
        self.strategy = strategy or {}
        self.last_obs = None
        self.rng = random.Random(seed)

    def observe(self, observation: Dict[str, Any]):
        self.last_obs = observation

    def act(self) -> Dict[str, Any]:
        if not self.last_obs:
            return {"action": "pass"}

        phase = self.last_obs["phase"]
        if phase == "NIGHT":
            return self._night_action()
        elif phase == "DAY_DISCUSSION":
            return self._day_discussion_action()
        elif phase == "DEFENSE":
            return self._defense_action()
        elif phase == "FINAL_VOTE":
            return self._final_vote_action()
        return {"action": "pass"}

    def _night_action(self) -> Dict[str, Any]:
        role = self.role.lower() if self.role else ""
        targets = [p for p in self.last_obs["alive_players"] if p != self.name]

        if not targets:
            return {"action": "pass"}

        if role == "cop":
            return {"action": "investigate", "target": self._choose_target(targets)}
        if role == "doctor":
            return {"action": "protect", "target": self.name}
        if role == "godfather":
            target = self._choose_target(targets)
            if target in self.last_obs.get("faction_members", []):
                return {"action": "pass"}  # prevent killing mafia
            return {"action": "kill", "target": target}
        return {"action": "pass"}

    def _day_discussion_action(self) -> Dict[str, Any]:
        # Example: deterministic logic based on strategy
        s = self.strategy

        # Accuse if allowed
        if not self.last_obs["player_on_trial"] and not self.last_obs.get("has_accused_today"):
            if s.get("always_accuse", False):
                target = self._choose_target(self.last_obs["alive_players"])
                return {"action": "accuse", "target": target}

        # Respond to questions
        if self.last_obs.get("is_current_turn"):
            return {"action": "speak", "content": f"{self.name} says something generic."}

        return {"action": "pass"}

    def _defense_action(self) -> Dict[str, Any]:
        return {"action": "speak", "content": f"{self.name} defends themselves with honor."}

    def _final_vote_action(self) -> Dict[str, Any]:
        s = self.strategy
        if s.get("always_vote_guilty"):
            return {"action": "vote", "vote_type": "final_guilty"}
        if s.get("always_vote_innocent"):
            return {"action": "vote", "vote_type": "final_innocent"}
        return {"action": "vote", "vote_type": self.rng.choice(["final_guilty", "final_innocent"])}

    def _choose_target(self, candidates: list[str]) -> str:
        # Deterministic by sorting, or use seeded RNG
        candidates = [p for p in candidates if p != self.name]
        return self.rng.choice(candidates) if candidates else self.name


# === agents\__init__.py ===


# === evaluation\analysis.py ===
# mafia/evaluation/analysis.py
from typing import List, Dict

def log_game_summary(game_state) -> Dict:
    """
    Logs key metrics and summary data from a completed game.
    Returns a structured dictionary with faction, winners, predictions, etc.
    """
    summary = {
        "game_id": game_state.game_id,
        "winner": game_state.winner,
        "day_count": game_state.day_count,
        "players": [],
        "predictions": [],
        "votes": [],
        "whispers": [],
        "questions": [],
        "accusations": [],
    }

    for player in game_state.players:
        summary["players"].append({
            "name": player.name,
            "role": player.role.name,
            "faction": player.faction.value,
            "alive": player.alive,
        })

        for target, role in player.predicted_roles.items():
            summary["predictions"].append({
                "predictor": player.name,
                "target": target,
                "predicted_role": role
            })

        if player.vote:
            summary["votes"].append({
                "voter": player.name,
                "voted_for": player.vote
            })

        for target, whisper_text in player.whispers_sent.items():
            summary["whispers"].append({
                "from": player.name,
                "to": target,
                "content": whisper_text
            })

        for target, count in player.questions_asked.items():
            summary["questions"].append({
                "asker": player.name,
                "target": target,
                "times": count
            })

        if player.has_accused:
            summary["accusations"].append(player.name)

    return summary


# === evaluation\metrics.py ===
# mafia/evaluation/metrics.py
from collections import defaultdict
from typing import Dict, List


def compute_win_rate(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the win rate for each faction based on finished games.
    """
    results = defaultdict(int)
    for game in games:
        results[game["winner"]] += 1
    total = sum(results.values())
    return {faction: wins / total for faction, wins in results.items()}


def compute_average_tokens(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the average number of tokens used by each agent across games.
    """
    token_totals = defaultdict(int)
    token_counts = defaultdict(int)
    for game in games:
        for agent, tokens in game["tokens"].items():
            token_totals[agent] += tokens.get("input", 0) + tokens.get("output", 0)
            token_counts[agent] += 1
    return {
        agent: token_totals[agent] / token_counts[agent]
        for agent in token_totals
    }


def compute_average_role_accuracy(games: List[Dict]) -> float:
    """
    Computes how often role predictions were correct.
    """
    correct = 0
    total = 0
    for game in games:
        for entry in game["hidden_log"]:
            if "Predicted" in entry["info"]:
                # Format: "Predicted X as Y"
                parts = entry["info"].split()
                predicted_role = parts[-1]
                target = parts[1]
                actual_role = None
                for player in game["players"]:
                    if player["name"] == target:
                        actual_role = player["role"]
                        break
                if actual_role:
                    total += 1
                    if predicted_role == actual_role:
                        correct += 1
    return correct / total if total else 0.0


# === mechanics\messaging.py ===
# mafia/mechanics/messaging.py
from typing import Dict, List, Optional, Tuple
from mafia.enums import Phase

class Message:
    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):
        self.sender = sender              # Who sent the message
        self.content = content            # What was said (raw text or structured)
        self.target = target              # If whispering or targeting another player
        self.private = private            # Whisper if True, public otherwise

    def render(self) -> str:
        if self.private:
            return f"[WHISPER] {self.sender} → {self.target}: {self.content}"
        elif self.target:
            return f"{self.sender} → {self.target}: {self.content}"
        return f"{self.sender}: {self.content}"


class MessagingSystem:
    def __init__(self):
        self.history: List[Message] = []

    def send_public(self, sender: str, content: str):
        msg = Message(sender=sender, content=content)
        self.history.append(msg)
        return msg

    def send_private(self, sender: str, recipient: str, content: str):
        msg = Message(sender=sender, content=content, target=recipient, private=True)
        self.history.append(msg)
        return msg

    def get_visible_messages(self, player_name: str, phase: Phase) -> List[str]:
        visible = []
        for msg in self.history:
            if not msg.private:
                visible.append(msg.render())
            elif msg.private and (msg.sender == player_name or msg.target == player_name):
                visible.append(msg.render())
        return visible

    def get_all_messages(self) -> List[str]:
        return [msg.render() for msg in self.history]

    def clear(self):
        self.history.clear()

    def get_log_data(self) -> List[Dict]:
        return [{
            "sender": msg.sender,
            "target": msg.target,
            "private": msg.private,
            "content": msg.content
        } for msg in self.history]


# === mechanics\roles.py ===
# === mafia/mechanics/roles.py ===

from abc import ABC, abstractmethod
from mafia.enums import Faction
from typing import Optional, TYPE_CHECKING, Dict, Any, List

# Avoid circular import for type hinting
if TYPE_CHECKING:
    from mafia.player import Player
    from mafia.game_state import GameState

class Role(ABC):
    def __init__(self, name: str, faction: Faction):
        self.name = name
        self.faction = faction
        # For now, we use faction as the alignment. Override if needed.
        self.alignment = faction

    @abstractmethod
    def get_role_description(self) -> str:
        """Return a string describing the role's abilities and goals."""
        pass

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Executes the role's night action.
        Target selection logic is handled by the agent/player.
        Returns a dict representing the action taken, or None.
        """
        return None  # Default: No night action

    def can_act_at_night(self) -> bool:
        """Checks if the role has a meaningful night action."""
        return self.__class__.night_action != Role.night_action

    def get_available_targets(self, player: 'Player', game_state: 'GameState') -> List[str]:
        """
        Returns a list of valid target player names.
        Default: any alive player except self.
        Override to add additional filters.
        """
        return [p.name for p in game_state.players if p.alive and p.name != player.name]

    def win_condition_met(self, player: 'Player', game_state: 'GameState') -> Optional[bool]:
        """
        Stub for roles with unique win conditions.
        Returns True if the player's win condition is met,
        False if failed, or None if undecided.
        """
        return None  # Default: rely on faction win

    def get_llm_schema(self) -> Dict[str, Any]:
        """
        Returns a dictionary with structured information about the role,
        useful for prompting LLM-based agents.
        """
        return {
            "name": self.name,
            "faction": self.faction.value,
            "alignment": self.alignment.value,
            "can_act_at_night": str(self.can_act_at_night()),
            "description": self.get_role_description()
        }

    def __repr__(self):
        return f"<{self.faction.value}:{self.name}>"

# ------------------- TOWN ROLES -------------------

class Villager(Role):
    def __init__(self):
        super().__init__("Villager", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are a Villager. You have no special abilities. Find and lynch the Mafia."

    # Inherits default night_action (None)

class Cop(Role):
    def __init__(self):
        super().__init__("Cop", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia)."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent self-investigation
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot investigate yourself.")
            return None

        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            # Handle Godfather detection: if target is a Godfather and game config dictates, appear as Town
            if isinstance(target_player.role, Godfather) and not game_state.game_config.get("godfather_detectable", False):
                result_faction = Faction.TOWN
            else:
                result_faction = target_player.role.faction

            result_info = f"Investigated {target_player.name}: Result {result_faction.value}"
            player.log_hidden(game_state, f"\uD83D\uDD0E {result_info}")
            player.memory.append({
                "type": "investigation_result",
                "day": game_state.day_count,
                "target": target_player.name,
                "result": result_faction.value
            })
            return {"type": "investigate", "target": target_player.name, "result": result_faction.value}
        elif target_name:
            player.log_hidden(game_state, f"\uD83D\uDD0E Tried to investigate {target_name}, but they were not found or dead.")
        return None

class Doctor(Role):
    def __init__(self):
        super().__init__("Doctor", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Doctor. Each night, you can choose one player to protect from death."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Optionally, disallow self-protection based on configuration.
        if target_name == player.name and not game_state.game_config.get("doctor_can_self_heal", True):
            player.log_hidden(game_state, "You cannot protect yourself tonight.")
            return None

        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83E\uDE78 Protected {target_player.name}")
            return {"type": "protect", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83E\uDE78 Tried to protect {target_name}, but they were not found or dead.")
        return None

# ------------------- MAFIA ROLES -------------------

class Goon(Role):
    def __init__(self):
        super().__init__("Goon", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day."

    # Inherits default night_action (None)

class Godfather(Role):
    def __init__(self):
        super().__init__("Godfather", Faction.MAFIA)
        self.appears_as = Faction.TOWN  # To cops, unless detectable

    def get_role_description(self) -> str:
        return ("You are the Godfather. You appear as Town to the Cop. "
                "Each night, choose a target for the Mafia to kill. "
                "If you die, a Goon will be promoted.")

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent self-targeting or targeting fellow Mafia
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot target yourself.")
            return None
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player:
            if target_player.faction == Faction.MAFIA:
                player.log_hidden(game_state, "You cannot order a kill on a fellow Mafia member.")
                return None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83D\uDD2A Ordered kill on {target_player.name}")
            return {"type": "kill", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83D\uDD2A Tried to order kill on {target_name}, but they were not found or dead.")
        return None

# ------------------- NEW ROLES -------------------

class RoleBlocker(Role):
    def __init__(self):
        super().__init__("RoleBlocker", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are the RoleBlocker. Each night, you can block another player's action."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent blocking self
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot roleblock yourself.")
            return None
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"Blocked {target_player.name}'s action")
            return {"type": "roleblock", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"Tried to block {target_name}, but they were not found or dead.")
        return None

class Consigliere(Role):
    def __init__(self):
        super().__init__("Consigliere", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are the Consigliere. Each night, you may learn the exact role of one player."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            role_name = target_player.role.name
            player.log_hidden(game_state, f"Investigated {target_player.name}: Role = {role_name}")
            player.memory.append({
                "type": "role_peek",
                "day": game_state.day_count,
                "target": target_player.name,
                "role": role_name
            })
            return {"type": "consigliere_investigate", "target": target_player.name, "result": role_name}
        elif target_name:
            player.log_hidden(game_state, f"Tried to investigate {target_name}, but they were not found or dead.")
        return None

# ------------------- OPTIONAL HELPER METHODS -------------------

# These can be overridden by individual roles if needed.
# For example, a role may override win_condition_met for unique victory conditions.
def default_win_condition(player: 'Player', game_state: 'GameState') -> Optional[bool]:
    return None

# ------------------- ROLE REGISTRY -------------------

ROLE_CLASS_MAP = {
    "villager": Villager,
    "cop": Cop,
    "doctor": Doctor,
    "goon": Goon,
    "godfather": Godfather,
    "roleblocker": RoleBlocker,
    "consigliere": Consigliere,
    # Add additional roles here...
}

def get_role_class(role_name: str) -> Optional[type[Role]]:
    return ROLE_CLASS_MAP.get(role_name.lower())


# === mechanics\voting.py ===
# mafia/mechanics/voting.py
from typing import Dict, Optional
from mafia.enums import Phase
from mafia.game_state import GameState


def cast_vote(game_state: GameState, voter: str, target: str) -> None:
    """Player casts or changes vote for someone."""
    if game_state.phase != Phase.DAY or voter not in game_state.alive_players:
        return

    # Remove old vote if it exists
    if voter in game_state.voting_targets:
        prev_target = game_state.voting_targets[voter]
        if prev_target != target:
            game_state.messages.append(f"{voter} changed their vote from {prev_target} to {target}.")
    else:
        game_state.messages.append(f"{voter} has voted for {target}.")

    game_state.voting_targets[voter] = target
    check_accusation_threshold(game_state)


def retract_vote(game_state: GameState, voter: str) -> None:
    """Player retracts their vote."""
    if voter in game_state.voting_targets:
        prev = game_state.voting_targets.pop(voter)
        game_state.messages.append(f"{voter} retracted their vote on {prev}.")


def check_accusation_threshold(game_state: GameState, threshold: float = 0.5) -> None:
    """Automatically trigger accusation if a player reaches vote threshold."""
    vote_counts: Dict[str, int] = {}
    for target in game_state.voting_targets.values():
        vote_counts[target] = vote_counts.get(target, 0) + 1

    total_voters = len(game_state.alive_players)
    for target, count in vote_counts.items():
        if count / total_voters >= threshold and game_state.accused_player != target:
            game_state.accused_player = target
            game_state.messages.append(f"{target} has been accused and must now defend themselves.")


def confirm_lynch_vote(game_state: GameState, voter: str, confirm: bool) -> None:
    """Player confirms or denies the lynch after accusation."""
    if game_state.phase != Phase.DAY or not game_state.accused_player:
        return

    game_state.lynch_confirm_votes[voter] = confirm
    yes_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if vote)
    no_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if not vote)

    total_voters = len(game_state.alive_players)
    if yes_votes > total_voters // 2:
        game_state.messages.append(f"{game_state.accused_player} has been lynched by majority vote.")
        game_state.kill_player(game_state.accused_player)
        game_state.reset_votes()
    elif no_votes >= total_voters // 2:
        game_state.messages.append(f"{game_state.accused_player} has survived the vote.")
        game_state.reset_votes()


# --------------------------
# Whisper Mechanics
# --------------------------

def whisper(game_state: GameState, sender: str, recipient: str, message: str) -> None:
    """Send a whisper from one player to another. Hidden from all other agents."""
    if sender not in game_state.alive_players or recipient not in game_state.alive_players:
        return

    # Track hidden message to sender and recipient
    for player in game_state.players:
        if player.name in {sender, recipient}:
            player.log_hidden(game_state, f"[WHISPER] {sender} → {recipient}: {message}")
        else:
            player.log_hidden(game_state, f"[WHISPER] {sender} → {recipient}: <hidden>")

    # Log public metadata
    game_state.messages.append(f"{sender} whispered to {recipient}.")


# --------------------------
# Voting Visibility
# --------------------------

def get_vote_visibility(game_state: GameState) -> Dict[str, str]:
    """Return a dict of current votes (publicly visible for now)."""
    return {voter: target for voter, target in game_state.voting_targets.items()}


# === mechanics\__init__.py ===


# === prompts\mafia_template.py ===
def format_prompt(name: str, obs: dict) -> str:
    # Format as readable context for the agent
    lines = [f"Day {obs['day']} | Phase: {obs['phase']}"]
    lines.append("Alive: " + ", ".join(obs["alive"]))
    lines.append("Dead: " + ", ".join(obs["dead"]))
    lines.append("Messages:")
    lines.extend(obs["messages"])
    lines.append("What do you do next? Choose one action:")
    return "\n".join(lines)

def parse_response(response: str) -> dict:
    """
    Expects LLM to return something like:
    <action> accuse </action> <target> Player3 </target>
    """
    import re
    act = re.search(r"<action>(.*?)</action>", response)
    tgt = re.search(r"<target>(.*?)</target>", response)
    return {
        "action": act.group(1).strip().lower() if act else "pass",
        "target": tgt.group(1).strip() if tgt else None
    }


# === utils\token_cost.py ===


