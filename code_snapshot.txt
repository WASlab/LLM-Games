# === mafia\config.py ===


# === mafia\enums.py ===
from enum import Enum

class Faction(Enum):
    TOWN = "town"
    MAFIA = "mafia"
    NEUTRAL = "neutral" # Reserved for extensibility

class GamePhase(Enum):
    NIGHT = "night"
    DAY_DISCUSSION = "day_discussion"
    VOTING = "voting"
    DEFENSE = "defense" # Optional phase if accusation needs defense
    FINAL_VOTE = "final_vote" # Optional phase for final lynch decision
    GAME_OVER = "game_over"

class VoteType(Enum):
    ACCUSATION = "accusation" # Initial vote during day
    FINAL_GUILTY = "final_guilty" # Vote during final lynch
    FINAL_INNOCENT = "final_innocent" # Vote during final lynch
    SKIP = "skip" # Abstain from voting

# === mafia\environment.py ===
# === mafia/environment.py ===

import random
from collections import deque
from typing import Dict, List, Optional, Any, Tuple, Set

# Core project imports (ensure they match your directory structure)
from llm_games.mafia.game_state import GameState, GameMessage
from llm_games.mafia.player import Player
from llm_games.mafia.enums import GamePhase, Faction, VoteType
from llm_games.mafia.mechanics.roles import Cop, Godfather, RoleBlocker,Doctor
# If you have a RoleBlocker or Blackmailer, import them similarly:
# from llm_games.mafia.mechanics.roles import RoleBlocker, Blackmailer

# from llm_games.mafia.rewards import compute_rewards  # If/when using a reward system
# from llm_games.mafia.utils.token_cost import track_tokens  # If/when tracking token budgets

# Dummy placeholders if those modules are not yet implemented:
def compute_rewards(state) -> Dict[str, float]:
    """Placeholder if you have not implemented rewards yet."""
    return {}

class TokenTracker:
    """Placeholder if you want to track tokens or verbosity budgets."""
    def __init__(self):
        self.usage = {}

    def update(self, *args, **kwargs):
        pass

    def to_dict(self):
        return dict(self.usage)


class MafiaEnvironment:
    """
    Manages the overall flow, phases, action resolution, and messaging for a Mafia game.

    Key Features:
      - Night action resolution with roleblock → protect → kill → investigate ordering
      - Day discussion with round-robin speaking, optional questioning, accusations
      - Voting phases, including defense and final vote
      - Tie votes or lack of majority → no lynch → transition to Night
      - Basic checks for valid night targets (e.g., Godfather cannot target a fellow Mafia)
    """

    def __init__(self, players: List[Player], config: Dict[str, Any]):
        """
        :param players: Pre-created list of Player objects with assigned roles.
        :param config:  Dictionary of configuration options (e.g. 'lynch_defense_enabled', etc.).
        """
        self.config = config

        # Initialize the game state
        self.state = GameState(players=players, game_config=config)
        self.state.initialize()

        # Token/budget tracking if desired
        self.token_tracker = TokenTracker()

        # Various environment configs
        self.lynch_defense_enabled: bool = self.config.get("lynch_defense_enabled", True)
        self.cop_speaks_first: bool = self.config.get("cop_speaks_first", False)

        # Day phase tracking
        self._speaker_queue: deque[str] = deque()
        # Queue of (questioner, questioned) to handle immediate back-and-forth:
        self._question_queue: deque[Tuple[str, str]] = deque()
        self._turns_taken_this_round: Set[str] = set()
        self._consecutive_passes: int = 0

    # ----------------------------------------------------------------
    # Public Methods for Simulation Loop
    # ----------------------------------------------------------------

    def step_phase(self) -> bool:
        """
        Advances the game by one phase (e.g., from Night → Day or running the defense → final vote).
        Returns True if the game has ended, False otherwise.
        """
        if self.state.game_over:
            return True

        current_phase = self.state.phase

        if current_phase == GamePhase.NIGHT:
            self._resolve_night()
            self._transition_to_day()

        elif current_phase == GamePhase.DAY_DISCUSSION:
            # The discussion-phase turns are advanced by process_player_action or advance_turn.
            # step_phase can check if we need to end discussion automatically.
            if self._check_discussion_end():
                self._transition_to_voting()

        elif current_phase == GamePhase.VOTING:
            # In a simpler design, voting might be resolved automatically or by some timer logic.
            # Often, you transition out of VOTING once everyone has voted, but that can be
            # handled in process_player_action or an external runner. So we just do a no-op here.
            pass

        elif current_phase == GamePhase.DEFENSE:
            # Let the accused speak; then move on to final vote.
            self._run_defense()
            self._transition_to_final_vote()

        elif current_phase == GamePhase.FINAL_VOTE:
            # Once final votes are in (or forced), resolve lynch.
            self._resolve_lynch()
            self._transition_to_night()

        return self.state.check_game_end()

    def get_current_player_name(self) -> Optional[str]:
        """Returns the name of the player whose turn it is to act (during DAY_DISCUSSION)."""
        return self.state.current_player_turn

    def get_observation(self, player_name: str) -> Dict[str, Any]:
        """Returns an observation dict for the specified player (public messages, private info, etc.)."""
        return self.state.get_player_observation(player_name)

    def process_player_action(self, player_name: str, action: Dict[str, Any]) -> bool:
        """
        The main method for handling actions from a player's agent.
        Returns True if the action was processed successfully, False if invalid.
        """
        player = self.state.get_player(player_name)
        if not player or not player.alive:
            self.state.log_hidden(player_name, f"Ignored action {action}; player is dead or invalid.")
            return False

        # Check if it is actually this player's turn (in discussion) or if we allow free actions
        if self.state.phase == GamePhase.DAY_DISCUSSION:
            if self.state.current_player_turn != player_name:
                self.state.log_hidden(
                    player_name, 
                    f"Attempted action {action} but it is not {player_name}'s turn."
                )
                return False

        # Log the attempt
        self.state.log_hidden(player_name, f"Received action: {action}")
        action_type = action.get("action")
        target = action.get("target")
        content = action.get("content")
        self.token_tracker.update(player_name, action_type, content)

        success = False

        # ----------------------------------------------------------------
        # NIGHT ACTIONS
        # ----------------------------------------------------------------
        if self.state.phase == GamePhase.NIGHT:
            if player.can_act_at_night():
                # The player's role logic typically sets a night_action dict or returns None if invalid.
                player.night_target = target
                intended_action = player.perform_night_action(self.state)

                # Optionally, we enforce extra checks (e.g., Godfather cannot target mafia).
                intended_action = self._validate_night_action(player, intended_action)

                if intended_action:
                    self.state.register_night_action(player_name, intended_action)
                success = True  # We treat it as a valid "turn" even if no action is performed.
            else:
                self.state.log_hidden(player_name, "Tried to act at night but this role has no night action.")
                success = True

        # ----------------------------------------------------------------
        # DAY ACTIONS - Discussion Phase
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.DAY_DISCUSSION:
            success = self._process_day_discussion_action(player, action_type, target, content)

            # If the action was valid, move to next speaker (unless an immediate phase transition happens).
            if success and not self.state.player_on_trial:
                # If an accusation occurs, we transition to voting within the same turn, so skip advance_turn
                self.advance_turn()
            

        # ----------------------------------------------------------------
        # VOTING PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.VOTING:
            success = self._process_voting_phase_action(player, action_type, target, content)

        # ----------------------------------------------------------------
        # DEFENSE PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.DEFENSE:
            if player_name == self.state.player_on_trial:
                # The accused can make a statement (content) or pass
                if content:
                    self.state.log_message(player_name, f"(Defense) {content}")
                else:
                    self.state.log_message(player_name, "(Defense) [No statement provided]")
                success = True
            else:
                self.state.log_hidden(player_name, f"Not on trial; ignoring defense action.")
                success = False

        # ----------------------------------------------------------------
        # FINAL VOTE PHASE
        # ----------------------------------------------------------------
        elif self.state.phase == GamePhase.FINAL_VOTE:
            success = self._process_final_vote_action(player, action)

        # ----------------------------------------------------------------
        # If action was valid but the day discussion is still ongoing, 
        # we might want to continue or see if we transition to next phase.
        # ----------------------------------------------------------------
        if not success:
            self.state.log_hidden(player_name, f"Action {action} could not be processed.")
        return success

    def advance_turn(self):
        """
        Advances to the next person's turn in the DAY_DISCUSSION phase,
        respecting any question queue ordering (the questioned player, then questioner’s response).
        """
        if self.state.phase != GamePhase.DAY_DISCUSSION:
            self.state.current_player_turn = None
            return

        # If we have a question queue, that takes priority
        if self._question_queue:
            questioner, questioned = self._question_queue.popleft()
            # The questioned player goes first
            self.state.current_player_turn = questioned
            self.state.turn_context = {"answering_question_from": questioner}

            # Then queue the questioner as next (a short follow-up), unless questioner == questioned
            if questioner != questioned:
                self._question_queue.appendleft((questioner, questioner))
            return

        # If the main speaker queue is empty, check discussion end or start a new round
        if not self._speaker_queue or self._consecutive_passes >= len(self.state.alive_players):
            self._transition_to_voting()
            return

        next_speaker = self._speaker_queue.popleft()
        self.state.current_player_turn = next_speaker
        self.state.turn_number_in_phase += 1
        self.state.turn_context = None

    # ----------------------------------------------------------------
    # Internal / Private Helpers
    # ----------------------------------------------------------------

    def _resolve_night(self):
        """Resolves all players' night actions in the correct order (roleblock, protect, kill, investigate, etc.)."""
        self.state.log_message("system", "Night ends. Resolving all night actions...")
        self.state.night_action_results.clear()
        submitted_actions = self.state.night_actions_submitted

        # 1. Roleblocks
        roleblocked_players: Set[str] = set()
        # 2. Blackmail
        blackmailed_players: Set[str] = set()

        for actor, action_dict in submitted_actions.items():
            if not self.state.is_alive(actor):
                continue  # Actor died mid-night somehow

            # e.g. if action_dict["type"] == "roleblock": ...
            # Example placeholder:
            if action_dict.get("type") == "roleblock":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    roleblocked_players.add(target)
                    self.state.log_hidden(
                        actor, f"Roleblocked {target} for the night."
                    )
            elif action_dict.get("type") == "blackmail":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    blackmailed_players.add(target)
                    self.state.log_hidden(actor, f"Blackmailed {target} for the day.")

        # Mark roleblocked players
        for blocked in roleblocked_players:
            p = self.state.get_player(blocked)
            if p:
                p.is_roleblocked = True

        # Mark blackmailed players so they can't speak tomorrow
        for bm in blackmailed_players:
            p = self.state.get_player(bm)
            if p:
                p.can_speak_today = False

        # 3. Protections
        protected: Dict[str, str] = {}
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "protect":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    # If multiple doctors protect the same target, the first or last might "win."
                    # Here we allow the first to stand; you can choose whichever convention you like.
                    if target not in protected:
                        protected[target] = actor
                        # For debug or future logic
                        target_p = self.state.get_player(target)
                        if target_p:
                            target_p.protected_by = actor
                        self.state.log_hidden(
                            actor, f"Protected {target} this night."
                        )

        # 4. Kills
        kills_attempted: List[Tuple[str, str]] = []
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "kill":
                target = action_dict.get("target")
                if target and self.state.is_alive(target):
                    kills_attempted.append((actor, target))
                    self.state.log_hidden(actor, f"Attempting kill on {target}.")

        successful_kills: Set[str] = set()
        for (killer, target) in kills_attempted:
            if target not in protected:
                successful_kills.add(target)
                self.state.log_hidden(killer, f"Kill on {target} succeeded.")
            else:
                doc = protected[target]
                self.state.log_hidden(killer, f"Kill on {target} failed (protected by {doc}).")
                self.state.log_hidden(doc, f"You successfully protected {target} from a kill.")

        # Apply kills
        deaths = []
        for victim in successful_kills:
            if self.state.is_alive(victim):
                self.state.kill_player(victim, reason="killed during night")
                deaths.append(victim)

        # 5. Investigations
        for actor, action_dict in submitted_actions.items():
            if actor in roleblocked_players:
                continue
            if not self.state.is_alive(actor):
                continue
            if action_dict.get("type") == "investigate":
                target = action_dict.get("target")
                result = action_dict.get("result")
                # Cop/Consigliere logic typically updates the player's memory. 
                # We also store it in environment logs.
                self.state.log_hidden(
                    actor, f"Investigation result on {target}: {result}"
                )
                self.state.night_action_results[actor] = action_dict

        if deaths:
            # Alphabetical or by order of kills
            self.state.log_message(
                "system",
                f"The sun rises. The following were found dead: {', '.join(sorted(deaths))}."
            )
        else:
            self.state.log_message("system", "The sun rises. Miraculously, nobody died last night!")

    def _transition_to_day(self):
        """Moves the game into DAY_DISCUSSION, resetting relevant flags and re-initializing speaker queues."""
        self.state.log_hidden("system", "Transitioning to Day phase.")
        # Clear roleblock statuses, etc.
        for p in self.state.players:
            p.reset_night_state()

        # Switch to day
        self.state.phase = GamePhase.DAY_DISCUSSION
        self.state.day_count += 1
        self.state.reset_day_phase_state()

        # Start a fresh speaking queue
        self._start_new_discussion_round()
        self.state.log_message("system", f"Day {self.state.day_count} begins. Discuss and vote!")

    def _start_new_discussion_round(self):
        """Initializes or re-initializes the round-robin talk queue for the day discussion phase."""
        self._speaker_queue.clear()
        self._question_queue.clear()
        self._turns_taken_this_round.clear()
        self._consecutive_passes = 0
        self.state.turn_context = None
        self.state.turn_number_in_phase = 0

        alive_names = sorted(self.state.alive_players)
        # If config demands Cop speak first
        if self.cop_speaks_first:
            for name in alive_names:
                pl = self.state.get_player(name)
                if pl and isinstance(pl.role, Cop):
                    alive_names.remove(name)
                    alive_names.insert(0, name)
                    self.state.log_hidden("system", f"Cop ({name}) will speak first today.")
                    break

        self._speaker_queue.extend(alive_names)
        # Force the environment to choose the first speaker
        self.advance_turn()

    def _check_discussion_end(self) -> bool:
        alive_count = len(self.state.alive_players)
        # Set minimum turns: 1 turn each for Day 0, 2 for later days.
        min_turns = self.config.get("min_discussion_turns", 2)
        if self.state.day_count == 0:
            min_turns = 1

        # Count turns from the hidden log for each player during DAY_DISCUSSION.
        player_turn_counts = {p: 0 for p in self.state.alive_players}
        for entry in self.state.hidden_log:
            if entry.get("phase") == GamePhase.DAY_DISCUSSION.name and entry.get("actor") in player_turn_counts:
                player_turn_counts[entry["actor"]] += 1

        self.state.log_hidden("system", f"Discussion turn counts: {player_turn_counts}")

        # End discussion if all players have met the minimum turns.
        if all(count >= min_turns for count in player_turn_counts.values()):
            self.state.log_hidden("system", f"All players completed {min_turns} discussion turns. Ending discussion.")
            return True

        # Alternatively, if everyone passes consecutively.
        if self._consecutive_passes >= alive_count:
            self.state.log_hidden("system", "All players passed consecutively. Ending discussion.")
            return True

        return False


    def _transition_to_voting(self):
        """
        Day discussion → Voting on the accused (or skipping to night if no accusations).
        """
        if not self.state.player_on_trial:
            self.state.log_message("system", "No one was put on trial today.")
            self._transition_to_night()
            return

        self.state.log_message("system", f"{self.state.player_on_trial} is on trial!")
        self.state.votes_for_lynch.clear()

        if self.lynch_defense_enabled:
            self.state.phase = GamePhase.DEFENSE
            self.state.current_player_turn = self.state.player_on_trial
            self.state.log_message(
                "system",
                f"{self.state.player_on_trial}, you may speak in your defense."
            )
        else:
            # Skip defense and go directly to final vote
            self._transition_to_final_vote()

    def _run_defense(self):
        """
        A placeholder hook for the defense phase. 
        The simulation typically calls process_player_action(...) so the accused can make a statement.
        """
        self.state.log_hidden("system", f"Defense phase for {self.state.player_on_trial}.")

    def _transition_to_final_vote(self):
        """
        Moves from DEFENSE → FINAL_VOTE. 
        All alive players can vote guilty/innocent simultaneously or in a loop if you prefer.
        """
        self.state.phase = GamePhase.FINAL_VOTE
        self.state.current_player_turn = None
        self.state.votes_for_lynch.clear()
        self.state.log_message(
            "system",
            f"Final voting begins for {self.state.player_on_trial}. Vote GUILTY or INNOCENT."
        )

    def _resolve_lynch(self):
        """
        After the final vote, count how many guilty vs. innocent votes. 
        Majority (strictly >= half+1) => lynch. Otherwise, no lynch.
        """
        if not self.state.player_on_trial:
            self.state.log_hidden("system", "No player on trial, skipping lynch resolution.")
            return

        votes = self.state.votes_for_lynch
        guilty = sum(1 for is_guilty in votes.values() if is_guilty)
        innocent = len(votes) - guilty
        total_alive = len(self.state.alive_players)
        needed_for_lynch = (total_alive // 2) + 1

        self.state.log_message(
            "system",
            f"Vote Results for {self.state.player_on_trial}: "
            f"Guilty={guilty}, Innocent={innocent}. Need {needed_for_lynch} to lynch."
        )
        self.state.log_hidden("system", f"Final Votes: {votes}")

        if guilty >= needed_for_lynch:
            self.state.log_message("system", f"The town has decided to lynch {self.state.player_on_trial}!")
            self.state.kill_player(self.state.player_on_trial, reason="lynched")
        else:
            self.state.log_message("system", f"The vote is inconclusive, sparing {self.state.player_on_trial}.")

        self.state.player_on_trial = None

    def _transition_to_night(self):
        """
        Resets day state and transitions to NIGHT, unless the game has ended.
        Typically called after lynch resolution or if no trial occurred.
        """
        self.state.log_hidden("system", "Transitioning to Night phase.")
        if self.state.player_on_trial and self.state.phase != GamePhase.NIGHT:
            # If for some reason we haven't resolved the lynch yet, do it now
            self._resolve_lynch()

        if self.state.check_game_end():
            return  # If game ended from a lynch, stop here

        self.state.phase = GamePhase.NIGHT
        self.state.reset_night_phase_state()
        self.state.current_player_turn = None
        self.state.log_message("system", "Night falls. Mafia members, choose your targets...")

    def apply_rewards(self):
        """
        Optional: If you have a reward system, call it here to store or return
        partial or final rewards for each player/agent.
        """
        rewards = compute_rewards(self.state)
        self.state.log_hidden("system", f"Computed rewards (not saved): {rewards}")
        # Optionally store them in the GameState or return them

    # ----------------------------------------------------------------
    # Day-Phase Action Helpers
    # ----------------------------------------------------------------

    def _process_day_discussion_action(
        self, 
        player: Player, 
        action_type: str, 
        target: Optional[str], 
        content: Optional[str]
    ) -> bool:
        """
        Handle actions that can occur specifically in the DAY_DISCUSSION phase.
        Returns True if valid, False otherwise.
        """
        # Reset consecutive passes only if the action is not a "pass"
        if action_type == "pass":
            self._consecutive_passes += 1
            self.state.log_message(player.name, f"{player.name} passes.")
            # Mark that the player has taken a turn
            self._turns_taken_this_round.add(player.name)
            return True
        elif action_type == "accuse" and target:
            if self.state.day_count == 0:
                self.state.log_hidden(player.name, "Accusations are not allowed on Day 0.")
                return False
            success = player.accuse(target, self.state)
            if success:
                self.state.player_on_trial = target
            self._turns_taken_this_round.add(player.name)
            return success
        else:
            # They did something, so reset the pass counter
            self._consecutive_passes = 0

        # Accuse
        if action_type == "accuse" and target:
            if self.state.player_on_trial:
                self.state.log_hidden(player.name, "Cannot accuse; someone is already on trial.")
                return False
            success = player.accuse(target, self.state)
            if success:
                self.state.player_on_trial = target
            self._turns_taken_this_round.add(player.name)
            return success

        # Vote (during discussion, not final vote)
        elif action_type == "vote" and target:
            success = player.vote_for(target, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Question
        elif action_type == "question" and target and content:
            # Possibly limit # of questions per day, per target
            times_asked = player.questions_asked_today.get(target, 0)
            if times_asked >= 1:
                self.state.log_hidden(player.name, f"Question limit reached for {target}.")
                return False
            success = player.question(target, content, self.state)
            if success:
                player.questions_asked_today[target] = times_asked + 1
                # Add the Q&A flow to the question queue
                self._question_queue.append((player.name, target))
                # Then the questioner is scheduled to respond
                self._question_queue.append((player.name, player.name))
            self._turns_taken_this_round.add(player.name)
            return success

        # Predict role
        elif action_type == "predict" and target and content:
            success = player.predict_role(target, content, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Whisper
        elif action_type == "whisper" and target and content:
            success = player.whisper(target, content, self.state)
            self._turns_taken_this_round.add(player.name)
            return success

        # Generic talk
        elif action_type == "speak":
            if content:
                self.state.log_message(player.name, content)
                self._turns_taken_this_round.add(player.name)
                return True
            else:
                self.state.log_hidden(player.name, "Tried to speak but no content was provided.")
                return False

        # If none of the above matched, treat as invalid or a default "speak"
        if content:
            self.state.log_message(player.name, content)
            self._turns_taken_this_round.add(player.name)
            return True

        self.state.log_hidden(player.name, f"Invalid or unrecognized day action: {action_type}")
        return False

    def _process_voting_phase_action(
        self,
        player: Player,
        action_type: str,
        target: Optional[str],
        content: Optional[str]
    ) -> bool:
        """
        Handle standard voting phase (pre-defense or a simpler immediate-voting system).
        If you prefer all final votes to happen in FINAL_VOTE, you can keep this minimal.
        """
        if action_type == "vote" and target == self.state.player_on_trial:
            # If the environment merges "voting" and "final vote," you could do a direct guilty/innocent.
            # Otherwise, you might track 'vote_for_lynch' in the state, or do a simpler approach.
            player.vote_for(target, self.state)
            self.state.log_message(player.name, f"votes to lynch {target} in the standard voting phase.")
            return True

        # You can add logic for 'skip' or 'abstain' as well:
        elif action_type == "skip":
            self.state.log_message(player.name, f"{player.name} decides not to vote right now.")
            return True

        self.state.log_hidden(player.name, f"Invalid or mismatched action {action_type} in VOTING phase.")
        return False

    def _process_final_vote_action(self, player: Player, action: Dict[str, Any]) -> bool:
        """
        In FINAL_VOTE phase, each player declares GUILTY or INNOCENT (or possibly abstains).
        action might look like {"action": "vote", "vote_type": "final_guilty"}
        """
        action_type = action.get("action")
        vote_type_str = action.get("vote_type", "").lower()

        # Must be a "vote" action
        if action_type != "vote":
            self.state.log_hidden(player.name, f"Expected a vote action in FINAL_VOTE, got {action_type}.")
            return False

        if vote_type_str == "final_guilty":
            self.state.votes_for_lynch[player.name] = True
            self.state.log_message(
                player.name,
                f"votes GUILTY on {self.state.player_on_trial}."
            )
            return True
        elif vote_type_str == "final_innocent":
            self.state.votes_for_lynch[player.name] = False
            self.state.log_message(
                player.name,
                f"votes INNOCENT on {self.state.player_on_trial}."
            )
            return True
        elif vote_type_str == "abstain":
            self.state.log_message(player.name, f"abstains from voting.")
            return True
        else:
            self.state.log_hidden(
                player.name,
                f"Invalid final vote type: {vote_type_str} (expected 'final_guilty' or 'final_innocent')."
            )
            return False

    # ----------------------------------------------------------------
    # Night Action Validation
    # ----------------------------------------------------------------

    def _validate_night_action(self, player: Player, action_dict: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Optional: Enforces certain constraints on night actions:
          - Godfather cannot kill themselves or a fellow Mafia
          - Cop cannot investigate themselves
          - Roleblocker cannot block themselves
          - ...
        Return the action_dict if valid, or None if invalid.
        """
        if not action_dict:
            return None

        action_type = action_dict.get("type")
        target = action_dict.get("target")

        # Basic checks: must have a target
        if not target:
            self.state.log_hidden(player.name, "No target specified for night action.")
            return None

        # Cop cannot investigate self
        if action_type == "investigate" and target == player.name:
            self.state.log_hidden(player.name, "Cop tried to investigate themselves; invalid.")
            return None

        # Godfather can't kill themselves or mafia
        if action_type == "kill" and isinstance(player.role, Godfather):
            target_p = self.state.get_player(target)
            if target_p:
                if target_p.faction == Faction.MAFIA or target_p.name == player.name:
                    self.state.log_hidden(
                        player.name,
                        "Godfather tried to kill themselves or a fellow Mafia, invalid action."
                    )
                    return None

        # Roleblocker cannot block themselves (if you have a RoleBlocker role)
        if action_type == "roleblock" and isinstance(player.role, RoleBlocker):
            if target == player.name:
                self.state.log_hidden(player.name, "RoleBlocker tried to block themselves, invalid.")
                return None

        return action_dict


# === mafia\export.py ===
# export.py
import os
import json

def collect_python_files(root_dir: str) -> dict:
    file_structure = {}

    for dirpath, _, filenames in os.walk(root_dir):
        for file in filenames:
            if file.endswith('.py'):
                full_path = os.path.join(dirpath, file)
                rel_path = os.path.relpath(full_path, root_dir)
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                file_structure[rel_path] = content

    return file_structure

def export_to_json(output_path="code_snapshot.json", root="mafia"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(all_files, f, indent=2)

def export_to_text(output_path="code_snapshot.txt", root="llm_games"):
    all_files = collect_python_files(root)
    with open(output_path, 'w', encoding='utf-8') as f:
        for path, content in all_files.items():
            f.write(f"# === {path} ===\n")
            f.write(content + "\n\n")

if __name__ == "__main__":
    export_to_json()
    export_to_text()
    print("✅ Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'")


# === mafia\game_state.py ===
# === mafia/game_state.py ===

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Any, Union
import uuid

# Core references to your enums, players, and roles:
from llm_games.mafia.enums import GamePhase, Faction
from llm_games.mafia.player import Player
from llm_games.mafia.mechanics.roles import Goon, Godfather, get_role_class

# -------------------------------------------------------------------
# Define the "type" of a single logged message, for clarity.
# Feel free to expand or rename these categories.
# -------------------------------------------------------------------
MESSAGE_TYPES = (
    "system",            # Internal system or phase announcements
    "public",            # Publicly spoken messages
    "whisper",           # Private whisper from A→B
    "vote",              # Voting or accusation messages
    "death_announcement" # Messages triggered on death
    # ... add "debug", "accusation", etc. as you see fit
)

@dataclass
class GameMessage:
    """Structured record of a single game message."""
    msg_type: str       # e.g. 'system', 'public', 'whisper', ...
    sender: str         # 'system' or player_name
    content: str
    recipients: Optional[List[str]] = None  # None means public
    phase: GamePhase = GamePhase.NIGHT
    day: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a serializable dict (helpful if you store logs as JSON)."""
        return {
            "type": self.msg_type,
            "sender": self.sender,
            "content": self.content,
            "recipients": self.recipients,
            "phase": self.phase.name,
            "day": self.day
        }


@dataclass
class GameState:
    """
    Central data store for a Mafia game:
      - Keeps track of players, alive/dead sets, messages, day/night transitions
      - Contains methods for logging and checking endgame
    """

    # ------------------------------
    # Core game setup
    # ------------------------------
    players: List[Player]
    game_config: Dict[str, Any] = field(default_factory=dict)  # e.g. "lynch_required": True, etc.

    # ------------------------------
    # Phase & Turn Tracking
    # ------------------------------
    phase: GamePhase = GamePhase.NIGHT
    day_count: int = 0
    turn_number_in_phase: int = 0
    current_player_turn: Optional[str] = None

    # Keep track of which players are alive or dead
    alive_players: Set[str] = field(default_factory=set)
    dead_players: Set[str] = field(default_factory=set)

    # ------------------------------
    # Logging
    # ------------------------------
    # Public and private logs
    messages: List[GameMessage] = field(default_factory=list)
    hidden_log: List[Dict[str, Any]] = field(default_factory=list)

    # ------------------------------
    # Accusation / Voting (Day)
    # ------------------------------
    # E.g. for a pre-trial voting system if you use it
    votes_for_accusation: Dict[str, str] = field(default_factory=dict)  # voter -> target
    accusation_counts: Dict[str, int] = field(default_factory=dict)     # target -> count

    # Which player is currently on trial (if any)
    player_on_trial: Optional[str] = None

    # Final-lunch votes: None = abstain, True = Guilty, False = Innocent
    votes_for_lynch: Dict[str, Optional[bool]] = field(default_factory=dict)

    # Token budgets for controlling how much players can speak (optional)
    discussion_token_budgets: Dict[str, int] = field(default_factory=dict)

    # ------------------------------
    # Night Phase Action Tracking
    # ------------------------------
    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)

    # ------------------------------
    # Game Identity & Completion
    # ------------------------------
    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    game_over: bool = False
    winner: Optional[Faction] = None
    final_player_roles: Dict[str, str] = field(default_factory=dict)  # e.g. "Alice": "Godfather"

    # Optional: track transitions or time-based info
    phase_history: List[Dict[str, Any]] = field(default_factory=list)

    # ----------------------------------------------------------------
    # Initialization & Setup
    # ----------------------------------------------------------------

    def initialize(self):
        """Called once at game start to populate initial states."""
        self.alive_players = {p.name for p in self.players}
        self.dead_players.clear()
        self.day_count = 0
        self.phase = GamePhase.NIGHT
        self.game_over = False
        self.winner = None
        self.messages.clear()
        self.hidden_log.clear()
        self.final_player_roles.clear()
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()

        # Reset each player's personal state
        for player in self.players:
            player.reset_for_new_game()
            # Optionally set token budgets if using
            # initial_tokens = self.game_config.get("initial_tokens", 999)
            # self.discussion_token_budgets[player.name] = initial_tokens

        # Example: record the start of the initial phase
        self.record_phase_start()

        # Log game creation
        self.log_message("system", "Game started.", msg_type="system")
        self.log_hidden("system", f"Game ID: {self.game_id}")
        self.log_hidden("system", f"Initial Roles: { {p.name: p.role.name for p in self.players} }")

    # ----------------------------------------------------------------
    # Player & Survival
    # ----------------------------------------------------------------

    def get_player(self, name: str) -> Optional[Player]:
        return next((p for p in self.players if p.name == name), None)

    def is_alive(self, name: str) -> bool:
        return name in self.alive_players

    def kill_player(self, name: str, reason: str = "killed"):
        """
        Officially kills a player:
          - Removes from alive_players
          - Logs death message
          - Checks if Godfather died => Goon promotion
          - Triggers check_game_end
        """
        if name not in self.alive_players:
            return  # Already dead or invalid

        player = self.get_player(name)
        if not player:
            return

        self.alive_players.remove(name)
        self.dead_players.add(name)
        player.alive = False

        self.log_message(
            "system",
            f"{name} ({player.role.name}) has died ({reason}).",
            msg_type="death_announcement"
        )
        self.log_hidden("system", f"{name} died. Reason: {reason}")

        # Check for Godfather death => Promote a Goon
        if isinstance(player.role, Godfather):
            self._promote_goon_to_gf(dead_gf_name=name)

        self.check_game_end()

    def _promote_goon_to_gf(self, dead_gf_name: str):
        """Promote the first alive Goon to Godfather upon GF death."""
        promoted_goon: Optional[Player] = None
        for p in self.players:
            if p.name in self.alive_players and isinstance(p.role, Goon):
                promoted_goon = p
                break

        if promoted_goon:
            new_role = Godfather()
            promoted_goon.role = new_role
            promoted_goon.faction = new_role.faction
            self.log_message(
                "system",
                f"{promoted_goon.name} has been promoted to Godfather!",
                msg_type="system"
            )
            self.log_hidden(
                promoted_goon.name,
                f"Promoted to Godfather after {dead_gf_name}'s death"
            )
        else:
            self.log_hidden("system", f"No Goon available to promote after {dead_gf_name} died.")

    # ----------------------------------------------------------------
    # Phase State Management
    # ----------------------------------------------------------------

    def reset_night_phase_state(self):
        """Clears any leftover actions/results from the previous night phase."""
        self.night_actions_submitted.clear()
        self.night_action_results.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            p = self.get_player(p_name)
            if p:
                p.reset_night_state()

    def reset_day_phase_state(self):
        """Clears day-specific data like accusations, lynch votes, and resets turn tracking."""
        self.votes_for_accusation.clear()
        self.accusation_counts.clear()
        self.player_on_trial = None
        self.votes_for_lynch.clear()
        self.turn_number_in_phase = 0
        self.current_player_turn = None
        for p_name in self.alive_players:
            p = self.get_player(p_name)
            if p:
                p.reset_day_state()

    # ----------------------------------------------------------------
    # Accusation & Voting Threshold
    # ----------------------------------------------------------------

    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):
        """
        If your day logic uses an 'accuse to put on trial' mechanism,
        track each player's accusation and count how many times each target was accused.
        """
        if old_target and old_target in self.accusation_counts:
            self.accusation_counts[old_target] -= 1
            if self.accusation_counts[old_target] <= 0:
                del self.accusation_counts[old_target]

        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1
        self.votes_for_accusation[voter] = new_target

    def get_accusation_threshold(self) -> int:
        """
        Returns how many votes are needed to put someone on trial during discussion.
        By default, we use a majority threshold if not explicitly set.

        e.g. threshold = floor(#alive / 2) + 1
        """
        if "accusation_threshold" in self.game_config:
            return int(self.game_config["accusation_threshold"])
        # Default to simple majority
        return (len(self.alive_players) // 2) + 1

    def accusation_threshold_reached(self, target: str) -> bool:
        """Check if the accused has enough votes to start a trial."""
        needed = self.get_accusation_threshold()
        return self.accusation_counts.get(target, 0) >= needed

    # ----------------------------------------------------------------
    # Night Actions
    # ----------------------------------------------------------------

    def register_night_action(self, actor_name: str, action: Dict[str, Any]):
        """Stores the intended night action from a player. The environment resolves them later."""
        if not self.is_alive(actor_name):
            return
        self.night_actions_submitted[actor_name] = action
        self.log_hidden(actor_name, f"Submitted night action: {action}")

    # ----------------------------------------------------------------
    # Endgame Conditions
    # ----------------------------------------------------------------

    def check_game_end(self) -> bool:
        """
        Checks if the game has ended by evaluating basic Town vs Mafia logic (and optionally expansions).
        If a winner is found, we finalize the game and store final roles.
        """
        if self.game_over:
            return True  # Already ended

        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}
        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}
        # If you want to handle neutrals or special roles, do so here

        winner: Optional[Faction] = None

        # Example: Town wins if no mafia remain
        if not mafia_alive:
            winner = Faction.TOWN
        # Mafia wins if mafia >= town or the config-based rule
        elif len(mafia_alive) >= len(town_alive):
            winner = Faction.MAFIA

        # Add any additional conditions or neutrals logic here

        if winner:
            self.game_over = True
            self.winner = winner
            self.phase = GamePhase.GAME_OVER

            # Final role record
            self.final_player_roles = {p.name: p.role.name for p in self.players}

            self.log_message(
                "system",
                f"Game Over! Winner: {winner.value.upper()}",
                msg_type="system"
            )
            self.log_hidden("system", f"Final Roles: {self.final_player_roles}")
            return True

        return False

    # ----------------------------------------------------------------
    # Logging
    # ----------------------------------------------------------------

    def log_message(self,
                    sender: str,
                    content: str,
                    recipients: Optional[List[str]] = None,
                    msg_type: str = "public"):
        """
        Logs a message to the main game log with a specified type (system, whisper, etc.).
        If 'recipients' is None, it's public for all. Otherwise, only the given recipients can see it.
        """
        if msg_type not in MESSAGE_TYPES:
            msg_type = "public"  # fallback if unknown

        self.messages.append(
            GameMessage(
                msg_type=msg_type,
                sender=sender,
                content=content,
                recipients=recipients,
                phase=self.phase,
                day=self.day_count
            )
        )

    def log_hidden(self, actor: str, info: str):
        """
        Logs details that only certain debugging or hidden channels should see.
        Often used for debugging or system clarifications.
        """
        entry = {
            "actor": actor,
            "info": info,
            "phase": self.phase.name,
            "day": self.day_count,
            "turn": self.turn_number_in_phase
        }
        self.hidden_log.append(entry)

    # ----------------------------------------------------------------
    # Observations
    # ----------------------------------------------------------------

    def get_player_observation(self, player_name: str) -> Dict[str, Any]:
        player = self.get_player(player_name)
        if not player or not player.alive:
            return {
                "game_id": self.game_id,
                "player_name": player_name,
                "alive": False,
                "message": "You are no longer in the game."
            }

        visible_messages = []
        for msg in self.messages:
            is_recip_private = (msg.recipients is not None and player_name in msg.recipients)
            is_sender_private = (msg.sender == player_name and msg.recipients is not None)
            if (msg.recipients is None) or is_recip_private or is_sender_private:
                if msg.msg_type == "whisper":
                    if is_sender_private:
                        visible_messages.append(f"(Whisper to {msg.recipients[0]}) {msg.content}")
                    elif is_recip_private:
                        visible_messages.append(f"(Whisper from {msg.sender}) {msg.content}")
                    else:
                        visible_messages.append(f"{msg.sender}: {msg.content}")
                else:
                    visible_messages.append(f"{msg.sender}: {msg.content}")

        # For mafia players, include the list of alive mafia members
        if player.faction == Faction.MAFIA:
            mafia_members = [p.name for p in self.players if p.alive and p.faction == Faction.MAFIA]
        else:
            mafia_members = []

        obs = {
            "game_id": self.game_id,
            "player_name": player.name,
            "role": player.role.name,
            "role_description": player.role.get_role_description(),
            "faction": player.faction.value,
            "phase": self.phase.name,
            "day": self.day_count,
            "turn": self.turn_number_in_phase,
            "is_current_turn": (self.current_player_turn == player.name),
            "alive_players": sorted(list(self.alive_players)),
            "dead_players": sorted(list(self.dead_players)),
            "messages": visible_messages[-20:],
            "can_speak": player.can_speak(),
            "can_act_tonight": (player.can_act_at_night() and self.phase == GamePhase.NIGHT),
            "player_on_trial": self.player_on_trial,
            "votes_for_accusation": dict(self.votes_for_accusation),
            "accusation_counts": dict(self.accusation_counts),
            "memory": list(player.memory),
            "is_roleblocked": player.is_roleblocked,
            "protected_by": player.protected_by,
            "lynch_votes": {voter: val for voter, val in self.votes_for_lynch.items()},
            "mafia_members": mafia_members
        }
        return obs


    # ----------------------------------------------------------------
    # Optional: Phase Tracking for Debug or Time-Aware Agents
    # ----------------------------------------------------------------

    def record_phase_start(self):
        """
        Record the beginning of a new phase for debugging or analysis.
        You might store timestamps, etc.
        """
        entry = {
            "phase": self.phase.name,
            "day": self.day_count,
            "turn_start": self.turn_number_in_phase,
            "timestamp": None  # set to datetime.now() if you want
        }
        self.phase_history.append(entry)

    def record_phase_end(self):
        """Mark the end of the current phase, e.g. to track how long each phase lasted."""
        if self.phase_history:
            self.phase_history[-1]["turn_end"] = self.turn_number_in_phase
            self.phase_history[-1]["end_timestamp"] = None  # if storing actual time

    # ----------------------------------------------------------------
    # Auditing / Debugging Tools
    # ----------------------------------------------------------------

    def get_game_summary(self) -> Dict[str, Any]:
        """
        Returns a structured summary of the game’s final state or current state.
        Useful for logs, testing, or replay.
        """
        summary = {
            "game_id": self.game_id,
            "phase": self.phase.name,
            "day_count": self.day_count,
            "game_over": self.game_over,
            "winner": self.winner.value if self.winner else None,
            "alive_players": sorted(list(self.alive_players)),
            "dead_players": sorted(list(self.dead_players)),
            "final_player_roles": dict(self.final_player_roles),
            "messages_count": len(self.messages),
            "hidden_log_count": len(self.hidden_log),
            "phase_history": self.phase_history,
        }
        return summary



# === mafia\player.py ===
from typing import Optional, Dict, List, Any
# Import the base Role class and Faction enum
from llm_games.mafia.mechanics.roles import Role
from llm_games.mafia.enums import Faction
from llm_games.mafia.mechanics.messaging import GameMessage
# Import GameState for type hinting only to avoid circular dependency
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from llm_games.mafia.game_state import GameState


class Player:
    def __init__(self, name: str, role: Role):
        self.name: str = name
        self.role: Role = role
        # Faction comes directly from the role object
        self.faction: Faction = self.role.faction
        self.alive: bool = True

        # Night action state
        self.night_target: Optional[str] = None  # Who the player chose to target
        self.is_roleblocked: bool = False
        self.protected_by: Optional[str] = None  # Who protected this player (e.g., Doctor's name)

        # Day state
        self.vote: Optional[str] = None  # For initial vote (e.g., accusation target)
        self.trial_vote: Optional[bool] = None  # For final trial vote (True=Guilty, False=Innocent, None=Abstain)
        self.discussion_tokens: int = 0  # Handled by environment/config
        self.can_speak_today: bool = True  # For effects like Blackmailer

        # Action tracking & Memory
        self.has_accused_today: bool = False
        self.predictions: Dict[str, str] = {}  # target_name -> predicted_role_name
        self.questions_asked_today: Dict[str, int] = {}  # target_name -> count
        self.whispers_sent_today: Dict[str, str] = {}  # target_name -> last_whisper_content

        # Memory for roles like Cop (to store investigation results, etc.)
        self.memory: List[Dict[str, Any]] = []

        # Optional: Track messages said/received for advanced agents
        self.messages_said: List[str] = []
        self.messages_received: List[str] = []

    def reset_for_new_game(self):
        """Resets player state for the start of a new game."""
        self.alive = True
        self.reset_night_state()
        self.reset_day_state()
        self.memory.clear()
        self.predictions.clear()
        # Reset message logs if desired
        self.messages_said.clear()
        self.messages_received.clear()

    def reset_night_state(self):
        """Resets state relevant to the night phase."""
        self.night_target = None
        self.is_roleblocked = False
        self.protected_by = None

    def reset_day_state(self):
        """Resets state relevant to the day phase."""
        self.vote = None
        self.trial_vote = None
        # discussion_tokens might be reset by environment based on config
        self.has_accused_today = False
        self.questions_asked_today.clear()
        self.whispers_sent_today.clear()
        self.can_speak_today = True  # Reset mute/blacklist effects

    def can_act_at_night(self) -> bool:
        """Check if player is alive and their role has a night action."""
        return self.alive and self.role.can_act_at_night()

    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:
        """
        Performs the player's role-specific night action.
        Assumes self.night_target has been set by the agent.
        Returns the action dict or None.
        """
        if not self.can_act_at_night() or self.is_roleblocked:
            if self.is_roleblocked:
                self.log_hidden(game_state, "Tried to act but was roleblocked.")
            return None
        return self.role.night_action(self, game_state, self.night_target)

    def can_speak(self) -> bool:
        """
        Returns whether the player is allowed to speak during the day.
        Can incorporate token budgets or mute effects if needed.
        """
        return self.alive and self.can_speak_today

    # --- Day Actions ---

    def accuse(self, target: str, game_state: 'GameState') -> bool:
        if not self.can_speak():
            self.log_hidden(game_state, f"Attempted to accuse {target} but cannot speak.")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to accuse {target} but they are dead or invalid.")
            return False

        # Allow re‑accusation: simply log the new accusation
        if self.has_accused_today:
            self.log_hidden(game_state, f"Re‑accusing: updating previous accusation to {target}.")
            # Optionally, update vote counts here if needed (via game_state.update_vote_counts)
        else:
            self.has_accused_today = True

        # Instead of appending a raw string, create a GameMessage.
        game_state.messages.append(GameMessage(
            msg_type="public",
            sender=self.name,
            content=f"{self.name} accuses {target}!",
            recipients=None,
            phase=game_state.phase,
            day=game_state.day_count
        ))
        return True


    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState') -> bool:
        """
        Predicts a player's role for internal analysis. Can be used to compare against actual role later.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player:
            return False

        self.predictions[target] = predicted_role_name
        self.log_hidden(game_state, f"Predicted {target} as {predicted_role_name}")
        return True

    def question(self, target: str, question_text: str, game_state: 'GameState') -> bool:
        """
        Sends a question to another player. The environment typically handles the Q&A flow.
        """
        if not self.can_speak():
            self.log_hidden(game_state, f"Attempted to question {target} but cannot speak.")
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to question {target} but they are dead or invalid.")
            return False

        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1
        self.log_hidden(game_state, f"Asked {target}: {question_text}")
        game_state.messages.append(f"{self.name} asks {target}: \"{question_text}\"")
        return True

    def whisper(self, target: str, whisper_text: str, game_state: 'GameState') -> bool:
        """
        Sends a private message to another player. The content is hidden from public logs.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to whisper {target} but they are dead or invalid.")
            return False

        self.whispers_sent_today[target] = whisper_text
        self.log_hidden(game_state, f"Whispered to {target}: {whisper_text}")
        # For simplicity, append a placeholder to public messages (actual content remains hidden)
        game_state.messages.append(f"[WHISPER] {self.name} to {target}")
        return True

    def vote_for(self, target: str, game_state: 'GameState') -> bool:
        """
        Casts or changes a vote during the initial accusation phase.
        """
        if not self.alive:
            return False
        target_player = game_state.get_player(target)
        if not target_player or not target_player.alive:
            self.log_hidden(game_state, f"Attempted to vote for {target} but they are dead or invalid.")
            return False

        old_vote = self.vote
        self.vote = target
        if old_vote and old_vote != target:
            log_msg = f"Changed vote from {old_vote} to {target}"
            public_msg = f"{self.name} changed vote to {target}."
        elif not old_vote:
            log_msg = f"Voted for {target}"
            public_msg = f"{self.name} voted for {target}."
        else:
            return True  # No change needed

        self.log_hidden(game_state, log_msg)
        game_state.messages.append(public_msg)
        game_state.update_vote_counts(self.name, old_vote, target)
        return True

    # --- Voting Phase: Final Trial Vote Support ---
    def cast_trial_vote(self, vote_type: str, game_state: 'GameState') -> bool:
        """
        Casts a final vote during the trial phase.
        vote_type should be one of: 'guilty', 'innocent', 'abstain'.
        This vote is stored separately as trial_vote.
        """
        if not self.alive:
            return False

        vt = vote_type.lower()
        if vt == "guilty":
            self.trial_vote = True
        elif vt == "innocent":
            self.trial_vote = False
        elif vt == "abstain":
            self.trial_vote = None
        else:
            self.log_hidden(game_state, f"Invalid trial vote type: {vote_type}")
            return False

        self.log_hidden(game_state, f"Cast final vote: {vote_type.upper()}")
        game_state.messages.append(f"{self.name} casts a final vote: {vote_type.upper()}.")
        return True

    def abstain_from_vote(self, game_state: 'GameState') -> bool:
        """
        Explicitly abstains from voting in the trial phase.
        """
        if not self.alive:
            return False

        self.trial_vote = None
        self.log_hidden(game_state, "Abstained from voting in the trial phase.")
        game_state.messages.append(f"{self.name} abstains from the final vote.")
        return True

    # --- LLM Action Interface ---
    def get_available_actions(self, game_state: 'GameState') -> List[Dict[str, Any]]:
        """
        Returns a structured list of available actions for this player.
        Each action is represented as a dict with a 'type' and optional 'params'.
        This helps LLM agents know what actions they can take.
        """
        if not self.alive:
            return []

        actions = []

        # Actions available during the day if the player can speak
        if self.can_speak():
            actions.append({"type": "speak", "params": ["content"]})
            actions.append({"type": "accuse", "params": ["target"]})
            actions.append({"type": "question", "params": ["target", "question_text"]})
            actions.append({"type": "predict", "params": ["target", "predicted_role"]})
            actions.append({"type": "whisper", "params": ["target", "whisper_text"]})

        # Actions available during night if the role can act
        if game_state.phase == game_state.phase.__class__.NIGHT and self.can_act_at_night():
            actions.append({"type": "night_action", "params": ["target"]})

        # Voting phase actions (both initial vote and trial vote)
        if game_state.phase.name in {"VOTING", "FINAL_VOTE"}:
            actions.append({"type": "vote", "params": ["target"]})
            actions.append({"type": "abstain", "params": []})
        # Final trial voting is separate from initial accusations
        if game_state.phase.name == "FINAL_VOTE":
            actions.append({"type": "cast_trial_vote", "params": ["vote_type (guilty/innocent/abstain)"]})

        return actions

    # --- Debugging / Serialization ---
    def to_dict(self) -> Dict[str, Any]:
        """
        Serializes the player's state into a dictionary for debugging or logging purposes.
        """
        return {
            "name": self.name,
            "role": self.role.name,
            "faction": self.faction.value,
            "alive": self.alive,
            "vote": self.vote,
            "trial_vote": self.trial_vote,
            "night_target": self.night_target,
            "memory": self.memory,
            "predictions": self.predictions,
            "questions_asked_today": self.questions_asked_today,
            "whispers_sent_today": self.whispers_sent_today,
        }

    def log_hidden(self, game_state: 'GameState', info: str):
        """
        Logs hidden information to the game state's hidden log.
        """
        game_state.log_hidden(self.name, info)

    def __repr__(self):
        status = 'Dead' if not self.alive else 'Alive'
        return f"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>"


# === mafia\play_test.py ===
# play_test.py

from llm_games.mafia.simulation import run_simulation

# Define a configuration with 10 players:
# 7 town players and 3 mafia players.
quick_config = {
    "roles": [
        # Town roles (7 players)
        {"name": "Alice",   "role": "Cop"},
        {"name": "Bob",     "role": "Doctor"},
        {"name": "Charlie", "role": "Villager"},
        {"name": "David",   "role": "Villager"},
        {"name": "Eve",     "role": "Villager"},
        {"name": "Faythe",  "role": "Villager"},
        {"name": "Grace",   "role": "Villager"},
        # Mafia roles (3 players)
        {"name": "Heidi",   "role": "Godfather"},
        {"name": "Ivan",    "role": "Goon"},
        {"name": "Judy",    "role": "Goon"}
    ],
    # Map all agents to the rule-based agent for testing.
    "agent_mapping": {
        "Alice": "rule",
        "Bob": "rule",
        "Charlie": "rule",
        "David": "rule",
        "Eve": "rule",
        "Faythe": "rule",
        "Grace": "rule",
        "Heidi": "rule",
        "Ivan": "rule",
        "Judy": "rule"
    },
    # Set up strategies:
    # For town: always accuse in day discussion and always vote guilty in final vote.
    # For mafia: always perform their night kill action and (optionally) always vote innocent.
    "agent_strategy": {
        # These strategies are read by the RuleAgent in its logic:
        # (The rule agent code checks "always_accuse", "always_vote_guilty", etc.)
        "always_accuse": True,         # All agents will try to accuse when possible.
        "always_vote_guilty": True,     # Town agents vote guilty on trial.
        "always_vote_innocent": True    # Mafia agents vote innocent.
    },
    # Override or add any other configuration options:
    "max_steps": 200,  # Increase max steps if needed to allow game termination.
    # For testing, we force the environment to transition to day immediately:
    #"force_day_on_start": True  
}

# An empty agent config (could be extended later)
agent_config = {}

if __name__ == "__main__":
    print("=== Running a quick Mafia test game with 10 rule agents (7 town, 3 mafia) ===")
    summary = run_simulation(quick_config, agent_config)
    print("\n=== Game Summary ===")
    for key, value in summary.items():
        print(f"{key}: {value}")


# === mafia\rewards.py ===
# mafia/rewards.py
from typing import Dict
from llm_games.mafia.enums import Faction


def assign_endgame_rewards(game_state) -> Dict[str, float]:
    """
    Assign final rewards to agents based on game outcome.
    Town agents get +1 for town win, -1 otherwise. Same for mafia.
    """
    rewards = {}
    for player in game_state.players:
        if player.faction.value == game_state.winner:
            rewards[player.name] = 1.0
        else:
            rewards[player.name] = -1.0
    return rewards


def assign_predict_role_reward(predicted: str, actual: str) -> float:
    return 0.5 if predicted == actual else -0.25


def assign_vote_reward(voter, target, game_state) -> float:
    """
    +1 if town correctly votes out mafia
    -1 if town votes town
    +0.5 if mafia avoids being voted
    """
    if not game_state.is_alive(target):  # Lynched
        if voter.faction == Faction.TOWN:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return 1.0
            else:
                return -1.0
        elif voter.faction == Faction.MAFIA:
            if game_state.get_player(target).faction == Faction.MAFIA:
                return -1.0
            else:
                return 0.5
    return 0.0


def assign_speaking_reward(agent_name: str, token_used: int) -> float:
    """
    Optional: Reward for verbosity, or penalize excess verbosity.
    For now, neutral. Could be tuned.
    """
    return 0.0


def assign_question_reward(asker, target, game_state) -> float:
    """
    +0.2 for engaging others; could scale if target is mafia and asker is town
    """
    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:
        return 0.4
    return 0.2


# === mafia\simulation.py ===
import os
import json
import uuid
from typing import Dict, List, Optional

from tqdm import tqdm

from llm_games.mafia.environment import MafiaEnvironment
from llm_games.mafia.player import Player
from llm_games.mafia.mechanics.roles import get_role_class
from llm_games.mafia.agents.rule_agent import RuleAgent
from llm_games.mafia.agents.llm_agent import LLMAgent
from llm_games.mafia.enums import GamePhase


class TokenTracker:
    def __init__(self):
        self.usage = {}

    def update(self, *args, **kwargs):
        pass

    def to_dict(self) -> Dict[str, Dict[str, int]]:
        return self.usage


def load_config_from_file(path: str) -> Dict:
    print(f"Attempting to load config from {path} (stub).")
    return {}


def create_players_from_config(config: Dict) -> List[Player]:
    players = []
    roles_config = config.get("roles", [])
    if not roles_config:
        roles_setup = [
            ("Player1", "Cop"),
            ("Player2", "Doctor"),
            ("Player3", "Villager"),
            ("Player4", "Godfather"),
            ("Player5", "Goon")
        ]
        print("Warning: Using default 5-player role setup.")
    else:
        roles_setup = [(entry["name"], entry["role"]) for entry in roles_config]

    for name, role_name in roles_setup:
        RoleClass = get_role_class(role_name)
        if not RoleClass:
            raise ValueError(f"Unknown role name '{role_name}' in configuration.")
        role_instance = RoleClass()
        player = Player(name=name, role=role_instance)

        agent_type = config.get("agent_mapping", {}).get(name, "rule").lower()
        if agent_type == "llm":
            model_name = config.get("llm_config", {}).get("model", "gpt-3.5-turbo")
            system_prompt = (
                f"You are {name}, playing Mafia as {role_instance.name}. "
                f"{role_instance.get_role_description()}"
            )

            def dummy_model_backend(prompt: str) -> str:
                return '{"action": "pass"}'

            agent = LLMAgent(
                name=name,
                model_backend=dummy_model_backend,
                tokenizer=None,
                config={"system_prompt": system_prompt, "model": model_name}
            )
            print(f"Assigning LLM-based Agent to {name} ({role_name})")
        else:
            strategy = config.get("agent_strategy", {})
            agent = RuleAgent(name=name, role=role_instance.name, strategy=strategy)
            print(f"Assigning RuleAgent to {name} ({role_name})")

        player.agent = agent
        players.append(player)

    return players


def log_game_summary(game_state) -> Dict:
    return {
        "game_id": game_state.game_id,
        "winner": game_state.winner.value if game_state.winner else None,
        "final_roles": game_state.final_player_roles,
        "day_count": game_state.day_count
    }


def run_simulation(game_config: Dict, agent_config: Dict) -> Dict:
    print(f"\n--- Starting Simulation Game ID: {game_config.get('game_id', 'N/A')} ---")
    combined_config = {**game_config, "agents": agent_config}

    players = create_players_from_config(combined_config)
    env = MafiaEnvironment(players=players, config=combined_config)

    if env.state.phase != GamePhase.NIGHT:
        env.state.phase = GamePhase.NIGHT
    print("Game begins at Night (Day 0). Agents may converse/pass; initial kills occur here if applicable.")

    token_tracker = TokenTracker()
    max_steps = combined_config.get("max_steps", 100)
    step_count = 0

    while not env.state.game_over and step_count < max_steps:
        step_count += 1
        print(f"\n=== [Step {step_count}] Day {env.state.day_count}, Phase: {env.state.phase.name}, Turn: {env.state.turn_number_in_phase} ===")

        current_phase = env.state.phase
        current_player_name = env.get_current_player_name()

        # Final vote is non-turn-based: every alive player votes
        if current_phase == GamePhase.FINAL_VOTE:
            for name in env.state.alive_players:
                player = env.state.get_player(name)
                if not player or not player.alive:
                    continue
                obs = env.get_observation(name)
                player.agent.observe(obs)
                act = player.agent.act()
                print(f"{name} votes: {act}")
                env.process_player_action(name, act)
            env.step_phase()
            continue

        # Other phases
        if not current_player_name:
            print("No current player; environment resolving phase...")
            env.step_phase()
            continue

        player = env.state.get_player(current_player_name)
        if not player or not player.alive:
            print(f"Skipping turn for {current_player_name} (dead or invalid).")
            env.advance_turn()
            continue

        observation = env.get_observation(current_player_name)
        agent = player.agent
        agent.observe(observation)
        agent_action = agent.act()
        print(f"{current_player_name} (role={player.role.name}) chooses: {agent_action}")

        success = env.process_player_action(current_player_name, agent_action)
        if not success:
            print(f"Action failed or was invalid: {agent_action}")
        else:
            env.advance_turn()

    print("\n=== Game Over ===")
    winner_str = env.state.winner.value if env.state.winner else "No winner / Undecided"
    print(f"Winner: {winner_str}")
    print(f"Ended on Day {env.state.day_count}, Phase: {env.state.phase.name}")

    summary = log_game_summary(env.state)
    summary["tokens_used"] = token_tracker.to_dict()
    return summary


def run_multiple_simulations(num_games: int = 5,
                             config_path: str = "config/default_game.json",
                             save_dir: str = "output/sim_results"):
    os.makedirs(save_dir, exist_ok=True)
    base_game_config = load_config_from_file(config_path)
    if not base_game_config:
        base_game_config = {
            "roles": [
                {"name": "Player1", "role": "Cop"},
                {"name": "Player2", "role": "Doctor"},
                {"name": "Player3", "role": "Villager"},
                {"name": "Player4", "role": "Godfather"},
                {"name": "Player5", "role": "Goon"}
            ],
            "agent_mapping": {
                "Player1": "llm",
                "Player4": "llm"
            },
            "llm_config": {"model": "gpt-3.5-turbo"},
            "max_steps": 100
        }
    base_agent_config = {}

    game_results = []
    log_file = os.path.join(save_dir, "games_log.jsonl")

    for _ in tqdm(range(num_games), desc="Simulating Games"):
        game_id = str(uuid.uuid4())
        current_game_config = {**base_game_config, "game_id": game_id}
        try:
            result = run_simulation(current_game_config, base_agent_config)
            result["game_id"] = game_id
            game_results.append(result)
            with open(log_file, "a", encoding="utf-8") as f:
                json.dump(result, f)
                f.write("\n")
        except Exception as e:
            print(f"\n!!!!!! Error during simulation {game_id} !!!!!!")
            print(f"Error: {e}")
            error_info = {"game_id": game_id, "status": "error", "error_message": str(e)}
            with open(log_file, "a", encoding="utf-8") as f:
                json.dump(error_info, f)
                f.write("\n")

    print(f"\n=== Simulations Complete ===\nSaved {len(game_results)} game logs to {log_file}")


def main():
    run_multiple_simulations(num_games=3)


if __name__ == "__main__":
    main()


# === mafia\__init__.py ===


# === mafia\agents\base_agent.py ===
# === mafia/agents/base_agent.py ===

from abc import ABC, abstractmethod
from typing import Dict, Any

class BaseAgent(ABC):
    """
    Base abstract agent class for Mafia.
    Each agent must at least implement:
      - observe(observation): to receive environment state
      - act(): to return an action dictionary
      - reset(): optional, if the agent needs to reset between games
    """
    def __init__(self, name: str):
        self.name = name  # The agent’s name (should match player.name, but not strictly required)

    @abstractmethod
    def observe(self, observation: Dict[str, Any]):
        """
        Called by the environment or simulation to present the agent with
        the current game observation (public messages, roles, day/phase info, etc.).
        The agent should store it internally for decision making.
        """
        pass

    @abstractmethod
    def act(self) -> Dict[str, Any]:
        """
        Called after the agent has observed the environment state and must
        produce an action dictionary, e.g. {"action": "accuse", "target": "Alice"}.
        """
        pass

    def reset(self):
        """
        Optional: Clear internal memory or states if needed between episodes/games.
        """
        pass


# === mafia\agents\llm_agent.py ===
# === mafia/agents/llm_agent.py ===

import json
from typing import Dict, Any, Optional
from llm_games.mafia.agents.base_agent import BaseAgent

class LLMAgent(BaseAgent):
    """
    A base LLM-powered agent that can interact with the environment
    using local or API-based model backends.
    """
    def __init__(self,
                 name: str,
                 model_backend: callable,
                 tokenizer: Optional[callable] = None,
                 config: Optional[Dict[str, Any]] = None):
        """
        :param name: Agent/player name
        :param model_backend: A callable that takes a string prompt and returns a string
        :param tokenizer: Optional tokenizer if needed (e.g. for measuring token usage)
        :param config: Additional config for prompts, temperature, etc.
        """
        super().__init__(name)
        self.model_backend = model_backend
        self.tokenizer = tokenizer
        self.config = config or {}
        self.last_observation: Optional[Dict[str, Any]] = None

    def observe(self, observation: Dict[str, Any]):
        self.last_observation = observation

    def act(self) -> Dict[str, Any]:
        if not self.last_observation:
            return {"action": "pass"}

        prompt = self.build_prompt(self.last_observation)
        raw_output = self.model_backend(prompt)
        action = self.parse_action(raw_output)
        return action

    def build_prompt(self, obs: Dict[str, Any]) -> str:
        """
        Convert the environment observation into a textual prompt for the LLM.
        This method can be customized or replaced with chain-of-thought or JSON-based instructions.
        """
        # A simple example: show the day/phase, who’s alive, last messages, etc.
        # Then instruct the model to pick an action.
        lines = []
        lines.append(f"You are {self.name}, playing the game of Mafia.")
        lines.append(f"Current Phase: {obs.get('phase', 'unknown')}, Day {obs.get('day', 0)}")
        lines.append("Alive Players: " + ", ".join(obs.get("alive_players", [])))
        lines.append("Dead Players: " + ", ".join(obs.get("dead_players", [])))
        lines.append("Recent Messages:")
        for msg in obs.get("messages", []):
            lines.append(f"  - {msg}")
        lines.append("Based on the above, choose your next action in JSON format.")
        lines.append('Example: {"action": "accuse", "target": "Bob"}')

        return "\n".join(lines)

    def parse_action(self, response: str) -> Dict[str, Any]:
        """
        Try to parse the LLM’s output as JSON. If parsing fails or fields are missing,
        default to {"action": "pass"}.
        """
        try:
            data = json.loads(response)
            # Validate minimal structure
            if "action" not in data:
                return {"action": "pass"}
            return data
        except json.JSONDecodeError:
            return {"action": "pass"}


# === mafia\agents\rule_agent.py ===
import random
from typing import Dict, Any, Optional
from llm_games.mafia.agents.base_agent import BaseAgent

class RuleAgent(BaseAgent):
    """
    A deterministic/strategy-based agent for testing.
    Useful for verifying environment correctness before using complex LLM behavior.
    """
    def __init__(self,
                 name: str,
                 role: Optional[str] = None,
                 strategy: Optional[Dict[str, Any]] = None,
                 seed: Optional[int] = None):
        super().__init__(name)
        self.player_role = (role or "").lower()
        self.strategy = strategy or {}
        self.rng = random.Random(seed)
        self.last_observation: Optional[Dict[str, Any]] = None
        self.max_discussion_turns = self.strategy.get("max_discussion_turns", 2)

    def observe(self, observation: Dict[str, Any]):
        self.last_observation = observation

    def act(self) -> Dict[str, Any]:
        if not self.last_observation:
            return {"action": "pass"}
        phase = self.last_observation.get("phase", "").lower()
        if phase == "night":
            return self._night_action()
        elif phase == "day_discussion":
            return self._day_discussion_action()
        elif phase == "defense":
            return self._defense_action()
        elif phase == "final_vote":
            return self._final_vote_action()
        else:
            return self._fallback_action()

    # ---------- Private Phase Logic ----------

    def _night_action(self) -> Dict[str, Any]:
        
        alive = self.last_observation.get("alive_players", [])
        if not alive:
            return {"action": "pass"}

        if self.player_role == "cop":
            target = self._choose_target(alive)
            return {"action": "investigate", "target": target}
        elif self.player_role == "doctor":
            return {"action": "protect", "target": self.name}
        elif self.player_role == "godfather":
            # Use mafia_members from observation (should be provided to mafia agents)
            mafia_members = self.last_observation.get("mafia_members", [])
            target_candidates = [p for p in alive if p not in mafia_members and p != self.name]
            if not target_candidates:
                return {"action": "pass"}
            target = self._choose_target(target_candidates)
            return {"action": "kill", "target": target}
        return {"action": "pass"}

    def _day_discussion_action(self) -> Dict[str, Any]:
        # Do not accuse if someone is already on trial
        if self.last_observation.get("player_on_trial"):
            return {"action": "pass"}

        # With some probability, issue an accusation (if it's our turn)
        if self.last_observation.get("is_current_turn", False) and self.rng.random() < 0.5:
            alive = self.last_observation.get("alive_players", [])
            if alive:
                target = self._choose_target(alive)
                return {"action": "accuse", "target": target}

        # Otherwise, if it's our turn, speak
        if self.last_observation.get("is_current_turn", False):
            return {"action": "speak", "content": f"{self.name} says something insightful."}

        return {"action": "pass"}

    def _defense_action(self) -> Dict[str, Any]:
        if self.last_observation.get("player_on_trial") == self.name:
            return {"action": "speak", "content": f"{self.name} defends themselves."}
        return {"action": "pass"}

    def _final_vote_action(self) -> Dict[str, Any]:
        if self.strategy.get("always_vote_guilty"):
            return {"action": "vote", "vote_type": "final_guilty"}
        elif self.strategy.get("always_vote_innocent"):
            return {"action": "vote", "vote_type": "final_innocent"}
        choice = self.rng.choice(["final_guilty", "final_innocent", "abstain"])
        return {"action": "vote", "vote_type": choice}

    def _fallback_action(self) -> Dict[str, Any]:
        return {"action": "pass"}

    # ---------- Helpers ----------
    def _choose_target(self, candidates: list) -> str:
        if not candidates:
            return self.name
        return self.rng.choice(candidates)

    @property
    def _alive_players(self) -> list:
        obs_alive = self.last_observation.get("alive_players", [])
        return [p for p in obs_alive if p != self.name]


# === mafia\agents\__init__.py ===


# === mafia\evaluation\analysis.py ===
# mafia/evaluation/analysis.py
from typing import List, Dict

def log_game_summary(game_state) -> Dict:
    """
    Logs key metrics and summary data from a completed game.
    Returns a structured dictionary with faction, winners, predictions, etc.
    """
    summary = {
        "game_id": game_state.game_id,
        "winner": game_state.winner,
        "day_count": game_state.day_count,
        "players": [],
        "predictions": [],
        "votes": [],
        "whispers": [],
        "questions": [],
        "accusations": [],
    }

    for player in game_state.players:
        summary["players"].append({
            "name": player.name,
            "role": player.role.name,
            "faction": player.faction.value,
            "alive": player.alive,
        })

        for target, role in player.predicted_roles.items():
            summary["predictions"].append({
                "predictor": player.name,
                "target": target,
                "predicted_role": role
            })

        if player.vote:
            summary["votes"].append({
                "voter": player.name,
                "voted_for": player.vote
            })

        for target, whisper_text in player.whispers_sent.items():
            summary["whispers"].append({
                "from": player.name,
                "to": target,
                "content": whisper_text
            })

        for target, count in player.questions_asked.items():
            summary["questions"].append({
                "asker": player.name,
                "target": target,
                "times": count
            })

        if player.has_accused:
            summary["accusations"].append(player.name)

    return summary


# === mafia\evaluation\metrics.py ===
# mafia/evaluation/metrics.py
from collections import defaultdict
from typing import Dict, List


def compute_win_rate(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the win rate for each faction based on finished games.
    """
    results = defaultdict(int)
    for game in games:
        results[game["winner"]] += 1
    total = sum(results.values())
    return {faction: wins / total for faction, wins in results.items()}


def compute_average_tokens(games: List[Dict]) -> Dict[str, float]:
    """
    Returns the average number of tokens used by each agent across games.
    """
    token_totals = defaultdict(int)
    token_counts = defaultdict(int)
    for game in games:
        for agent, tokens in game["tokens"].items():
            token_totals[agent] += tokens.get("input", 0) + tokens.get("output", 0)
            token_counts[agent] += 1
    return {
        agent: token_totals[agent] / token_counts[agent]
        for agent in token_totals
    }


def compute_average_role_accuracy(games: List[Dict]) -> float:
    """
    Computes how often role predictions were correct.
    """
    correct = 0
    total = 0
    for game in games:
        for entry in game["hidden_log"]:
            if "Predicted" in entry["info"]:
                # Format: "Predicted X as Y"
                parts = entry["info"].split()
                predicted_role = parts[-1]
                target = parts[1]
                actual_role = None
                for player in game["players"]:
                    if player["name"] == target:
                        actual_role = player["role"]
                        break
                if actual_role:
                    total += 1
                    if predicted_role == actual_role:
                        correct += 1
    return correct / total if total else 0.0


# === mafia\mechanics\messaging.py ===
# mafia/mechanics/messaging.py
from typing import Dict, List, Optional, Tuple, Any

from dataclasses import dataclass, field
from llm_games.mafia.enums import GamePhase

@dataclass
class GameMessage:
    """Structured record of a single game message."""
    msg_type: str       # e.g. 'system', 'public', 'whisper', ...
    sender: str         # 'system' or player_name
    content: str
    recipients: Optional[List[str]] = None  # None means public
    phase: GamePhase = GamePhase.NIGHT
    day: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a serializable dict (helpful if you store logs as JSON)."""
        return {
            "type": self.msg_type,
            "sender": self.sender,
            "content": self.content,
            "recipients": self.recipients,
            "phase": self.phase.name,
            "day": self.day
        }
class Message:
    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):
        self.sender = sender              # Who sent the message
        self.content = content            # What was said (raw text or structured)
        self.target = target              # If whispering or targeting another player
        self.private = private            # Whisper if True, public otherwise

    def render(self) -> str:
        if self.private:
            return f"[WHISPER] {self.sender} → {self.target}: {self.content}"
        elif self.target:
            return f"{self.sender} → {self.target}: {self.content}"
        return f"{self.sender}: {self.content}"


class MessagingSystem:
    def __init__(self):
        self.history: List[Message] = []

    def send_public(self, sender: str, content: str):
        msg = Message(sender=sender, content=content)
        self.history.append(msg)
        return msg

    def send_private(self, sender: str, recipient: str, content: str):
        msg = Message(sender=sender, content=content, target=recipient, private=True)
        self.history.append(msg)
        return msg

    def get_visible_messages(self, player_name: str, phase: GamePhase) -> List[str]:
        visible = []
        for msg in self.history:
            if not msg.private:
                visible.append(msg.render())
            elif msg.private and (msg.sender == player_name or msg.target == player_name):
                visible.append(msg.render())
        return visible

    def get_all_messages(self) -> List[str]:
        return [msg.render() for msg in self.history]

    def clear(self):
        self.history.clear()

    def get_log_data(self) -> List[Dict]:
        return [{
            "sender": msg.sender,
            "target": msg.target,
            "private": msg.private,
            "content": msg.content
        } for msg in self.history]


# === mafia\mechanics\roles.py ===
# === mafia/mechanics/roles.py ===

from abc import ABC, abstractmethod
from llm_games.mafia.enums import Faction
from typing import Optional, TYPE_CHECKING, Dict, Any, List

# Avoid circular import for type hinting
if TYPE_CHECKING:
    from llm_games.mafia.player import Player
    from llm_games.mafia.game_state import GameState

class Role(ABC):
    def __init__(self, name: str, faction: Faction):
        self.name = name
        self.faction = faction
        # For now, we use faction as the alignment. Override if needed.
        self.alignment = faction

    @abstractmethod
    def get_role_description(self) -> str:
        """Return a string describing the role's abilities and goals."""
        pass

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Executes the role's night action.
        Target selection logic is handled by the agent/player.
        Returns a dict representing the action taken, or None.
        """
        return None  # Default: No night action

    def can_act_at_night(self) -> bool:
        """Checks if the role has a meaningful night action."""
        return self.__class__.night_action != Role.night_action

    def get_available_targets(self, player: 'Player', game_state: 'GameState') -> List[str]:
        """
        Returns a list of valid target player names.
        Default: any alive player except self.
        Override to add additional filters.
        """
        return [p.name for p in game_state.players if p.alive and p.name != player.name]

    def win_condition_met(self, player: 'Player', game_state: 'GameState') -> Optional[bool]:
        """
        Stub for roles with unique win conditions.
        Returns True if the player's win condition is met,
        False if failed, or None if undecided.
        """
        return None  # Default: rely on faction win

    def get_llm_schema(self) -> Dict[str, Any]:
        """
        Returns a dictionary with structured information about the role,
        useful for prompting LLM-based agents.
        """
        return {
            "name": self.name,
            "faction": self.faction.value,
            "alignment": self.alignment.value,
            "can_act_at_night": str(self.can_act_at_night()),
            "description": self.get_role_description()
        }

    def __repr__(self):
        return f"<{self.faction.value}:{self.name}>"

# ------------------- TOWN ROLES -------------------

class Villager(Role):
    def __init__(self):
        super().__init__("Villager", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are a Villager. You have no special abilities. Find and lynch the Mafia."

    # Inherits default night_action (None)

class Cop(Role):
    def __init__(self):
        super().__init__("Cop", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia)."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent self-investigation
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot investigate yourself.")
            return None

        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            # Handle Godfather detection: if target is a Godfather and game config dictates, appear as Town
            if isinstance(target_player.role, Godfather) and not game_state.game_config.get("godfather_detectable", False):
                result_faction = Faction.TOWN
            else:
                result_faction = target_player.role.faction

            result_info = f"Investigated {target_player.name}: Result {result_faction.value}"
            player.log_hidden(game_state, f"\uD83D\uDD0E {result_info}")
            player.memory.append({
                "type": "investigation_result",
                "day": game_state.day_count,
                "target": target_player.name,
                "result": result_faction.value
            })
            return {"type": "investigate", "target": target_player.name, "result": result_faction.value}
        elif target_name:
            player.log_hidden(game_state, f"\uD83D\uDD0E Tried to investigate {target_name}, but they were not found or dead.")
        return None

class Doctor(Role):
    def __init__(self):
        super().__init__("Doctor", Faction.TOWN)

    def get_role_description(self) -> str:
        return "You are the Doctor. Each night, you can choose one player to protect from death."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Optionally, disallow self-protection based on configuration.
        if target_name == player.name and not game_state.game_config.get("doctor_can_self_heal", True):
            player.log_hidden(game_state, "You cannot protect yourself tonight.")
            return None

        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83E\uDE78 Protected {target_player.name}")
            return {"type": "protect", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83E\uDE78 Tried to protect {target_name}, but they were not found or dead.")
        return None

# ------------------- MAFIA ROLES -------------------

class Goon(Role):
    def __init__(self):
        super().__init__("Goon", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day."

    # Inherits default night_action (None)

class Godfather(Role):
    def __init__(self):
        super().__init__("Godfather", Faction.MAFIA)
        self.appears_as = Faction.TOWN  # To cops, unless detectable

    def get_role_description(self) -> str:
        return ("You are the Godfather. You appear as Town to the Cop. "
                "Each night, choose a target for the Mafia to kill. "
                "If you die, a Goon will be promoted.")

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent self-targeting or targeting fellow Mafia
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot target yourself.")
            return None
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player:
            if target_player.faction == Faction.MAFIA:
                player.log_hidden(game_state, "You cannot order a kill on a fellow Mafia member.")
                return None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"\uD83D\uDD2A Ordered kill on {target_player.name}")
            return {"type": "kill", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"\uD83D\uDD2A Tried to order kill on {target_name}, but they were not found or dead.")
        return None

# ------------------- NEW ROLES -------------------

class RoleBlocker(Role):
    def __init__(self):
        super().__init__("RoleBlocker", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are the RoleBlocker. Each night, you can block another player's action."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        # Prevent blocking self
        if target_name == player.name:
            player.log_hidden(game_state, "You cannot roleblock yourself.")
            return None
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            player.log_hidden(game_state, f"Blocked {target_player.name}'s action")
            return {"type": "roleblock", "target": target_player.name}
        elif target_name:
            player.log_hidden(game_state, f"Tried to block {target_name}, but they were not found or dead.")
        return None

class Consigliere(Role):
    def __init__(self):
        super().__init__("Consigliere", Faction.MAFIA)

    def get_role_description(self) -> str:
        return "You are the Consigliere. Each night, you may learn the exact role of one player."

    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
        target_player = game_state.get_player(target_name) if target_name else None
        if target_player and target_player.alive:
            role_name = target_player.role.name
            player.log_hidden(game_state, f"Investigated {target_player.name}: Role = {role_name}")
            player.memory.append({
                "type": "role_peek",
                "day": game_state.day_count,
                "target": target_player.name,
                "role": role_name
            })
            return {"type": "consigliere_investigate", "target": target_player.name, "result": role_name}
        elif target_name:
            player.log_hidden(game_state, f"Tried to investigate {target_name}, but they were not found or dead.")
        return None

# ------------------- OPTIONAL HELPER METHODS -------------------

# These can be overridden by individual roles if needed.
# For example, a role may override win_condition_met for unique victory conditions.
def default_win_condition(player: 'Player', game_state: 'GameState') -> Optional[bool]:
    return None

# ------------------- ROLE REGISTRY -------------------

ROLE_CLASS_MAP = {
    "villager": Villager,
    "cop": Cop,
    "doctor": Doctor,
    "goon": Goon,
    "godfather": Godfather,
    "roleblocker": RoleBlocker,
    "consigliere": Consigliere,
    # Add additional roles here...
}

def get_role_class(role_name: str) -> Optional[type[Role]]:
    return ROLE_CLASS_MAP.get(role_name.lower())


# === mafia\mechanics\__init__.py ===


# === mafia\prompts\mafia_template.py ===
def format_prompt(name: str, obs: dict) -> str:
    # Format as readable context for the agent
    lines = [f"Day {obs['day']} | Phase: {obs['phase']}"]
    lines.append("Alive: " + ", ".join(obs["alive"]))
    lines.append("Dead: " + ", ".join(obs["dead"]))
    lines.append("Messages:")
    lines.extend(obs["messages"])
    lines.append("What do you do next? Choose one action:")
    return "\n".join(lines)

def parse_response(response: str) -> dict:
    """
    Expects LLM to return something like:
    <action> accuse </action> <target> Player3 </target>
    """
    import re
    act = re.search(r"<action>(.*?)</action>", response)
    tgt = re.search(r"<target>(.*?)</target>", response)
    return {
        "action": act.group(1).strip().lower() if act else "pass",
        "target": tgt.group(1).strip() if tgt else None
    }


# === mafia\utils\token_cost.py ===


