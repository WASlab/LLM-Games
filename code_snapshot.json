{
  "config.py": "",
  "enums.py": "from enum import Enum\n\nclass Faction(Enum):\n    TOWN = \"town\"\n    MAFIA = \"mafia\"\n    NEUTRAL = \"neutral\" # Reserved for extensibility\n\nclass GamePhase(Enum):\n    NIGHT = \"night\"\n    DAY_DISCUSSION = \"day_discussion\"\n    VOTING = \"voting\"\n    DEFENSE = \"defense\" # Optional phase if accusation needs defense\n    FINAL_VOTE = \"final_vote\" # Optional phase for final lynch decision\n    GAME_OVER = \"game_over\"\n\nclass VoteType(Enum):\n    ACCUSATION = \"accusation\" # Initial vote during day\n    FINAL_GUILTY = \"final_guilty\" # Vote during final lynch\n    FINAL_INNOCENT = \"final_innocent\" # Vote during final lynch\n    SKIP = \"skip\" # Abstain from voting",
  "environment.py": "# === mafia/environment.py ===\n\nimport random\nfrom collections import deque\nfrom typing import Dict, List, Optional, Any, Tuple, Set\n\n# Core project imports (ensure they match your directory structure)\nfrom mafia.game_state import GameState\nfrom mafia.player import Player\nfrom mafia.enums import GamePhase, Faction, VoteType\nfrom mafia.mechanics.roles import Cop, Godfather, Roleblocker,Doctor\n# If you have a RoleBlocker or Blackmailer, import them similarly:\n# from mafia.mechanics.roles import RoleBlocker, Blackmailer\n\n# from mafia.rewards import compute_rewards  # If/when using a reward system\n# from mafia.utils.token_cost import track_tokens  # If/when tracking token budgets\n\n# Dummy placeholders if those modules are not yet implemented:\ndef compute_rewards(state) -> Dict[str, float]:\n    \"\"\"Placeholder if you have not implemented rewards yet.\"\"\"\n    return {}\n\nclass TokenTracker:\n    \"\"\"Placeholder if you want to track tokens or verbosity budgets.\"\"\"\n    def __init__(self):\n        self.usage = {}\n\n    def update(self, *args, **kwargs):\n        pass\n\n    def to_dict(self):\n        return dict(self.usage)\n\n\nclass MafiaEnvironment:\n    \"\"\"\n    Manages the overall flow, phases, action resolution, and messaging for a Mafia game.\n\n    Key Features:\n      - Night action resolution with roleblock \u2192 protect \u2192 kill \u2192 investigate ordering\n      - Day discussion with round-robin speaking, optional questioning, accusations\n      - Voting phases, including defense and final vote\n      - Tie votes or lack of majority \u2192 no lynch \u2192 transition to Night\n      - Basic checks for valid night targets (e.g., Godfather cannot target a fellow Mafia)\n    \"\"\"\n\n    def __init__(self, players: List[Player], config: Dict[str, Any]):\n        \"\"\"\n        :param players: Pre-created list of Player objects with assigned roles.\n        :param config:  Dictionary of configuration options (e.g. 'lynch_defense_enabled', etc.).\n        \"\"\"\n        self.config = config\n\n        # Initialize the game state\n        self.state = GameState(players=players, game_config=config)\n        self.state.initialize()\n\n        # Token/budget tracking if desired\n        self.token_tracker = TokenTracker()\n\n        # Various environment configs\n        self.lynch_defense_enabled: bool = self.config.get(\"lynch_defense_enabled\", True)\n        self.cop_speaks_first: bool = self.config.get(\"cop_speaks_first\", False)\n\n        # Day phase tracking\n        self._speaker_queue: deque[str] = deque()\n        # Queue of (questioner, questioned) to handle immediate back-and-forth:\n        self._question_queue: deque[Tuple[str, str]] = deque()\n        self._turns_taken_this_round: Set[str] = set()\n        self._consecutive_passes: int = 0\n\n    # ----------------------------------------------------------------\n    # Public Methods for Simulation Loop\n    # ----------------------------------------------------------------\n\n    def step_phase(self) -> bool:\n        \"\"\"\n        Advances the game by one phase (e.g., from Night \u2192 Day or running the defense \u2192 final vote).\n        Returns True if the game has ended, False otherwise.\n        \"\"\"\n        if self.state.game_over:\n            return True\n\n        current_phase = self.state.phase\n\n        if current_phase == GamePhase.NIGHT:\n            self._resolve_night()\n            self._transition_to_day()\n\n        elif current_phase == GamePhase.DAY_DISCUSSION:\n            # The discussion-phase turns are advanced by process_player_action or advance_turn.\n            # step_phase can check if we need to end discussion automatically.\n            if self._check_discussion_end():\n                self._transition_to_voting()\n\n        elif current_phase == GamePhase.VOTING:\n            # In a simpler design, voting might be resolved automatically or by some timer logic.\n            # Often, you transition out of VOTING once everyone has voted, but that can be\n            # handled in process_player_action or an external runner. So we just do a no-op here.\n            pass\n\n        elif current_phase == GamePhase.DEFENSE:\n            # Let the accused speak; then move on to final vote.\n            self._run_defense()\n            self._transition_to_final_vote()\n\n        elif current_phase == GamePhase.FINAL_VOTE:\n            # Once final votes are in (or forced), resolve lynch.\n            self._resolve_lynch()\n            self._transition_to_night()\n\n        return self.state.check_game_end()\n\n    def get_current_player_name(self) -> Optional[str]:\n        \"\"\"Returns the name of the player whose turn it is to act (during DAY_DISCUSSION).\"\"\"\n        return self.state.current_player_turn\n\n    def get_observation(self, player_name: str) -> Dict[str, Any]:\n        \"\"\"Returns an observation dict for the specified player (public messages, private info, etc.).\"\"\"\n        return self.state.get_player_observation(player_name)\n\n    def process_player_action(self, player_name: str, action: Dict[str, Any]) -> bool:\n        \"\"\"\n        The main method for handling actions from a player's agent.\n        Returns True if the action was processed successfully, False if invalid.\n        \"\"\"\n        player = self.state.get_player(player_name)\n        if not player or not player.alive:\n            self.state.log_hidden(player_name, f\"Ignored action {action}; player is dead or invalid.\")\n            return False\n\n        # Check if it is actually this player's turn (in discussion) or if we allow free actions\n        if self.state.phase == GamePhase.DAY_DISCUSSION:\n            if self.state.current_player_turn != player_name:\n                self.state.log_hidden(\n                    player_name, \n                    f\"Attempted action {action} but it is not {player_name}'s turn.\"\n                )\n                return False\n\n        # Log the attempt\n        self.state.log_hidden(player_name, f\"Received action: {action}\")\n        action_type = action.get(\"action\")\n        target = action.get(\"target\")\n        content = action.get(\"content\")\n        self.token_tracker.update(player_name, action_type, content)\n\n        success = False\n\n        # ----------------------------------------------------------------\n        # NIGHT ACTIONS\n        # ----------------------------------------------------------------\n        if self.state.phase == GamePhase.NIGHT:\n            if player.can_act_at_night():\n                # The player's role logic typically sets a night_action dict or returns None if invalid.\n                player.night_target = target\n                intended_action = player.perform_night_action(self.state)\n\n                # Optionally, we enforce extra checks (e.g., Godfather cannot target mafia).\n                intended_action = self._validate_night_action(player, intended_action)\n\n                if intended_action:\n                    self.state.register_night_action(player_name, intended_action)\n                success = True  # We treat it as a valid \"turn\" even if no action is performed.\n            else:\n                self.state.log_hidden(player_name, \"Tried to act at night but this role has no night action.\")\n                success = True\n\n        # ----------------------------------------------------------------\n        # DAY ACTIONS - Discussion Phase\n        # ----------------------------------------------------------------\n        elif self.state.phase == GamePhase.DAY_DISCUSSION:\n            success = self._process_day_discussion_action(player, action_type, target, content)\n\n            # If the action was valid, move to next speaker (unless an immediate phase transition happens).\n            if success and not self.state.player_on_trial:\n                # If an accusation occurs, we transition to voting within the same turn, so skip advance_turn\n                self.advance_turn()\n\n        # ----------------------------------------------------------------\n        # VOTING PHASE\n        # ----------------------------------------------------------------\n        elif self.state.phase == GamePhase.VOTING:\n            success = self._process_voting_phase_action(player, action_type, target, content)\n\n        # ----------------------------------------------------------------\n        # DEFENSE PHASE\n        # ----------------------------------------------------------------\n        elif self.state.phase == GamePhase.DEFENSE:\n            if player_name == self.state.player_on_trial:\n                # The accused can make a statement (content) or pass\n                if content:\n                    self.state.log_message(player_name, f\"(Defense) {content}\")\n                else:\n                    self.state.log_message(player_name, \"(Defense) [No statement provided]\")\n                success = True\n            else:\n                self.state.log_hidden(player_name, f\"Not on trial; ignoring defense action.\")\n                success = False\n\n        # ----------------------------------------------------------------\n        # FINAL VOTE PHASE\n        # ----------------------------------------------------------------\n        elif self.state.phase == GamePhase.FINAL_VOTE:\n            success = self._process_final_vote_action(player, action)\n\n        # ----------------------------------------------------------------\n        # If action was valid but the day discussion is still ongoing, \n        # we might want to continue or see if we transition to next phase.\n        # ----------------------------------------------------------------\n        if not success:\n            self.state.log_hidden(player_name, f\"Action {action} could not be processed.\")\n        return success\n\n    def advance_turn(self):\n        \"\"\"\n        Advances to the next person's turn in the DAY_DISCUSSION phase,\n        respecting any question queue ordering (the questioned player, then questioner\u2019s response).\n        \"\"\"\n        if self.state.phase != GamePhase.DAY_DISCUSSION:\n            self.state.current_player_turn = None\n            return\n\n        # If we have a question queue, that takes priority\n        if self._question_queue:\n            questioner, questioned = self._question_queue.popleft()\n            # The questioned player goes first\n            self.state.current_player_turn = questioned\n            self.state.turn_context = {\"answering_question_from\": questioner}\n\n            # Then queue the questioner as next (a short follow-up), unless questioner == questioned\n            if questioner != questioned:\n                self._question_queue.appendleft((questioner, questioner))\n            return\n\n        # If the main speaker queue is empty, check discussion end or start a new round\n        if not self._speaker_queue or self._consecutive_passes >= len(self.state.alive_players):\n            self._transition_to_voting()\n            return\n\n        next_speaker = self._speaker_queue.popleft()\n        self.state.current_player_turn = next_speaker\n        self.state.turn_number_in_phase += 1\n        self.state.turn_context = None\n\n    # ----------------------------------------------------------------\n    # Internal / Private Helpers\n    # ----------------------------------------------------------------\n\n    def _resolve_night(self):\n        \"\"\"Resolves all players' night actions in the correct order (roleblock, protect, kill, investigate, etc.).\"\"\"\n        self.state.log_message(\"system\", \"Night ends. Resolving all night actions...\")\n        self.state.night_action_results.clear()\n        submitted_actions = self.state.night_actions_submitted\n\n        # 1. Roleblocks\n        roleblocked_players: Set[str] = set()\n        # 2. Blackmail\n        blackmailed_players: Set[str] = set()\n\n        for actor, action_dict in submitted_actions.items():\n            if not self.state.is_alive(actor):\n                continue  # Actor died mid-night somehow\n\n            # e.g. if action_dict[\"type\"] == \"roleblock\": ...\n            # Example placeholder:\n            if action_dict.get(\"type\") == \"roleblock\":\n                target = action_dict.get(\"target\")\n                if target and self.state.is_alive(target):\n                    roleblocked_players.add(target)\n                    self.state.log_hidden(\n                        actor, f\"Roleblocked {target} for the night.\"\n                    )\n            elif action_dict.get(\"type\") == \"blackmail\":\n                target = action_dict.get(\"target\")\n                if target and self.state.is_alive(target):\n                    blackmailed_players.add(target)\n                    self.state.log_hidden(actor, f\"Blackmailed {target} for the day.\")\n\n        # Mark roleblocked players\n        for blocked in roleblocked_players:\n            p = self.state.get_player(blocked)\n            if p:\n                p.is_roleblocked = True\n\n        # Mark blackmailed players so they can't speak tomorrow\n        for bm in blackmailed_players:\n            p = self.state.get_player(bm)\n            if p:\n                p.can_speak_today = False\n\n        # 3. Protections\n        protected: Dict[str, str] = {}\n        for actor, action_dict in submitted_actions.items():\n            if actor in roleblocked_players:\n                continue\n            if not self.state.is_alive(actor):\n                continue\n            if action_dict.get(\"type\") == \"protect\":\n                target = action_dict.get(\"target\")\n                if target and self.state.is_alive(target):\n                    # If multiple doctors protect the same target, the first or last might \"win.\"\n                    # Here we allow the first to stand; you can choose whichever convention you like.\n                    if target not in protected:\n                        protected[target] = actor\n                        # For debug or future logic\n                        target_p = self.state.get_player(target)\n                        if target_p:\n                            target_p.protected_by = actor\n                        self.state.log_hidden(\n                            actor, f\"Protected {target} this night.\"\n                        )\n\n        # 4. Kills\n        kills_attempted: List[Tuple[str, str]] = []\n        for actor, action_dict in submitted_actions.items():\n            if actor in roleblocked_players:\n                continue\n            if not self.state.is_alive(actor):\n                continue\n            if action_dict.get(\"type\") == \"kill\":\n                target = action_dict.get(\"target\")\n                if target and self.state.is_alive(target):\n                    kills_attempted.append((actor, target))\n                    self.state.log_hidden(actor, f\"Attempting kill on {target}.\")\n\n        successful_kills: Set[str] = set()\n        for (killer, target) in kills_attempted:\n            if target not in protected:\n                successful_kills.add(target)\n                self.state.log_hidden(killer, f\"Kill on {target} succeeded.\")\n            else:\n                doc = protected[target]\n                self.state.log_hidden(killer, f\"Kill on {target} failed (protected by {doc}).\")\n                self.state.log_hidden(doc, f\"You successfully protected {target} from a kill.\")\n\n        # Apply kills\n        deaths = []\n        for victim in successful_kills:\n            if self.state.is_alive(victim):\n                self.state.kill_player(victim, reason=\"killed during night\")\n                deaths.append(victim)\n\n        # 5. Investigations\n        for actor, action_dict in submitted_actions.items():\n            if actor in roleblocked_players:\n                continue\n            if not self.state.is_alive(actor):\n                continue\n            if action_dict.get(\"type\") == \"investigate\":\n                target = action_dict.get(\"target\")\n                result = action_dict.get(\"result\")\n                # Cop/Consigliere logic typically updates the player's memory. \n                # We also store it in environment logs.\n                self.state.log_hidden(\n                    actor, f\"Investigation result on {target}: {result}\"\n                )\n                self.state.night_action_results[actor] = action_dict\n\n        if deaths:\n            # Alphabetical or by order of kills\n            self.state.log_message(\n                \"system\",\n                f\"The sun rises. The following were found dead: {', '.join(sorted(deaths))}.\"\n            )\n        else:\n            self.state.log_message(\"system\", \"The sun rises. Miraculously, nobody died last night!\")\n\n    def _transition_to_day(self):\n        \"\"\"Moves the game into DAY_DISCUSSION, resetting relevant flags and re-initializing speaker queues.\"\"\"\n        self.state.log_hidden(\"system\", \"Transitioning to Day phase.\")\n        # Clear roleblock statuses, etc.\n        for p in self.state.players:\n            p.reset_night_state()\n\n        # Switch to day\n        self.state.phase = GamePhase.DAY_DISCUSSION\n        self.state.day_count += 1\n        self.state.reset_day_phase_state()\n\n        # Start a fresh speaking queue\n        self._start_new_discussion_round()\n        self.state.log_message(\"system\", f\"Day {self.state.day_count} begins. Discuss and vote!\")\n\n    def _start_new_discussion_round(self):\n        \"\"\"Initializes or re-initializes the round-robin talk queue for the day discussion phase.\"\"\"\n        self._speaker_queue.clear()\n        self._question_queue.clear()\n        self._turns_taken_this_round.clear()\n        self._consecutive_passes = 0\n        self.state.turn_context = None\n        self.state.turn_number_in_phase = 0\n\n        alive_names = sorted(self.state.alive_players)\n        # If config demands Cop speak first\n        if self.cop_speaks_first:\n            for name in alive_names:\n                pl = self.state.get_player(name)\n                if pl and isinstance(pl.role, Cop):\n                    alive_names.remove(name)\n                    alive_names.insert(0, name)\n                    self.state.log_hidden(\"system\", f\"Cop ({name}) will speak first today.\")\n                    break\n\n        self._speaker_queue.extend(alive_names)\n        # Force the environment to choose the first speaker\n        self.advance_turn()\n\n    def _check_discussion_end(self) -> bool:\n        \"\"\"\n        Checks if we must end DAY_DISCUSSION:\n          - Everyone passes in a row\n          - An accusation is made\n          - The day discussion round is otherwise complete (all spoke, queue empty)\n          - (Optional) A max turn or time-based limit\n        \"\"\"\n        # 1. Everyone passes consecutively\n        if self._consecutive_passes >= len(self.state.alive_players):\n            self.state.log_hidden(\"system\", \"All players have consecutively passed. Discussion ending.\")\n            return True\n\n        # 2. If the queue is empty and every living player has spoken at least once\n        if (not self._speaker_queue and not self._question_queue \n                and len(self._turns_taken_this_round) >= len(self.state.alive_players)):\n            self.state.log_hidden(\"system\", \"Discussion round ended: queue empty, everyone spoke.\")\n            return True\n\n        # 3. If someone is on trial already (accusation triggered)\n        if self.state.player_on_trial:\n            self.state.log_hidden(\"system\", f\"Discussion ended: {self.state.player_on_trial} was put on trial.\")\n            return True\n\n        return False\n\n    def _transition_to_voting(self):\n        \"\"\"\n        Day discussion \u2192 Voting on the accused (or skipping to night if no accusations).\n        \"\"\"\n        if not self.state.player_on_trial:\n            self.state.log_message(\"system\", \"No one was put on trial today.\")\n            self._transition_to_night()\n            return\n\n        self.state.log_message(\"system\", f\"{self.state.player_on_trial} is on trial!\")\n        self.state.votes_for_lynch.clear()\n\n        if self.lynch_defense_enabled:\n            self.state.phase = GamePhase.DEFENSE\n            self.state.current_player_turn = self.state.player_on_trial\n            self.state.log_message(\n                \"system\",\n                f\"{self.state.player_on_trial}, you may speak in your defense.\"\n            )\n        else:\n            # Skip defense and go directly to final vote\n            self._transition_to_final_vote()\n\n    def _run_defense(self):\n        \"\"\"\n        A placeholder hook for the defense phase. \n        The simulation typically calls process_player_action(...) so the accused can make a statement.\n        \"\"\"\n        self.state.log_hidden(\"system\", f\"Defense phase for {self.state.player_on_trial}.\")\n\n    def _transition_to_final_vote(self):\n        \"\"\"\n        Moves from DEFENSE \u2192 FINAL_VOTE. \n        All alive players can vote guilty/innocent simultaneously or in a loop if you prefer.\n        \"\"\"\n        self.state.phase = GamePhase.FINAL_VOTE\n        self.state.current_player_turn = None\n        self.state.votes_for_lynch.clear()\n        self.state.log_message(\n            \"system\",\n            f\"Final voting begins for {self.state.player_on_trial}. Vote GUILTY or INNOCENT.\"\n        )\n\n    def _resolve_lynch(self):\n        \"\"\"\n        After the final vote, count how many guilty vs. innocent votes. \n        Majority (strictly >= half+1) => lynch. Otherwise, no lynch.\n        \"\"\"\n        if not self.state.player_on_trial:\n            self.state.log_hidden(\"system\", \"No player on trial, skipping lynch resolution.\")\n            return\n\n        votes = self.state.votes_for_lynch\n        guilty = sum(1 for is_guilty in votes.values() if is_guilty)\n        innocent = len(votes) - guilty\n        total_alive = len(self.state.alive_players)\n        needed_for_lynch = (total_alive // 2) + 1\n\n        self.state.log_message(\n            \"system\",\n            f\"Vote Results for {self.state.player_on_trial}: \"\n            f\"Guilty={guilty}, Innocent={innocent}. Need {needed_for_lynch} to lynch.\"\n        )\n        self.state.log_hidden(\"system\", f\"Final Votes: {votes}\")\n\n        if guilty >= needed_for_lynch:\n            self.state.log_message(\"system\", f\"The town has decided to lynch {self.state.player_on_trial}!\")\n            self.state.kill_player(self.state.player_on_trial, reason=\"lynched\")\n        else:\n            self.state.log_message(\"system\", f\"The vote is inconclusive, sparing {self.state.player_on_trial}.\")\n\n        self.state.player_on_trial = None\n\n    def _transition_to_night(self):\n        \"\"\"\n        Resets day state and transitions to NIGHT, unless the game has ended.\n        Typically called after lynch resolution or if no trial occurred.\n        \"\"\"\n        self.state.log_hidden(\"system\", \"Transitioning to Night phase.\")\n        if self.state.player_on_trial and self.state.phase != GamePhase.NIGHT:\n            # If for some reason we haven't resolved the lynch yet, do it now\n            self._resolve_lynch()\n\n        if self.state.check_game_end():\n            return  # If game ended from a lynch, stop here\n\n        self.state.phase = GamePhase.NIGHT\n        self.state.reset_night_phase_state()\n        self.state.current_player_turn = None\n        self.state.log_message(\"system\", \"Night falls. Mafia members, choose your targets...\")\n\n    def apply_rewards(self):\n        \"\"\"\n        Optional: If you have a reward system, call it here to store or return\n        partial or final rewards for each player/agent.\n        \"\"\"\n        rewards = compute_rewards(self.state)\n        self.state.log_hidden(\"system\", f\"Computed rewards (not saved): {rewards}\")\n        # Optionally store them in the GameState or return them\n\n    # ----------------------------------------------------------------\n    # Day-Phase Action Helpers\n    # ----------------------------------------------------------------\n\n    def _process_day_discussion_action(\n        self, \n        player: Player, \n        action_type: str, \n        target: Optional[str], \n        content: Optional[str]\n    ) -> bool:\n        \"\"\"\n        Handle actions that can occur specifically in the DAY_DISCUSSION phase.\n        Returns True if valid, False otherwise.\n        \"\"\"\n        # Reset consecutive passes only if the action is not a \"pass\"\n        if action_type == \"pass\":\n            self._consecutive_passes += 1\n            self.state.log_message(player.name, f\"{player.name} passes.\")\n            # Mark that the player has taken a turn\n            self._turns_taken_this_round.add(player.name)\n            return True\n        else:\n            # They did something, so reset the pass counter\n            self._consecutive_passes = 0\n\n        # Accuse\n        if action_type == \"accuse\" and target:\n            if self.state.player_on_trial:\n                self.state.log_hidden(player.name, \"Cannot accuse; someone is already on trial.\")\n                return False\n            success = player.accuse(target, self.state)\n            if success:\n                self.state.player_on_trial = target\n            self._turns_taken_this_round.add(player.name)\n            return success\n\n        # Vote (during discussion, not final vote)\n        elif action_type == \"vote\" and target:\n            success = player.vote_for(target, self.state)\n            self._turns_taken_this_round.add(player.name)\n            return success\n\n        # Question\n        elif action_type == \"question\" and target and content:\n            # Possibly limit # of questions per day, per target\n            times_asked = player.questions_asked_today.get(target, 0)\n            if times_asked >= 1:\n                self.state.log_hidden(player.name, f\"Question limit reached for {target}.\")\n                return False\n            success = player.question(target, content, self.state)\n            if success:\n                player.questions_asked_today[target] = times_asked + 1\n                # Add the Q&A flow to the question queue\n                self._question_queue.append((player.name, target))\n                # Then the questioner is scheduled to respond\n                self._question_queue.append((player.name, player.name))\n            self._turns_taken_this_round.add(player.name)\n            return success\n\n        # Predict role\n        elif action_type == \"predict\" and target and content:\n            success = player.predict_role(target, content, self.state)\n            self._turns_taken_this_round.add(player.name)\n            return success\n\n        # Whisper\n        elif action_type == \"whisper\" and target and content:\n            success = player.whisper(target, content, self.state)\n            self._turns_taken_this_round.add(player.name)\n            return success\n\n        # Generic talk\n        elif action_type == \"speak\":\n            if content:\n                self.state.log_message(player.name, content)\n                self._turns_taken_this_round.add(player.name)\n                return True\n            else:\n                self.state.log_hidden(player.name, \"Tried to speak but no content was provided.\")\n                return False\n\n        # If none of the above matched, treat as invalid or a default \"speak\"\n        if content:\n            self.state.log_message(player.name, content)\n            self._turns_taken_this_round.add(player.name)\n            return True\n\n        self.state.log_hidden(player.name, f\"Invalid or unrecognized day action: {action_type}\")\n        return False\n\n    def _process_voting_phase_action(\n        self,\n        player: Player,\n        action_type: str,\n        target: Optional[str],\n        content: Optional[str]\n    ) -> bool:\n        \"\"\"\n        Handle standard voting phase (pre-defense or a simpler immediate-voting system).\n        If you prefer all final votes to happen in FINAL_VOTE, you can keep this minimal.\n        \"\"\"\n        if action_type == \"vote\" and target == self.state.player_on_trial:\n            # If the environment merges \"voting\" and \"final vote,\" you could do a direct guilty/innocent.\n            # Otherwise, you might track 'vote_for_lynch' in the state, or do a simpler approach.\n            player.vote_for(target, self.state)\n            self.state.log_message(player.name, f\"votes to lynch {target} in the standard voting phase.\")\n            return True\n\n        # You can add logic for 'skip' or 'abstain' as well:\n        elif action_type == \"skip\":\n            self.state.log_message(player.name, f\"{player.name} decides not to vote right now.\")\n            return True\n\n        self.state.log_hidden(player.name, f\"Invalid or mismatched action {action_type} in VOTING phase.\")\n        return False\n\n    def _process_final_vote_action(self, player: Player, action: Dict[str, Any]) -> bool:\n        \"\"\"\n        In FINAL_VOTE phase, each player declares GUILTY or INNOCENT (or possibly abstains).\n        action might look like {\"action\": \"vote\", \"vote_type\": \"final_guilty\"}\n        \"\"\"\n        action_type = action.get(\"action\")\n        vote_type_str = action.get(\"vote_type\", \"\").lower()\n\n        # Must be a \"vote\" action\n        if action_type != \"vote\":\n            self.state.log_hidden(player.name, f\"Expected a vote action in FINAL_VOTE, got {action_type}.\")\n            return False\n\n        if vote_type_str == \"final_guilty\":\n            self.state.votes_for_lynch[player.name] = True\n            self.state.log_message(\n                player.name,\n                f\"votes GUILTY on {self.state.player_on_trial}.\"\n            )\n            return True\n        elif vote_type_str == \"final_innocent\":\n            self.state.votes_for_lynch[player.name] = False\n            self.state.log_message(\n                player.name,\n                f\"votes INNOCENT on {self.state.player_on_trial}.\"\n            )\n            return True\n        elif vote_type_str == \"abstain\":\n            self.state.log_message(player.name, f\"abstains from voting.\")\n            return True\n        else:\n            self.state.log_hidden(\n                player.name,\n                f\"Invalid final vote type: {vote_type_str} (expected 'final_guilty' or 'final_innocent').\"\n            )\n            return False\n\n    # ----------------------------------------------------------------\n    # Night Action Validation\n    # ----------------------------------------------------------------\n\n    def _validate_night_action(self, player: Player, action_dict: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Optional: Enforces certain constraints on night actions:\n          - Godfather cannot kill themselves or a fellow Mafia\n          - Cop cannot investigate themselves\n          - Roleblocker cannot block themselves\n          - ...\n        Return the action_dict if valid, or None if invalid.\n        \"\"\"\n        if not action_dict:\n            return None\n\n        action_type = action_dict.get(\"type\")\n        target = action_dict.get(\"target\")\n\n        # Basic checks: must have a target\n        if not target:\n            self.state.log_hidden(player.name, \"No target specified for night action.\")\n            return None\n\n        # Cop cannot investigate self\n        if action_type == \"investigate\" and target == player.name:\n            self.state.log_hidden(player.name, \"Cop tried to investigate themselves; invalid.\")\n            return None\n\n        # Godfather can't kill themselves or mafia\n        if action_type == \"kill\" and isinstance(player.role, Godfather):\n            target_p = self.state.get_player(target)\n            if target_p:\n                if target_p.faction == Faction.MAFIA or target_p.name == player.name:\n                    self.state.log_hidden(\n                        player.name,\n                        \"Godfather tried to kill themselves or a fellow Mafia, invalid action.\"\n                    )\n                    return None\n\n        # Roleblocker cannot block themselves (if you have a RoleBlocker role)\n        if action_type == \"roleblock\" and isinstance(player.role, RoleBlocker):\n            if target == player.name:\n                self.state.log_hidden(player.name, \"RoleBlocker tried to block themselves, invalid.\")\n                return None\n\n        return action_dict\n",
  "export.py": "# export.py\nimport os\nimport json\n\ndef collect_python_files(root_dir: str) -> dict:\n    file_structure = {}\n\n    for dirpath, _, filenames in os.walk(root_dir):\n        for file in filenames:\n            if file.endswith('.py'):\n                full_path = os.path.join(dirpath, file)\n                rel_path = os.path.relpath(full_path, root_dir)\n                with open(full_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                file_structure[rel_path] = content\n\n    return file_structure\n\ndef export_to_json(output_path=\"code_snapshot.json\", root=\"mafia\"):\n    all_files = collect_python_files(root)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        json.dump(all_files, f, indent=2)\n\ndef export_to_text(output_path=\"code_snapshot.txt\", root=\"mafia\"):\n    all_files = collect_python_files(root)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        for path, content in all_files.items():\n            f.write(f\"# === {path} ===\\n\")\n            f.write(content + \"\\n\\n\")\n\nif __name__ == \"__main__\":\n    export_to_json()\n    export_to_text()\n    print(\"\u2705 Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'\")\n",
  "game_state.py": "# === mafia/game_state.py ===\n\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional, Set, Any, Union\nimport uuid\n\n# Core references to your enums, players, and roles:\nfrom mafia.enums import GamePhase, Faction\nfrom mafia.player import Player\nfrom mafia.mechanics.roles import Goon, Godfather, get_role_class\n\n# -------------------------------------------------------------------\n# Define the \"type\" of a single logged message, for clarity.\n# Feel free to expand or rename these categories.\n# -------------------------------------------------------------------\nMESSAGE_TYPES = (\n    \"system\",            # Internal system or phase announcements\n    \"public\",            # Publicly spoken messages\n    \"whisper\",           # Private whisper from A\u2192B\n    \"vote\",              # Voting or accusation messages\n    \"death_announcement\" # Messages triggered on death\n    # ... add \"debug\", \"accusation\", etc. as you see fit\n)\n\n@dataclass\nclass GameMessage:\n    \"\"\"Structured record of a single game message.\"\"\"\n    msg_type: str       # e.g. 'system', 'public', 'whisper', ...\n    sender: str         # 'system' or player_name\n    content: str\n    recipients: Optional[List[str]] = None  # None means public\n    phase: GamePhase = GamePhase.NIGHT\n    day: int = 0\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to a serializable dict (helpful if you store logs as JSON).\"\"\"\n        return {\n            \"type\": self.msg_type,\n            \"sender\": self.sender,\n            \"content\": self.content,\n            \"recipients\": self.recipients,\n            \"phase\": self.phase.name,\n            \"day\": self.day\n        }\n\n\n@dataclass\nclass GameState:\n    \"\"\"\n    Central data store for a Mafia game:\n      - Keeps track of players, alive/dead sets, messages, day/night transitions\n      - Contains methods for logging and checking endgame\n    \"\"\"\n\n    # ------------------------------\n    # Core game setup\n    # ------------------------------\n    players: List[Player]\n    game_config: Dict[str, Any] = field(default_factory=dict)  # e.g. \"lynch_required\": True, etc.\n\n    # ------------------------------\n    # Phase & Turn Tracking\n    # ------------------------------\n    phase: GamePhase = GamePhase.NIGHT\n    day_count: int = 0\n    turn_number_in_phase: int = 0\n    current_player_turn: Optional[str] = None\n\n    # Keep track of which players are alive or dead\n    alive_players: Set[str] = field(default_factory=set)\n    dead_players: Set[str] = field(default_factory=set)\n\n    # ------------------------------\n    # Logging\n    # ------------------------------\n    # Public and private logs\n    messages: List[GameMessage] = field(default_factory=list)\n    hidden_log: List[Dict[str, Any]] = field(default_factory=list)\n\n    # ------------------------------\n    # Accusation / Voting (Day)\n    # ------------------------------\n    # E.g. for a pre-trial voting system if you use it\n    votes_for_accusation: Dict[str, str] = field(default_factory=dict)  # voter -> target\n    accusation_counts: Dict[str, int] = field(default_factory=dict)     # target -> count\n\n    # Which player is currently on trial (if any)\n    player_on_trial: Optional[str] = None\n\n    # Final-lunch votes: None = abstain, True = Guilty, False = Innocent\n    votes_for_lynch: Dict[str, Optional[bool]] = field(default_factory=dict)\n\n    # Token budgets for controlling how much players can speak (optional)\n    discussion_token_budgets: Dict[str, int] = field(default_factory=dict)\n\n    # ------------------------------\n    # Night Phase Action Tracking\n    # ------------------------------\n    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n\n    # ------------------------------\n    # Game Identity & Completion\n    # ------------------------------\n    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    game_over: bool = False\n    winner: Optional[Faction] = None\n    final_player_roles: Dict[str, str] = field(default_factory=dict)  # e.g. \"Alice\": \"Godfather\"\n\n    # Optional: track transitions or time-based info\n    phase_history: List[Dict[str, Any]] = field(default_factory=list)\n\n    # ----------------------------------------------------------------\n    # Initialization & Setup\n    # ----------------------------------------------------------------\n\n    def initialize(self):\n        \"\"\"Called once at game start to populate initial states.\"\"\"\n        self.alive_players = {p.name for p in self.players}\n        self.dead_players.clear()\n        self.day_count = 0\n        self.phase = GamePhase.NIGHT\n        self.game_over = False\n        self.winner = None\n        self.messages.clear()\n        self.hidden_log.clear()\n        self.final_player_roles.clear()\n        self.votes_for_accusation.clear()\n        self.accusation_counts.clear()\n        self.player_on_trial = None\n        self.votes_for_lynch.clear()\n\n        # Reset each player's personal state\n        for player in self.players:\n            player.reset_for_new_game()\n            # Optionally set token budgets if using\n            # initial_tokens = self.game_config.get(\"initial_tokens\", 999)\n            # self.discussion_token_budgets[player.name] = initial_tokens\n\n        # Example: record the start of the initial phase\n        self.record_phase_start()\n\n        # Log game creation\n        self.log_message(\"system\", \"Game started.\", msg_type=\"system\")\n        self.log_hidden(\"system\", f\"Game ID: {self.game_id}\")\n        self.log_hidden(\"system\", f\"Initial Roles: { {p.name: p.role.name for p in self.players} }\")\n\n    # ----------------------------------------------------------------\n    # Player & Survival\n    # ----------------------------------------------------------------\n\n    def get_player(self, name: str) -> Optional[Player]:\n        return next((p for p in self.players if p.name == name), None)\n\n    def is_alive(self, name: str) -> bool:\n        return name in self.alive_players\n\n    def kill_player(self, name: str, reason: str = \"killed\"):\n        \"\"\"\n        Officially kills a player:\n          - Removes from alive_players\n          - Logs death message\n          - Checks if Godfather died => Goon promotion\n          - Triggers check_game_end\n        \"\"\"\n        if name not in self.alive_players:\n            return  # Already dead or invalid\n\n        player = self.get_player(name)\n        if not player:\n            return\n\n        self.alive_players.remove(name)\n        self.dead_players.add(name)\n        player.alive = False\n\n        self.log_message(\n            \"system\",\n            f\"{name} ({player.role.name}) has died ({reason}).\",\n            msg_type=\"death_announcement\"\n        )\n        self.log_hidden(\"system\", f\"{name} died. Reason: {reason}\")\n\n        # Check for Godfather death => Promote a Goon\n        if isinstance(player.role, Godfather):\n            self._promote_goon_to_gf(dead_gf_name=name)\n\n        self.check_game_end()\n\n    def _promote_goon_to_gf(self, dead_gf_name: str):\n        \"\"\"Promote the first alive Goon to Godfather upon GF death.\"\"\"\n        promoted_goon: Optional[Player] = None\n        for p in self.players:\n            if p.name in self.alive_players and isinstance(p.role, Goon):\n                promoted_goon = p\n                break\n\n        if promoted_goon:\n            new_role = Godfather()\n            promoted_goon.role = new_role\n            promoted_goon.faction = new_role.faction\n            self.log_message(\n                \"system\",\n                f\"{promoted_goon.name} has been promoted to Godfather!\",\n                msg_type=\"system\"\n            )\n            self.log_hidden(\n                promoted_goon.name,\n                f\"Promoted to Godfather after {dead_gf_name}'s death\"\n            )\n        else:\n            self.log_hidden(\"system\", f\"No Goon available to promote after {dead_gf_name} died.\")\n\n    # ----------------------------------------------------------------\n    # Phase State Management\n    # ----------------------------------------------------------------\n\n    def reset_night_phase_state(self):\n        \"\"\"Clears any leftover actions/results from the previous night phase.\"\"\"\n        self.night_actions_submitted.clear()\n        self.night_action_results.clear()\n        self.turn_number_in_phase = 0\n        self.current_player_turn = None\n        for p_name in self.alive_players:\n            p = self.get_player(p_name)\n            if p:\n                p.reset_night_state()\n\n    def reset_day_phase_state(self):\n        \"\"\"Clears day-specific data like accusations, lynch votes, and resets turn tracking.\"\"\"\n        self.votes_for_accusation.clear()\n        self.accusation_counts.clear()\n        self.player_on_trial = None\n        self.votes_for_lynch.clear()\n        self.turn_number_in_phase = 0\n        self.current_player_turn = None\n        for p_name in self.alive_players:\n            p = self.get_player(p_name)\n            if p:\n                p.reset_day_state()\n\n    # ----------------------------------------------------------------\n    # Accusation & Voting Threshold\n    # ----------------------------------------------------------------\n\n    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):\n        \"\"\"\n        If your day logic uses an 'accuse to put on trial' mechanism,\n        track each player's accusation and count how many times each target was accused.\n        \"\"\"\n        if old_target and old_target in self.accusation_counts:\n            self.accusation_counts[old_target] -= 1\n            if self.accusation_counts[old_target] <= 0:\n                del self.accusation_counts[old_target]\n\n        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1\n        self.votes_for_accusation[voter] = new_target\n\n    def get_accusation_threshold(self) -> int:\n        \"\"\"\n        Returns how many votes are needed to put someone on trial during discussion.\n        By default, we use a majority threshold if not explicitly set.\n\n        e.g. threshold = floor(#alive / 2) + 1\n        \"\"\"\n        if \"accusation_threshold\" in self.game_config:\n            return int(self.game_config[\"accusation_threshold\"])\n        # Default to simple majority\n        return (len(self.alive_players) // 2) + 1\n\n    def accusation_threshold_reached(self, target: str) -> bool:\n        \"\"\"Check if the accused has enough votes to start a trial.\"\"\"\n        needed = self.get_accusation_threshold()\n        return self.accusation_counts.get(target, 0) >= needed\n\n    # ----------------------------------------------------------------\n    # Night Actions\n    # ----------------------------------------------------------------\n\n    def register_night_action(self, actor_name: str, action: Dict[str, Any]):\n        \"\"\"Stores the intended night action from a player. The environment resolves them later.\"\"\"\n        if not self.is_alive(actor_name):\n            return\n        self.night_actions_submitted[actor_name] = action\n        self.log_hidden(actor_name, f\"Submitted night action: {action}\")\n\n    # ----------------------------------------------------------------\n    # Endgame Conditions\n    # ----------------------------------------------------------------\n\n    def check_game_end(self) -> bool:\n        \"\"\"\n        Checks if the game has ended by evaluating basic Town vs Mafia logic (and optionally expansions).\n        If a winner is found, we finalize the game and store final roles.\n        \"\"\"\n        if self.game_over:\n            return True  # Already ended\n\n        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}\n        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}\n        # If you want to handle neutrals or special roles, do so here\n\n        winner: Optional[Faction] = None\n\n        # Example: Town wins if no mafia remain\n        if not mafia_alive:\n            winner = Faction.TOWN\n        # Mafia wins if mafia >= town or the config-based rule\n        elif len(mafia_alive) >= len(town_alive):\n            winner = Faction.MAFIA\n\n        # Add any additional conditions or neutrals logic here\n\n        if winner:\n            self.game_over = True\n            self.winner = winner\n            self.phase = GamePhase.GAME_OVER\n\n            # Final role record\n            self.final_player_roles = {p.name: p.role.name for p in self.players}\n\n            self.log_message(\n                \"system\",\n                f\"Game Over! Winner: {winner.value.upper()}\",\n                msg_type=\"system\"\n            )\n            self.log_hidden(\"system\", f\"Final Roles: {self.final_player_roles}\")\n            return True\n\n        return False\n\n    # ----------------------------------------------------------------\n    # Logging\n    # ----------------------------------------------------------------\n\n    def log_message(self,\n                    sender: str,\n                    content: str,\n                    recipients: Optional[List[str]] = None,\n                    msg_type: str = \"public\"):\n        \"\"\"\n        Logs a message to the main game log with a specified type (system, whisper, etc.).\n        If 'recipients' is None, it's public for all. Otherwise, only the given recipients can see it.\n        \"\"\"\n        if msg_type not in MESSAGE_TYPES:\n            msg_type = \"public\"  # fallback if unknown\n\n        self.messages.append(\n            GameMessage(\n                msg_type=msg_type,\n                sender=sender,\n                content=content,\n                recipients=recipients,\n                phase=self.phase,\n                day=self.day_count\n            )\n        )\n\n    def log_hidden(self, actor: str, info: str):\n        \"\"\"\n        Logs details that only certain debugging or hidden channels should see.\n        Often used for debugging or system clarifications.\n        \"\"\"\n        entry = {\n            \"actor\": actor,\n            \"info\": info,\n            \"phase\": self.phase.name,\n            \"day\": self.day_count,\n            \"turn\": self.turn_number_in_phase\n        }\n        self.hidden_log.append(entry)\n\n    # ----------------------------------------------------------------\n    # Observations\n    # ----------------------------------------------------------------\n\n    def get_player_observation(self, player_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Generates a viewpoint for one player, containing:\n          - visible (public + relevant private) messages\n          - personal flags (roleblocked, protected, memory)\n          - day/phase details\n        \"\"\"\n        player = self.get_player(player_name)\n        if not player or not player.alive:\n            # Alternatively, return a 'You are dead' prompt\n            return {\n                \"game_id\": self.game_id,\n                \"player_name\": player_name,\n                \"alive\": False,\n                \"message\": \"You are no longer in the game.\"\n            }\n\n        # Gather messages visible to this player\n        visible_messages: List[str] = []\n        for msg_obj in self.messages:\n            is_recip_private = (msg_obj.recipients is not None and player_name in msg_obj.recipients)\n            is_sender_private = (msg_obj.sender == player_name and msg_obj.recipients is not None)\n            if (msg_obj.recipients is None) or is_recip_private or is_sender_private:\n                # Format differently if it's a whisper or if they are the sender\n                if msg_obj.msg_type == \"whisper\":\n                    if is_sender_private:\n                        # From self to someone else\n                        visible_messages.append(\n                            f\"(Whisper to {msg_obj.recipients[0]}) {msg_obj.content}\"\n                        )\n                    elif is_recip_private:\n                        # A whisper from someone else to you\n                        visible_messages.append(\n                            f\"(Whisper from {msg_obj.sender}) {msg_obj.content}\"\n                        )\n                    else:\n                        # Shouldn't happen with typed logs, but just in case\n                        visible_messages.append(f\"{msg_obj.sender}: {msg_obj.content}\")\n                else:\n                    # Normal or system message\n                    visible_messages.append(f\"{msg_obj.sender}: {msg_obj.content}\")\n\n        # Construct final observation\n        obs = {\n            \"game_id\": self.game_id,\n            \"player_name\": player.name,\n            \"role\": player.role.name,\n            \"role_description\": player.role.get_role_description(),\n            \"faction\": player.faction.value,\n            \"phase\": self.phase.name,\n            \"day\": self.day_count,\n            \"turn\": self.turn_number_in_phase,\n            \"is_current_turn\": (self.current_player_turn == player.name),\n            \"alive_players\": sorted(self.alive_players),\n            \"dead_players\": sorted(self.dead_players),\n            \"messages\": visible_messages[-20:],  # Limit message history\n            \"can_speak\": player.can_speak(),\n            \"can_act_tonight\": (player.can_act_at_night() and self.phase == GamePhase.NIGHT),\n            \"player_on_trial\": self.player_on_trial,\n            \"votes_for_accusation\": dict(self.votes_for_accusation),\n            \"accusation_counts\": dict(self.accusation_counts),\n            \"memory\": list(player.memory),\n            \"is_roleblocked\": player.is_roleblocked,\n            \"protected_by\": player.protected_by,\n            # Example: \"token_budget\": self.discussion_token_budgets.get(player.name, 0),\n            \"lynch_votes\": {\n                voter: val for voter, val in self.votes_for_lynch.items()\n            },  # Show final vote states\n        }\n        return obs\n\n    # ----------------------------------------------------------------\n    # Optional: Phase Tracking for Debug or Time-Aware Agents\n    # ----------------------------------------------------------------\n\n    def record_phase_start(self):\n        \"\"\"\n        Record the beginning of a new phase for debugging or analysis.\n        You might store timestamps, etc.\n        \"\"\"\n        entry = {\n            \"phase\": self.phase.name,\n            \"day\": self.day_count,\n            \"turn_start\": self.turn_number_in_phase,\n            \"timestamp\": None  # set to datetime.now() if you want\n        }\n        self.phase_history.append(entry)\n\n    def record_phase_end(self):\n        \"\"\"Mark the end of the current phase, e.g. to track how long each phase lasted.\"\"\"\n        if self.phase_history:\n            self.phase_history[-1][\"turn_end\"] = self.turn_number_in_phase\n            self.phase_history[-1][\"end_timestamp\"] = None  # if storing actual time\n\n    # ----------------------------------------------------------------\n    # Auditing / Debugging Tools\n    # ----------------------------------------------------------------\n\n    def get_game_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns a structured summary of the game\u2019s final state or current state.\n        Useful for logs, testing, or replay.\n        \"\"\"\n        summary = {\n            \"game_id\": self.game_id,\n            \"phase\": self.phase.name,\n            \"day_count\": self.day_count,\n            \"game_over\": self.game_over,\n            \"winner\": self.winner.value if self.winner else None,\n            \"alive_players\": sorted(list(self.alive_players)),\n            \"dead_players\": sorted(list(self.dead_players)),\n            \"final_player_roles\": dict(self.final_player_roles),\n            \"messages_count\": len(self.messages),\n            \"hidden_log_count\": len(self.hidden_log),\n            \"phase_history\": self.phase_history,\n        }\n        return summary\n\n",
  "player.py": "from typing import Optional, Dict, List, Any\n# Import the base Role class and Faction enum\nfrom mafia.mechanics.roles import Role\nfrom mafia.enums import Faction\n# Import GameState for type hinting only to avoid circular dependency\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from mafia.game_state import GameState\n\n\nclass Player:\n    def __init__(self, name: str, role: Role):\n        self.name: str = name\n        self.role: Role = role\n        # Faction comes directly from the role object\n        self.faction: Faction = self.role.faction\n        self.alive: bool = True\n\n        # Night action state\n        self.night_target: Optional[str] = None  # Who the player chose to target\n        self.is_roleblocked: bool = False\n        self.protected_by: Optional[str] = None  # Who protected this player (e.g., Doctor's name)\n\n        # Day state\n        self.vote: Optional[str] = None  # For initial vote (e.g., accusation target)\n        self.trial_vote: Optional[bool] = None  # For final trial vote (True=Guilty, False=Innocent, None=Abstain)\n        self.discussion_tokens: int = 0  # Handled by environment/config\n        self.can_speak_today: bool = True  # For effects like Blackmailer\n\n        # Action tracking & Memory\n        self.has_accused_today: bool = False\n        self.predictions: Dict[str, str] = {}  # target_name -> predicted_role_name\n        self.questions_asked_today: Dict[str, int] = {}  # target_name -> count\n        self.whispers_sent_today: Dict[str, str] = {}  # target_name -> last_whisper_content\n\n        # Memory for roles like Cop (to store investigation results, etc.)\n        self.memory: List[Dict[str, Any]] = []\n\n        # Optional: Track messages said/received for advanced agents\n        self.messages_said: List[str] = []\n        self.messages_received: List[str] = []\n\n    def reset_for_new_game(self):\n        \"\"\"Resets player state for the start of a new game.\"\"\"\n        self.alive = True\n        self.reset_night_state()\n        self.reset_day_state()\n        self.memory.clear()\n        self.predictions.clear()\n        # Reset message logs if desired\n        self.messages_said.clear()\n        self.messages_received.clear()\n\n    def reset_night_state(self):\n        \"\"\"Resets state relevant to the night phase.\"\"\"\n        self.night_target = None\n        self.is_roleblocked = False\n        self.protected_by = None\n\n    def reset_day_state(self):\n        \"\"\"Resets state relevant to the day phase.\"\"\"\n        self.vote = None\n        self.trial_vote = None\n        # discussion_tokens might be reset by environment based on config\n        self.has_accused_today = False\n        self.questions_asked_today.clear()\n        self.whispers_sent_today.clear()\n        self.can_speak_today = True  # Reset mute/blacklist effects\n\n    def can_act_at_night(self) -> bool:\n        \"\"\"Check if player is alive and their role has a night action.\"\"\"\n        return self.alive and self.role.can_act_at_night()\n\n    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Performs the player's role-specific night action.\n        Assumes self.night_target has been set by the agent.\n        Returns the action dict or None.\n        \"\"\"\n        if not self.can_act_at_night() or self.is_roleblocked:\n            if self.is_roleblocked:\n                self.log_hidden(game_state, \"Tried to act but was roleblocked.\")\n            return None\n        return self.role.night_action(self, game_state, self.night_target)\n\n    def can_speak(self) -> bool:\n        \"\"\"\n        Returns whether the player is allowed to speak during the day.\n        Can incorporate token budgets or mute effects if needed.\n        \"\"\"\n        return self.alive and self.can_speak_today\n\n    # --- Day Actions ---\n\n    def accuse(self, target: str, game_state: 'GameState') -> bool:\n        \"\"\"\n        Attempts to accuse a target. Only allowed once per day.\n        Logs the accusation and appends a public message.\n        \"\"\"\n        if not self.can_speak() or self.has_accused_today:\n            self.log_hidden(game_state, f\"Attempted to accuse {target} but couldn't (already accused or cannot speak).\")\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to accuse {target} but they are dead or invalid.\")\n            return False\n\n        self.log_hidden(game_state, f\"Accused {target}\")\n        game_state.messages.append(f\"{self.name} accuses {target}!\")\n        self.has_accused_today = True\n        return True\n\n    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState') -> bool:\n        \"\"\"\n        Predicts a player's role for internal analysis. Can be used to compare against actual role later.\n        \"\"\"\n        if not self.alive:\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player:\n            return False\n\n        self.predictions[target] = predicted_role_name\n        self.log_hidden(game_state, f\"Predicted {target} as {predicted_role_name}\")\n        return True\n\n    def question(self, target: str, question_text: str, game_state: 'GameState') -> bool:\n        \"\"\"\n        Sends a question to another player. The environment typically handles the Q&A flow.\n        \"\"\"\n        if not self.can_speak():\n            self.log_hidden(game_state, f\"Attempted to question {target} but cannot speak.\")\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to question {target} but they are dead or invalid.\")\n            return False\n\n        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1\n        self.log_hidden(game_state, f\"Asked {target}: {question_text}\")\n        game_state.messages.append(f\"{self.name} asks {target}: \\\"{question_text}\\\"\")\n        return True\n\n    def whisper(self, target: str, whisper_text: str, game_state: 'GameState') -> bool:\n        \"\"\"\n        Sends a private message to another player. The content is hidden from public logs.\n        \"\"\"\n        if not self.alive:\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to whisper {target} but they are dead or invalid.\")\n            return False\n\n        self.whispers_sent_today[target] = whisper_text\n        self.log_hidden(game_state, f\"Whispered to {target}: {whisper_text}\")\n        # For simplicity, append a placeholder to public messages (actual content remains hidden)\n        game_state.messages.append(f\"[WHISPER] {self.name} to {target}\")\n        return True\n\n    def vote_for(self, target: str, game_state: 'GameState') -> bool:\n        \"\"\"\n        Casts or changes a vote during the initial accusation phase.\n        \"\"\"\n        if not self.alive:\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to vote for {target} but they are dead or invalid.\")\n            return False\n\n        old_vote = self.vote\n        self.vote = target\n        if old_vote and old_vote != target:\n            log_msg = f\"Changed vote from {old_vote} to {target}\"\n            public_msg = f\"{self.name} changed vote to {target}.\"\n        elif not old_vote:\n            log_msg = f\"Voted for {target}\"\n            public_msg = f\"{self.name} voted for {target}.\"\n        else:\n            return True  # No change needed\n\n        self.log_hidden(game_state, log_msg)\n        game_state.messages.append(public_msg)\n        game_state.update_vote_counts(self.name, old_vote, target)\n        return True\n\n    # --- Voting Phase: Final Trial Vote Support ---\n    def cast_trial_vote(self, vote_type: str, game_state: 'GameState') -> bool:\n        \"\"\"\n        Casts a final vote during the trial phase.\n        vote_type should be one of: 'guilty', 'innocent', 'abstain'.\n        This vote is stored separately as trial_vote.\n        \"\"\"\n        if not self.alive:\n            return False\n\n        vt = vote_type.lower()\n        if vt == \"guilty\":\n            self.trial_vote = True\n        elif vt == \"innocent\":\n            self.trial_vote = False\n        elif vt == \"abstain\":\n            self.trial_vote = None\n        else:\n            self.log_hidden(game_state, f\"Invalid trial vote type: {vote_type}\")\n            return False\n\n        self.log_hidden(game_state, f\"Cast final vote: {vote_type.upper()}\")\n        game_state.messages.append(f\"{self.name} casts a final vote: {vote_type.upper()}.\")\n        return True\n\n    def abstain_from_vote(self, game_state: 'GameState') -> bool:\n        \"\"\"\n        Explicitly abstains from voting in the trial phase.\n        \"\"\"\n        if not self.alive:\n            return False\n\n        self.trial_vote = None\n        self.log_hidden(game_state, \"Abstained from voting in the trial phase.\")\n        game_state.messages.append(f\"{self.name} abstains from the final vote.\")\n        return True\n\n    # --- LLM Action Interface ---\n    def get_available_actions(self, game_state: 'GameState') -> List[Dict[str, Any]]:\n        \"\"\"\n        Returns a structured list of available actions for this player.\n        Each action is represented as a dict with a 'type' and optional 'params'.\n        This helps LLM agents know what actions they can take.\n        \"\"\"\n        if not self.alive:\n            return []\n\n        actions = []\n\n        # Actions available during the day if the player can speak\n        if self.can_speak():\n            actions.append({\"type\": \"speak\", \"params\": [\"content\"]})\n            actions.append({\"type\": \"accuse\", \"params\": [\"target\"]})\n            actions.append({\"type\": \"question\", \"params\": [\"target\", \"question_text\"]})\n            actions.append({\"type\": \"predict\", \"params\": [\"target\", \"predicted_role\"]})\n            actions.append({\"type\": \"whisper\", \"params\": [\"target\", \"whisper_text\"]})\n\n        # Actions available during night if the role can act\n        if game_state.phase == game_state.phase.__class__.NIGHT and self.can_act_at_night():\n            actions.append({\"type\": \"night_action\", \"params\": [\"target\"]})\n\n        # Voting phase actions (both initial vote and trial vote)\n        if game_state.phase.name in {\"VOTING\", \"FINAL_VOTE\"}:\n            actions.append({\"type\": \"vote\", \"params\": [\"target\"]})\n            actions.append({\"type\": \"abstain\", \"params\": []})\n        # Final trial voting is separate from initial accusations\n        if game_state.phase.name == \"FINAL_VOTE\":\n            actions.append({\"type\": \"cast_trial_vote\", \"params\": [\"vote_type (guilty/innocent/abstain)\"]})\n\n        return actions\n\n    # --- Debugging / Serialization ---\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the player's state into a dictionary for debugging or logging purposes.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"role\": self.role.name,\n            \"faction\": self.faction.value,\n            \"alive\": self.alive,\n            \"vote\": self.vote,\n            \"trial_vote\": self.trial_vote,\n            \"night_target\": self.night_target,\n            \"memory\": self.memory,\n            \"predictions\": self.predictions,\n            \"questions_asked_today\": self.questions_asked_today,\n            \"whispers_sent_today\": self.whispers_sent_today,\n        }\n\n    def log_hidden(self, game_state: 'GameState', info: str):\n        \"\"\"\n        Logs hidden information to the game state's hidden log.\n        \"\"\"\n        game_state.log_hidden(self.name, info)\n\n    def __repr__(self):\n        status = 'Dead' if not self.alive else 'Alive'\n        return f\"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>\"\n",
  "rewards.py": "# mafia/rewards.py\nfrom typing import Dict\nfrom mafia.enums import Faction\n\n\ndef assign_endgame_rewards(game_state) -> Dict[str, float]:\n    \"\"\"\n    Assign final rewards to agents based on game outcome.\n    Town agents get +1 for town win, -1 otherwise. Same for mafia.\n    \"\"\"\n    rewards = {}\n    for player in game_state.players:\n        if player.faction.value == game_state.winner:\n            rewards[player.name] = 1.0\n        else:\n            rewards[player.name] = -1.0\n    return rewards\n\n\ndef assign_predict_role_reward(predicted: str, actual: str) -> float:\n    return 0.5 if predicted == actual else -0.25\n\n\ndef assign_vote_reward(voter, target, game_state) -> float:\n    \"\"\"\n    +1 if town correctly votes out mafia\n    -1 if town votes town\n    +0.5 if mafia avoids being voted\n    \"\"\"\n    if not game_state.is_alive(target):  # Lynched\n        if voter.faction == Faction.TOWN:\n            if game_state.get_player(target).faction == Faction.MAFIA:\n                return 1.0\n            else:\n                return -1.0\n        elif voter.faction == Faction.MAFIA:\n            if game_state.get_player(target).faction == Faction.MAFIA:\n                return -1.0\n            else:\n                return 0.5\n    return 0.0\n\n\ndef assign_speaking_reward(agent_name: str, token_used: int) -> float:\n    \"\"\"\n    Optional: Reward for verbosity, or penalize excess verbosity.\n    For now, neutral. Could be tuned.\n    \"\"\"\n    return 0.0\n\n\ndef assign_question_reward(asker, target, game_state) -> float:\n    \"\"\"\n    +0.2 for engaging others; could scale if target is mafia and asker is town\n    \"\"\"\n    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:\n        return 0.4\n    return 0.2\n",
  "simulation.py": "import os\nimport json\nfrom tqdm import tqdm\n# Use correct Environment class name\nfrom mafia.environment import MafiaEnvironment\n# Import role classes and helper\nfrom mafia.mechanics.roles import get_role_class, Role\nfrom mafia.player import Player\n# Keep TokenTracker import, assume it exists or create dummy\n# from mafia.utils.token_cost import TokenTracker # If using\n# Import agent classes\nfrom mafia.agents.rule_agent import RuleBasedAgent # Assuming this will exist\nfrom mafia.agents.llm_agent import LLMAPIClientAgent # Import the LLM agent\nfrom typing import Dict, List\nimport uuid\n\n# Dummy Token Tracker if needed\nclass TokenTracker:\n    def __init__(self): self.usage = {}\n    def update(self, *args, **kwargs): pass\n    def to_dict(self): return self.usage\n\ndef create_players_from_config(config: Dict) -> List[Player]:\n    \"\"\"Creates Player objects based on a configuration dictionary.\"\"\"\n    players = []\n    roles_config = config.get(\"roles\", []) # e.g., [{\"name\": \"Player1\", \"role\": \"Cop\"}, ...]\n    if not roles_config: # Fallback to default if config is empty/missing roles\n        roles_setup = [\n            (\"Player1\", \"Cop\"), (\"Player2\", \"Doctor\"), (\"Player3\", \"Villager\"),\n            (\"Player4\", \"Godfather\"), (\"Player5\", \"Goon\")\n        ]\n        print(\"Warning: Using default 5-player role setup.\")\n    else:\n        roles_setup = [(p_cfg[\"name\"], p_cfg[\"role\"]) for p_cfg in roles_config]\n\n    for name, role_name in roles_setup:\n        RoleClass = get_role_class(role_name)\n        if not RoleClass:\n             raise ValueError(f\"Unknown role name '{role_name}' in configuration.\")\n        role_instance = RoleClass()\n        player = Player(name=name, role=role_instance)\n\n        # --- Agent Assignment ---\n        # Example: Assign agents based on config or default to RuleBased\n        agent_type = config.get(\"agent_mapping\", {}).get(name, \"rule\") # Default to rule-based\n\n        if agent_type.lower() == \"llm\":\n            # TODO: Get model name, system prompt from config\n            model_name = config.get(\"llm_config\", {}).get(\"model\", \"gpt-4\") # Example default\n            system_prompt_key = config.get(\"llm_config\", {}).get(\"system_prompt_key\", \"default_mafia\")\n            # Need a way to load system prompts based on key\n            system_prompt = f\"You are {name}, playing Mafia as {role_instance.name}. {role_instance.get_role_description()}\" # Basic example\n            agent = LLMAPIClientAgent(name=name, model=model_name, system_prompt=system_prompt)\n            print(f\"Assigning LLM Agent ({model_name}) to {name}\")\n        else: # Default to RuleBasedAgent\n             # RuleBasedAgent needs to be implemented\n            agent = RuleBasedAgent(name=name, player_role=role_instance.name)\n            print(f\"Assigning Rule Agent to {name}\")\n\n        # Link agent to player (though environment might manage this)\n        player.agent = agent # Store agent reference if needed directly by player, otherwise managed by env/runner\n        players.append(player)\n\n    return players\n\n\ndef run_simulation(game_config: Dict, agent_config: Dict) -> Dict:\n    \"\"\"Runs a single game simulation and returns the final state.\"\"\"\n    print(f\"\\n--- Starting Simulation Game ID: {game_config.get('game_id', 'N/A')} ---\")\n\n    # Combine configs or pass separately\n    full_config = {**game_config, \"agents\": agent_config} # Example merge\n\n    # Create players based on combined config\n    players = create_players_from_config(full_config) # Pass merged config\n\n    # Initialize environment\n    # Pass game_config to environment if it needs rules like GF detectability\n    env = MafiaEnvironment(players=players, config=full_config)\n    token_tracker = TokenTracker() # Initialize token tracker if used\n\n    # --- Game Loop ---\n    max_steps = full_config.get(\"max_steps\", 100) # Limit game length\n    step_count = 0\n    while not env.state.game_over and step_count < max_steps:\n        step_count += 1\n        print(f\"\\n=== Day {env.state.day_count} | Phase: {env.state.phase.name} | Turn: {env.state.turn_number_in_phase} ===\")\n        current_player_name = env.get_current_player_name() # Needs implementation in Env\n\n        if not current_player_name:\n            # Environment handles transition or phase resolution automatically\n             print(\"Environment resolving phase...\")\n             env.step_phase() # Needs implementation in Env\n             continue # Go to next loop iteration to check game state\n\n        player = env.state.get_player(current_player_name)\n        if not player or not player.alive:\n             print(f\"Skipping turn for {current_player_name} (dead or invalid).\")\n             env.advance_turn() # Needs implementation in Env\n             continue\n\n        agent = player.agent # Get agent associated with the player\n\n        # Get observation for the current player\n        observation = env.get_observation(current_player_name) # Needs implementation in Env\n\n        # Agent decides action\n        print(f\"--- {current_player_name}'s Turn ({agent.__class__.__name__}) ---\")\n        action = agent.act(observation) # Agent returns action dict\n        print(f\"Action chosen: {action}\")\n\n        # Environment processes action\n        success = env.process_player_action(current_player_name, action) # Needs implementation in Env\n        if not success:\n            print(f\"Action {action} failed or was invalid.\")\n\n        # Optional: Track tokens\n        # token_tracker.update(current_player_name, observation, action)\n\n        # Environment potentially advances turn or phase based on action\n        # This might happen inside process_player_action or require a separate env.advance() call\n\n    print(f\"\\n--- Game Over ---\")\n    print(f\"Winner: {env.state.winner.value if env.state.winner else 'Draw/Timeout'}\")\n    print(f\"Ended on Day {env.state.day_count}, Phase {env.state.phase.name}\")\n\n    # Log final state and return results\n    final_state_summary = log_game_summary(env.state) # Use analysis function\n    final_state_summary[\"tokens_used\"] = token_tracker.to_dict() # Add token info if tracked\n    return final_state_summary\n\n\ndef run_multiple_simulations(num_games=10, config_path=\"config/default_game.json\", save_dir=\"data/episodes\"):\n    \"\"\"Runs multiple simulations based on a config file.\"\"\"\n    os.makedirs(save_dir, exist_ok=True)\n\n    # Load base configuration (needs implementation)\n    # base_game_config = load_config_from_file(config_path)\n    # base_agent_config = base_game_config.get(\"agent_config\", {}) # Separate agent config if needed\n    base_game_config = {\"roles\": [ # Example default config\n             {\"name\": \"Player1\", \"role\": \"Cop\"}, {\"name\": \"Player2\", \"role\": \"Doctor\"},\n             {\"name\": \"Player3\", \"role\": \"Villager\"}, {\"name\": \"Player4\", \"role\": \"Godfather\"},\n             {\"name\": \"Player5\", \"role\": \"Goon\"}\n         ],\n        \"agent_mapping\": {\"Player1\": \"llm\", \"Player4\": \"llm\"}, # P1 & P4 are LLMs\n        \"llm_config\": {\"model\": \"gpt-3.5-turbo\"} # Example LLM config\n     }\n    base_agent_config = {} # Agent specific settings if needed\n\n\n    game_results = []\n    for i in tqdm(range(num_games), desc=\"Simulating Games\"):\n        game_id = str(uuid.uuid4())\n        current_game_config = {**base_game_config, \"game_id\": game_id}\n        # Add variations here if doing experiments (e.g., change roles, prompts)\n\n        try:\n            result = run_simulation(current_game_config, base_agent_config)\n            game_results.append(result)\n\n            # Save individual game logs as JSONL\n            log_path = os.path.join(save_dir, \"games_log.jsonl\")\n            with open(log_path, \"a\") as f:\n                json.dump(result, f)\n                f.write(\"\\n\")\n\n        except Exception as e:\n            print(f\"\\n!!!!!! Error during simulation {game_id} !!!!!!\")\n            print(f\"Error: {e}\")\n            # Log error state if possible\n            error_info = {\"game_id\": game_id, \"status\": \"error\", \"error_message\": str(e)}\n            log_path = os.path.join(save_dir, \"games_log.jsonl\")\n            with open(log_path, \"a\") as f:\n                json.dump(error_info, f)\n                f.write(\"\\n\")\n\n\n    print(f\"\\n--- Simulation Run Complete ---\")\n    print(f\"Saved {len(game_results)} game logs to {os.path.join(save_dir, 'games_log.jsonl')}\")\n\n    # --- Optional: Compute and print aggregate metrics ---\n    # win_rates = compute_win_rate(game_results)\n    # avg_tokens = compute_average_tokens(game_results)\n    # avg_accuracy = compute_average_role_accuracy(game_results)\n    # print(\"\\nAggregate Metrics:\")\n    # print(f\"Win Rates: {win_rates}\")\n    # print(f\"Avg Tokens: {avg_tokens}\")\n    # print(f\"Avg Role Accuracy: {avg_accuracy}\")\n\n\n# Helper for loading config (placeholder)\ndef load_config_from_file(path: str) -> Dict:\n     print(f\"Warning: Config loading not implemented. Using defaults. Tried path: {path}\")\n     # Implement actual JSON/YAML loading here\n     return {}\n\n\n# Need log_game_summary, compute_* from evaluation module\n# Placeholder if not implemented yet\ndef log_game_summary(game_state): return {\"game_id\": game_state.game_id, \"winner\": game_state.winner.value if game_state.winner else None, \"final_roles\": game_state.final_player_roles}\n# def compute_win_rate(results): return {}\n# def compute_average_tokens(results): return {}\n# def compute_average_role_accuracy(results): return 0.0\n\n\nif __name__ == \"__main__\":\n    # Example of how to run\n    run_multiple_simulations(num_games=5, save_dir=\"output/sim_results\")\n",
  "__init__.py": "",
  "agents\\base.py": "from abc import ABC, abstractmethod\nfrom typing import Dict, Any\n\nclass BaseAgent(ABC):\n    def __init__(self, name: str):\n        self.name = name\n\n    @abstractmethod\n    def observe(self, observation: Dict[str, Any]):\n        \"\"\"Receive an observation from the environment.\"\"\"\n        pass\n\n    @abstractmethod\n    def act(self) -> Dict[str, Any]:\n        \"\"\"Produce an action dictionary in response to the last observation.\"\"\"\n        pass\n\n    def reset(self):\n        \"\"\"Reset internal memory/state if needed between games.\"\"\"\n        pass\n",
  "agents\\llm_agent.py": "from typing import Dict, Any\nimport json\nfrom mafia.agents.base import BaseAgent\n\nclass LLMAgent(BaseAgent):\n    def __init__(self, name, model_backend, tokenizer=None, config=None):\n        super().__init__(name)\n        self.model_backend = model_backend  # API or local callable\n        self.tokenizer = tokenizer\n        self.config = config or {}\n        self.last_obs = None\n\n    def observe(self, observation: Dict[str, Any]):\n        self.last_obs = observation\n\n    def act(self) -> Dict[str, Any]:\n        prompt = self.build_prompt(self.last_obs)\n        output = self.model_backend(prompt)\n        action = self.parse_action(output)\n        return action\n\n    def build_prompt(self, obs: Dict[str, Any]) -> str:\n        # Could be JSON, natural language, or both\n        return f\"<Observation>\\n{obs}\\n</Observation>\\n<Action>\"\n\n    def parse_action(self, response: str) -> Dict[str, Any]:\n        # Basic parsing with regex or structured JSON output\n        try:\n            return json.loads(response)\n        except:\n            return {\"action\": \"pass\"}\n",
  "agents\\rule_agent.py": "import random\nfrom typing import Dict, Any, Optional\nfrom mafia.agents.base_agent import BaseAgent\n\nclass RuleAgent(BaseAgent):\n    def __init__(self, name: str, role: Optional[str] = None, strategy: Optional[Dict[str, Any]] = None, seed: Optional[int] = None):\n        super().__init__(name)\n        self.role = role\n        self.strategy = strategy or {}\n        self.last_obs = None\n        self.rng = random.Random(seed)\n\n    def observe(self, observation: Dict[str, Any]):\n        self.last_obs = observation\n\n    def act(self) -> Dict[str, Any]:\n        if not self.last_obs:\n            return {\"action\": \"pass\"}\n\n        phase = self.last_obs[\"phase\"]\n        if phase == \"NIGHT\":\n            return self._night_action()\n        elif phase == \"DAY_DISCUSSION\":\n            return self._day_discussion_action()\n        elif phase == \"DEFENSE\":\n            return self._defense_action()\n        elif phase == \"FINAL_VOTE\":\n            return self._final_vote_action()\n        return {\"action\": \"pass\"}\n\n    def _night_action(self) -> Dict[str, Any]:\n        role = self.role.lower() if self.role else \"\"\n        targets = [p for p in self.last_obs[\"alive_players\"] if p != self.name]\n\n        if not targets:\n            return {\"action\": \"pass\"}\n\n        if role == \"cop\":\n            return {\"action\": \"investigate\", \"target\": self._choose_target(targets)}\n        if role == \"doctor\":\n            return {\"action\": \"protect\", \"target\": self.name}\n        if role == \"godfather\":\n            target = self._choose_target(targets)\n            if target in self.last_obs.get(\"faction_members\", []):\n                return {\"action\": \"pass\"}  # prevent killing mafia\n            return {\"action\": \"kill\", \"target\": target}\n        return {\"action\": \"pass\"}\n\n    def _day_discussion_action(self) -> Dict[str, Any]:\n        # Example: deterministic logic based on strategy\n        s = self.strategy\n\n        # Accuse if allowed\n        if not self.last_obs[\"player_on_trial\"] and not self.last_obs.get(\"has_accused_today\"):\n            if s.get(\"always_accuse\", False):\n                target = self._choose_target(self.last_obs[\"alive_players\"])\n                return {\"action\": \"accuse\", \"target\": target}\n\n        # Respond to questions\n        if self.last_obs.get(\"is_current_turn\"):\n            return {\"action\": \"speak\", \"content\": f\"{self.name} says something generic.\"}\n\n        return {\"action\": \"pass\"}\n\n    def _defense_action(self) -> Dict[str, Any]:\n        return {\"action\": \"speak\", \"content\": f\"{self.name} defends themselves with honor.\"}\n\n    def _final_vote_action(self) -> Dict[str, Any]:\n        s = self.strategy\n        if s.get(\"always_vote_guilty\"):\n            return {\"action\": \"vote\", \"vote_type\": \"final_guilty\"}\n        if s.get(\"always_vote_innocent\"):\n            return {\"action\": \"vote\", \"vote_type\": \"final_innocent\"}\n        return {\"action\": \"vote\", \"vote_type\": self.rng.choice([\"final_guilty\", \"final_innocent\"])}\n\n    def _choose_target(self, candidates: list[str]) -> str:\n        # Deterministic by sorting, or use seeded RNG\n        candidates = [p for p in candidates if p != self.name]\n        return self.rng.choice(candidates) if candidates else self.name\n",
  "agents\\__init__.py": "",
  "evaluation\\analysis.py": "# mafia/evaluation/analysis.py\nfrom typing import List, Dict\n\ndef log_game_summary(game_state) -> Dict:\n    \"\"\"\n    Logs key metrics and summary data from a completed game.\n    Returns a structured dictionary with faction, winners, predictions, etc.\n    \"\"\"\n    summary = {\n        \"game_id\": game_state.game_id,\n        \"winner\": game_state.winner,\n        \"day_count\": game_state.day_count,\n        \"players\": [],\n        \"predictions\": [],\n        \"votes\": [],\n        \"whispers\": [],\n        \"questions\": [],\n        \"accusations\": [],\n    }\n\n    for player in game_state.players:\n        summary[\"players\"].append({\n            \"name\": player.name,\n            \"role\": player.role.name,\n            \"faction\": player.faction.value,\n            \"alive\": player.alive,\n        })\n\n        for target, role in player.predicted_roles.items():\n            summary[\"predictions\"].append({\n                \"predictor\": player.name,\n                \"target\": target,\n                \"predicted_role\": role\n            })\n\n        if player.vote:\n            summary[\"votes\"].append({\n                \"voter\": player.name,\n                \"voted_for\": player.vote\n            })\n\n        for target, whisper_text in player.whispers_sent.items():\n            summary[\"whispers\"].append({\n                \"from\": player.name,\n                \"to\": target,\n                \"content\": whisper_text\n            })\n\n        for target, count in player.questions_asked.items():\n            summary[\"questions\"].append({\n                \"asker\": player.name,\n                \"target\": target,\n                \"times\": count\n            })\n\n        if player.has_accused:\n            summary[\"accusations\"].append(player.name)\n\n    return summary\n",
  "evaluation\\metrics.py": "# mafia/evaluation/metrics.py\nfrom collections import defaultdict\nfrom typing import Dict, List\n\n\ndef compute_win_rate(games: List[Dict]) -> Dict[str, float]:\n    \"\"\"\n    Returns the win rate for each faction based on finished games.\n    \"\"\"\n    results = defaultdict(int)\n    for game in games:\n        results[game[\"winner\"]] += 1\n    total = sum(results.values())\n    return {faction: wins / total for faction, wins in results.items()}\n\n\ndef compute_average_tokens(games: List[Dict]) -> Dict[str, float]:\n    \"\"\"\n    Returns the average number of tokens used by each agent across games.\n    \"\"\"\n    token_totals = defaultdict(int)\n    token_counts = defaultdict(int)\n    for game in games:\n        for agent, tokens in game[\"tokens\"].items():\n            token_totals[agent] += tokens.get(\"input\", 0) + tokens.get(\"output\", 0)\n            token_counts[agent] += 1\n    return {\n        agent: token_totals[agent] / token_counts[agent]\n        for agent in token_totals\n    }\n\n\ndef compute_average_role_accuracy(games: List[Dict]) -> float:\n    \"\"\"\n    Computes how often role predictions were correct.\n    \"\"\"\n    correct = 0\n    total = 0\n    for game in games:\n        for entry in game[\"hidden_log\"]:\n            if \"Predicted\" in entry[\"info\"]:\n                # Format: \"Predicted X as Y\"\n                parts = entry[\"info\"].split()\n                predicted_role = parts[-1]\n                target = parts[1]\n                actual_role = None\n                for player in game[\"players\"]:\n                    if player[\"name\"] == target:\n                        actual_role = player[\"role\"]\n                        break\n                if actual_role:\n                    total += 1\n                    if predicted_role == actual_role:\n                        correct += 1\n    return correct / total if total else 0.0\n",
  "mechanics\\messaging.py": "# mafia/mechanics/messaging.py\nfrom typing import Dict, List, Optional, Tuple\nfrom mafia.enums import Phase\n\nclass Message:\n    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):\n        self.sender = sender              # Who sent the message\n        self.content = content            # What was said (raw text or structured)\n        self.target = target              # If whispering or targeting another player\n        self.private = private            # Whisper if True, public otherwise\n\n    def render(self) -> str:\n        if self.private:\n            return f\"[WHISPER] {self.sender} \u2192 {self.target}: {self.content}\"\n        elif self.target:\n            return f\"{self.sender} \u2192 {self.target}: {self.content}\"\n        return f\"{self.sender}: {self.content}\"\n\n\nclass MessagingSystem:\n    def __init__(self):\n        self.history: List[Message] = []\n\n    def send_public(self, sender: str, content: str):\n        msg = Message(sender=sender, content=content)\n        self.history.append(msg)\n        return msg\n\n    def send_private(self, sender: str, recipient: str, content: str):\n        msg = Message(sender=sender, content=content, target=recipient, private=True)\n        self.history.append(msg)\n        return msg\n\n    def get_visible_messages(self, player_name: str, phase: Phase) -> List[str]:\n        visible = []\n        for msg in self.history:\n            if not msg.private:\n                visible.append(msg.render())\n            elif msg.private and (msg.sender == player_name or msg.target == player_name):\n                visible.append(msg.render())\n        return visible\n\n    def get_all_messages(self) -> List[str]:\n        return [msg.render() for msg in self.history]\n\n    def clear(self):\n        self.history.clear()\n\n    def get_log_data(self) -> List[Dict]:\n        return [{\n            \"sender\": msg.sender,\n            \"target\": msg.target,\n            \"private\": msg.private,\n            \"content\": msg.content\n        } for msg in self.history]\n",
  "mechanics\\roles.py": "# === mafia/mechanics/roles.py ===\n\nfrom abc import ABC, abstractmethod\nfrom mafia.enums import Faction\nfrom typing import Optional, TYPE_CHECKING, Dict, Any, List\n\n# Avoid circular import for type hinting\nif TYPE_CHECKING:\n    from mafia.player import Player\n    from mafia.game_state import GameState\n\nclass Role(ABC):\n    def __init__(self, name: str, faction: Faction):\n        self.name = name\n        self.faction = faction\n        # For now, we use faction as the alignment. Override if needed.\n        self.alignment = faction\n\n    @abstractmethod\n    def get_role_description(self) -> str:\n        \"\"\"Return a string describing the role's abilities and goals.\"\"\"\n        pass\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Executes the role's night action.\n        Target selection logic is handled by the agent/player.\n        Returns a dict representing the action taken, or None.\n        \"\"\"\n        return None  # Default: No night action\n\n    def can_act_at_night(self) -> bool:\n        \"\"\"Checks if the role has a meaningful night action.\"\"\"\n        return self.__class__.night_action != Role.night_action\n\n    def get_available_targets(self, player: 'Player', game_state: 'GameState') -> List[str]:\n        \"\"\"\n        Returns a list of valid target player names.\n        Default: any alive player except self.\n        Override to add additional filters.\n        \"\"\"\n        return [p.name for p in game_state.players if p.alive and p.name != player.name]\n\n    def win_condition_met(self, player: 'Player', game_state: 'GameState') -> Optional[bool]:\n        \"\"\"\n        Stub for roles with unique win conditions.\n        Returns True if the player's win condition is met,\n        False if failed, or None if undecided.\n        \"\"\"\n        return None  # Default: rely on faction win\n\n    def get_llm_schema(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns a dictionary with structured information about the role,\n        useful for prompting LLM-based agents.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"faction\": self.faction.value,\n            \"alignment\": self.alignment.value,\n            \"can_act_at_night\": str(self.can_act_at_night()),\n            \"description\": self.get_role_description()\n        }\n\n    def __repr__(self):\n        return f\"<{self.faction.value}:{self.name}>\"\n\n# ------------------- TOWN ROLES -------------------\n\nclass Villager(Role):\n    def __init__(self):\n        super().__init__(\"Villager\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are a Villager. You have no special abilities. Find and lynch the Mafia.\"\n\n    # Inherits default night_action (None)\n\nclass Cop(Role):\n    def __init__(self):\n        super().__init__(\"Cop\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia).\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        # Prevent self-investigation\n        if target_name == player.name:\n            player.log_hidden(game_state, \"You cannot investigate yourself.\")\n            return None\n\n        target_player = game_state.get_player(target_name) if target_name else None\n        if target_player and target_player.alive:\n            # Handle Godfather detection: if target is a Godfather and game config dictates, appear as Town\n            if isinstance(target_player.role, Godfather) and not game_state.game_config.get(\"godfather_detectable\", False):\n                result_faction = Faction.TOWN\n            else:\n                result_faction = target_player.role.faction\n\n            result_info = f\"Investigated {target_player.name}: Result {result_faction.value}\"\n            player.log_hidden(game_state, f\"\\uD83D\\uDD0E {result_info}\")\n            player.memory.append({\n                \"type\": \"investigation_result\",\n                \"day\": game_state.day_count,\n                \"target\": target_player.name,\n                \"result\": result_faction.value\n            })\n            return {\"type\": \"investigate\", \"target\": target_player.name, \"result\": result_faction.value}\n        elif target_name:\n            player.log_hidden(game_state, f\"\\uD83D\\uDD0E Tried to investigate {target_name}, but they were not found or dead.\")\n        return None\n\nclass Doctor(Role):\n    def __init__(self):\n        super().__init__(\"Doctor\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are the Doctor. Each night, you can choose one player to protect from death.\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        # Optionally, disallow self-protection based on configuration.\n        if target_name == player.name and not game_state.game_config.get(\"doctor_can_self_heal\", True):\n            player.log_hidden(game_state, \"You cannot protect yourself tonight.\")\n            return None\n\n        target_player = game_state.get_player(target_name) if target_name else None\n        if target_player and target_player.alive:\n            player.log_hidden(game_state, f\"\\uD83E\\uDE78 Protected {target_player.name}\")\n            return {\"type\": \"protect\", \"target\": target_player.name}\n        elif target_name:\n            player.log_hidden(game_state, f\"\\uD83E\\uDE78 Tried to protect {target_name}, but they were not found or dead.\")\n        return None\n\n# ------------------- MAFIA ROLES -------------------\n\nclass Goon(Role):\n    def __init__(self):\n        super().__init__(\"Goon\", Faction.MAFIA)\n\n    def get_role_description(self) -> str:\n        return \"You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day.\"\n\n    # Inherits default night_action (None)\n\nclass Godfather(Role):\n    def __init__(self):\n        super().__init__(\"Godfather\", Faction.MAFIA)\n        self.appears_as = Faction.TOWN  # To cops, unless detectable\n\n    def get_role_description(self) -> str:\n        return (\"You are the Godfather. You appear as Town to the Cop. \"\n                \"Each night, choose a target for the Mafia to kill. \"\n                \"If you die, a Goon will be promoted.\")\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        # Prevent self-targeting or targeting fellow Mafia\n        if target_name == player.name:\n            player.log_hidden(game_state, \"You cannot target yourself.\")\n            return None\n        target_player = game_state.get_player(target_name) if target_name else None\n        if target_player:\n            if target_player.faction == Faction.MAFIA:\n                player.log_hidden(game_state, \"You cannot order a kill on a fellow Mafia member.\")\n                return None\n        if target_player and target_player.alive:\n            player.log_hidden(game_state, f\"\\uD83D\\uDD2A Ordered kill on {target_player.name}\")\n            return {\"type\": \"kill\", \"target\": target_player.name}\n        elif target_name:\n            player.log_hidden(game_state, f\"\\uD83D\\uDD2A Tried to order kill on {target_name}, but they were not found or dead.\")\n        return None\n\n# ------------------- NEW ROLES -------------------\n\nclass RoleBlocker(Role):\n    def __init__(self):\n        super().__init__(\"RoleBlocker\", Faction.MAFIA)\n\n    def get_role_description(self) -> str:\n        return \"You are the RoleBlocker. Each night, you can block another player's action.\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        # Prevent blocking self\n        if target_name == player.name:\n            player.log_hidden(game_state, \"You cannot roleblock yourself.\")\n            return None\n        target_player = game_state.get_player(target_name) if target_name else None\n        if target_player and target_player.alive:\n            player.log_hidden(game_state, f\"Blocked {target_player.name}'s action\")\n            return {\"type\": \"roleblock\", \"target\": target_player.name}\n        elif target_name:\n            player.log_hidden(game_state, f\"Tried to block {target_name}, but they were not found or dead.\")\n        return None\n\nclass Consigliere(Role):\n    def __init__(self):\n        super().__init__(\"Consigliere\", Faction.MAFIA)\n\n    def get_role_description(self) -> str:\n        return \"You are the Consigliere. Each night, you may learn the exact role of one player.\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n        if target_player and target_player.alive:\n            role_name = target_player.role.name\n            player.log_hidden(game_state, f\"Investigated {target_player.name}: Role = {role_name}\")\n            player.memory.append({\n                \"type\": \"role_peek\",\n                \"day\": game_state.day_count,\n                \"target\": target_player.name,\n                \"role\": role_name\n            })\n            return {\"type\": \"consigliere_investigate\", \"target\": target_player.name, \"result\": role_name}\n        elif target_name:\n            player.log_hidden(game_state, f\"Tried to investigate {target_name}, but they were not found or dead.\")\n        return None\n\n# ------------------- OPTIONAL HELPER METHODS -------------------\n\n# These can be overridden by individual roles if needed.\n# For example, a role may override win_condition_met for unique victory conditions.\ndef default_win_condition(player: 'Player', game_state: 'GameState') -> Optional[bool]:\n    return None\n\n# ------------------- ROLE REGISTRY -------------------\n\nROLE_CLASS_MAP = {\n    \"villager\": Villager,\n    \"cop\": Cop,\n    \"doctor\": Doctor,\n    \"goon\": Goon,\n    \"godfather\": Godfather,\n    \"roleblocker\": RoleBlocker,\n    \"consigliere\": Consigliere,\n    # Add additional roles here...\n}\n\ndef get_role_class(role_name: str) -> Optional[type[Role]]:\n    return ROLE_CLASS_MAP.get(role_name.lower())\n",
  "mechanics\\voting.py": "# mafia/mechanics/voting.py\nfrom typing import Dict, Optional\nfrom mafia.enums import Phase\nfrom mafia.game_state import GameState\n\n\ndef cast_vote(game_state: GameState, voter: str, target: str) -> None:\n    \"\"\"Player casts or changes vote for someone.\"\"\"\n    if game_state.phase != Phase.DAY or voter not in game_state.alive_players:\n        return\n\n    # Remove old vote if it exists\n    if voter in game_state.voting_targets:\n        prev_target = game_state.voting_targets[voter]\n        if prev_target != target:\n            game_state.messages.append(f\"{voter} changed their vote from {prev_target} to {target}.\")\n    else:\n        game_state.messages.append(f\"{voter} has voted for {target}.\")\n\n    game_state.voting_targets[voter] = target\n    check_accusation_threshold(game_state)\n\n\ndef retract_vote(game_state: GameState, voter: str) -> None:\n    \"\"\"Player retracts their vote.\"\"\"\n    if voter in game_state.voting_targets:\n        prev = game_state.voting_targets.pop(voter)\n        game_state.messages.append(f\"{voter} retracted their vote on {prev}.\")\n\n\ndef check_accusation_threshold(game_state: GameState, threshold: float = 0.5) -> None:\n    \"\"\"Automatically trigger accusation if a player reaches vote threshold.\"\"\"\n    vote_counts: Dict[str, int] = {}\n    for target in game_state.voting_targets.values():\n        vote_counts[target] = vote_counts.get(target, 0) + 1\n\n    total_voters = len(game_state.alive_players)\n    for target, count in vote_counts.items():\n        if count / total_voters >= threshold and game_state.accused_player != target:\n            game_state.accused_player = target\n            game_state.messages.append(f\"{target} has been accused and must now defend themselves.\")\n\n\ndef confirm_lynch_vote(game_state: GameState, voter: str, confirm: bool) -> None:\n    \"\"\"Player confirms or denies the lynch after accusation.\"\"\"\n    if game_state.phase != Phase.DAY or not game_state.accused_player:\n        return\n\n    game_state.lynch_confirm_votes[voter] = confirm\n    yes_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if vote)\n    no_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if not vote)\n\n    total_voters = len(game_state.alive_players)\n    if yes_votes > total_voters // 2:\n        game_state.messages.append(f\"{game_state.accused_player} has been lynched by majority vote.\")\n        game_state.kill_player(game_state.accused_player)\n        game_state.reset_votes()\n    elif no_votes >= total_voters // 2:\n        game_state.messages.append(f\"{game_state.accused_player} has survived the vote.\")\n        game_state.reset_votes()\n\n\n# --------------------------\n# Whisper Mechanics\n# --------------------------\n\ndef whisper(game_state: GameState, sender: str, recipient: str, message: str) -> None:\n    \"\"\"Send a whisper from one player to another. Hidden from all other agents.\"\"\"\n    if sender not in game_state.alive_players or recipient not in game_state.alive_players:\n        return\n\n    # Track hidden message to sender and recipient\n    for player in game_state.players:\n        if player.name in {sender, recipient}:\n            player.log_hidden(game_state, f\"[WHISPER] {sender} \u2192 {recipient}: {message}\")\n        else:\n            player.log_hidden(game_state, f\"[WHISPER] {sender} \u2192 {recipient}: <hidden>\")\n\n    # Log public metadata\n    game_state.messages.append(f\"{sender} whispered to {recipient}.\")\n\n\n# --------------------------\n# Voting Visibility\n# --------------------------\n\ndef get_vote_visibility(game_state: GameState) -> Dict[str, str]:\n    \"\"\"Return a dict of current votes (publicly visible for now).\"\"\"\n    return {voter: target for voter, target in game_state.voting_targets.items()}\n",
  "mechanics\\__init__.py": "",
  "prompts\\mafia_template.py": "def format_prompt(name: str, obs: dict) -> str:\n    # Format as readable context for the agent\n    lines = [f\"Day {obs['day']} | Phase: {obs['phase']}\"]\n    lines.append(\"Alive: \" + \", \".join(obs[\"alive\"]))\n    lines.append(\"Dead: \" + \", \".join(obs[\"dead\"]))\n    lines.append(\"Messages:\")\n    lines.extend(obs[\"messages\"])\n    lines.append(\"What do you do next? Choose one action:\")\n    return \"\\n\".join(lines)\n\ndef parse_response(response: str) -> dict:\n    \"\"\"\n    Expects LLM to return something like:\n    <action> accuse </action> <target> Player3 </target>\n    \"\"\"\n    import re\n    act = re.search(r\"<action>(.*?)</action>\", response)\n    tgt = re.search(r\"<target>(.*?)</target>\", response)\n    return {\n        \"action\": act.group(1).strip().lower() if act else \"pass\",\n        \"target\": tgt.group(1).strip() if tgt else None\n    }\n",
  "utils\\token_cost.py": ""
}