{
  "config.py": "",
  "enums.py": "from enum import Enum\n\nclass Faction(Enum):\n    TOWN = \"town\"\n    MAFIA = \"mafia\"\n    NEUTRAL = \"neutral\" # Reserved for extensibility\n\nclass GamePhase(Enum):\n    NIGHT = \"night\"\n    DAY_DISCUSSION = \"day_discussion\"\n    VOTING = \"voting\"\n    DEFENSE = \"defense\" # Optional phase if accusation needs defense\n    FINAL_VOTE = \"final_vote\" # Optional phase for final lynch decision\n    GAME_OVER = \"game_over\"\n\nclass VoteType(Enum):\n    ACCUSATION = \"accusation\" # Initial vote during day\n    FINAL_GUILTY = \"final_guilty\" # Vote during final lynch\n    FINAL_INNOCENT = \"final_innocent\" # Vote during final lynch\n    SKIP = \"skip\" # Abstain from voting",
  "environment.py": "# mafia/environment.py\nfrom typing import Dict, List, Optional\nfrom mafia.game_state import GameState\nfrom mafia.player import Player\nfrom mafia.enums import Phase\nfrom mafia.rewards import compute_rewards\nfrom mafia.utils.token_cost import track_tokens\n\nclass MafiaEnvironment:\n    def __init__(self, players: List[Player]):\n        self.state = GameState(players=players)\n        self.state.initialize()\n\n    def step(self):\n        if self.state.phase == Phase.NIGHT:\n            self._resolve_night()\n            self._transition_to_day()\n        elif self.state.phase == Phase.DAY:\n            self._resolve_day()\n            self._transition_to_night()\n        return self._get_observations(), self.state.ended\n\n    def _resolve_night(self):\n        self.state.resolve_night_actions()\n\n    def _transition_to_day(self):\n        self.state.phase = Phase.DAY\n        self.state.day_count += 1\n        self.state.reset_votes()\n        self.state.reset_discussion_state()\n        for player in self.state.players:\n            player.reset_day_state()\n\n    def _resolve_day(self):\n        self._process_votes()\n\n    def _transition_to_night(self):\n        self.state.phase = Phase.NIGHT\n        for player in self.state.players:\n            player.reset_night_state()\n\n    def _process_votes(self):\n        votes = self.state.voting_targets\n        if not votes:\n            return\n        max_votes = max(votes.values())\n        candidates = [name for name, count in votes.items() if count == max_votes]\n        if len(candidates) == 1:\n            accused = candidates[0]\n            self.state.accused_player = accused\n            self._process_lynch(accused)\n\n    def _process_lynch(self, accused: str):\n        confirm_votes = list(self.state.lynch_confirm_votes.values())\n        if not confirm_votes:\n            return\n        if sum(confirm_votes) > len(confirm_votes) // 2:\n            self.state.kill_player(accused)\n            self.state.log_hidden(accused, f\"Lynched on Day {self.state.day_count}\")\n\n    def _get_observations(self) -> Dict[str, Dict]:\n        obs = {}\n        for player in self.state.players:\n            if player.alive:\n                obs[player.name] = {\n                    \"phase\": self.state.phase.name,\n                    \"day\": self.state.day_count,\n                    \"alive\": list(self.state.alive_players),\n                    \"dead\": list(self.state.dead_players),\n                    \"messages\": self.state.messages[-10:],\n                    \"can_speak\": player.can_speak(),\n                    \"accused\": self.state.accused_player,\n                    \"votes\": self.state.voting_targets,\n                    \"token_budget\": self.state.discussion_token_budgets.get(player.name, 0)\n                }\n        return obs\n\n    def act(self, name: str, action: str, target: Optional[str] = None, content: Optional[str] = None):\n        player = self.state.get_player(name)\n        if not player or not player.alive:\n            return False\n\n        success = False\n        if action == \"accuse\" and target:\n            success = player.accuse(target, self.state)\n        elif action == \"predict\" and target and content:\n            success = player.predict_role(target, content, self.state)\n        elif action == \"question\" and target and content:\n            success = player.question(target, content, self.state)\n        elif action == \"whisper\" and target and content:\n            success = player.whisper(target, content, self.state)\n        elif action == \"vote\" and target:\n            success = player.vote_for(target, self.state)\n\n        if success:\n            track_tokens(name, action, content)\n        return success\n\n    def apply_rewards(self):\n        compute_rewards(self.state)\n",
  "export.py": "# export.py\nimport os\nimport json\n\ndef collect_python_files(root_dir: str) -> dict:\n    file_structure = {}\n\n    for dirpath, _, filenames in os.walk(root_dir):\n        for file in filenames:\n            if file.endswith('.py'):\n                full_path = os.path.join(dirpath, file)\n                rel_path = os.path.relpath(full_path, root_dir)\n                with open(full_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                file_structure[rel_path] = content\n\n    return file_structure\n\ndef export_to_json(output_path=\"code_snapshot.json\", root=\"mafia\"):\n    all_files = collect_python_files(root)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        json.dump(all_files, f, indent=2)\n\ndef export_to_text(output_path=\"code_snapshot.txt\", root=\"mafia\"):\n    all_files = collect_python_files(root)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        for path, content in all_files.items():\n            f.write(f\"# === {path} ===\\n\")\n            f.write(content + \"\\n\\n\")\n\nif __name__ == \"__main__\":\n    export_to_json()\n    export_to_text()\n    print(\"\u2705 Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'\")\n",
  "game_state.py": "from dataclasses import dataclass, field\nfrom typing import List, Dict, Optional, Set, Any\n# Use correct imports based on unified role system\nfrom mafia.enums import GamePhase, Faction\nfrom mafia.player import Player\n# Import specific role classes only if needed for specific logic (like promotion)\nfrom mafia.mechanics.roles import Goon, Godfather, get_role_class # Added get_role_class\nimport uuid\n\n@dataclass\nclass GameState:\n    players: List[Player]\n    game_config: Dict[str, Any] = field(default_factory=dict) # For rules like godfather_detectable\n    phase: GamePhase = GamePhase.NIGHT\n    day_count: int = 0\n    turn_number_in_phase: int = 0 # Track turns within day/night\n    current_player_turn: Optional[str] = None # Whose turn it is to act\n\n    alive_players: Set[str] = field(default_factory=set)\n    dead_players: Set[str] = field(default_factory=set)\n\n    messages: List[Dict[str, Any]] = field(default_factory=list) # Store message dicts, not just strings\n    hidden_log: List[Dict[str, Any]] = field(default_factory=list)\n\n    # Day phase state\n    votes_for_accusation: Dict[str, str] = field(default_factory=dict) # voter -> target\n    accusation_counts: Dict[str, int] = field(default_factory=dict) # target -> count\n    player_on_trial: Optional[str] = None\n    votes_for_lynch: Dict[str, bool] = field(default_factory=dict) # voter -> guilty (True) or innocent (False)\n\n    # Discussion state\n    discussion_token_budgets: Dict[str, int] = field(default_factory=dict) # Optional\n\n    # Night phase state\n    # Stores chosen actions before resolution: player_name -> {\"action_type\": \"kill\", \"target\": \"PlayerB\", ...}\n    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n    # Stores resolved outcomes of actions: player_name -> {\"action_type\": \"investigate\", \"result\": \"mafia\", ...}\n    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n\n\n    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    game_over: bool = False\n    winner: Optional[Faction] = None # Store winning Faction enum\n    final_player_roles: Dict[str, str] = field(default_factory=dict) # player_name -> role_name\n\n    def initialize(self):\n        \"\"\"Called at game start to set up.\"\"\"\n        self.alive_players = {p.name for p in self.players}\n        self.dead_players = set()\n        self.day_count = 0\n        self.phase = GamePhase.NIGHT # Start at night\n        self.game_over = False\n        self.winner = None\n        self.messages.clear()\n        self.hidden_log.clear()\n        self.final_player_roles.clear()\n\n        # Initialize player states\n        for player in self.players:\n            player.reset_for_new_game()\n            # Set initial token budgets based on config if needed\n            # self.discussion_token_budgets[player.name] = self.game_config.get(\"initial_tokens\", 0)\n\n        self.log_message(\"system\", \"Game started.\")\n        self.log_hidden(\"system\", f\"Game ID: {self.game_id}\")\n        self.log_hidden(\"system\", f\"Initial Roles: { {p.name: p.role.name for p in self.players} }\")\n\n\n    def get_player(self, name: str) -> Optional[Player]:\n        for p in self.players:\n            if p.name == name:\n                return p\n        return None\n\n    def is_alive(self, name: str) -> bool:\n        return name in self.alive_players\n\n    def kill_player(self, name: str, reason: str = \"killed\"):\n        \"\"\"Marks a player as dead and handles consequences like GF promotion.\"\"\"\n        if name not in self.alive_players:\n            return # Already dead or invalid\n\n        player = self.get_player(name)\n        if not player: return # Should not happen\n\n        self.alive_players.discard(name)\n        self.dead_players.add(name)\n        player.alive = False\n        self.log_message(\"system\", f\"{name} ({player.role.name}) has died ({reason}).\")\n        self.log_hidden(\"system\", f\"{name} died. Reason: {reason}\")\n\n        # Check for Godfather death and promote a Goon\n        if isinstance(player.role, Godfather):\n            # Find the first alive Goon to promote\n            promoted_goon: Optional[Player] = None\n            for p in self.players:\n                 # Check using isinstance and ensure they are alive\n                if p.name in self.alive_players and isinstance(p.role, Goon):\n                    promoted_goon = p\n                    break\n\n            if promoted_goon:\n                # Change the role object of the promoted player\n                new_role = Godfather()\n                promoted_goon.role = new_role\n                promoted_goon.faction = new_role.faction # Ensure faction is updated if needed\n                msg = f\"{promoted_goon.name} has been promoted to Godfather!\"\n                self.log_message(\"system\", msg)\n                self.log_hidden(promoted_goon.name, f\"Promoted to Godfather after {name}'s death\")\n            else:\n                 self.log_hidden(\"system\", f\"Godfather {name} died, but no Goons available to promote.\")\n\n        # Check for game end after death\n        self.check_game_end()\n\n\n    def reset_night_phase_state(self):\n        self.night_actions_submitted.clear()\n        self.night_action_results.clear()\n        self.turn_number_in_phase = 0\n        self.current_player_turn = None\n        for p_name in self.alive_players:\n            player = self.get_player(p_name)\n            if player: player.reset_night_state()\n\n\n    def reset_day_phase_state(self):\n        self.votes_for_accusation.clear()\n        self.accusation_counts.clear()\n        self.player_on_trial = None\n        self.votes_for_lynch.clear()\n        self.turn_number_in_phase = 0\n        self.current_player_turn = None # Or set to first speaker\n        for p_name in self.alive_players:\n            player = self.get_player(p_name)\n            if player: player.reset_day_state()\n\n    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):\n        \"\"\"Updates accusation counts when a vote changes.\"\"\"\n        if old_target and old_target in self.accusation_counts:\n            self.accusation_counts[old_target] -= 1\n            if self.accusation_counts[old_target] <= 0:\n                del self.accusation_counts[old_target]\n\n        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1\n        self.votes_for_accusation[voter] = new_target\n\n\n    def register_night_action(self, actor_name: str, action: Dict[str, Any]):\n        \"\"\"Stores the intended night action from a player.\"\"\"\n        if not self.is_alive(actor_name): return\n        self.night_actions_submitted[actor_name] = action\n        self.log_hidden(actor_name, f\"Submitted night action: {action}\")\n\n    # resolve_night_actions is now primarily handled by the Environment\n\n    def check_game_end(self) -> bool:\n        \"\"\"Checks if a win condition has been met.\"\"\"\n        if self.game_over: return True # Already ended\n\n        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}\n        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}\n        # Add other factions (Neutral) if they exist\n\n        winner = None\n        if not mafia_alive:\n            winner = Faction.TOWN # Town wins if all Mafia are dead\n        elif len(mafia_alive) >= len(town_alive):\n            # Mafia wins if they equal or outnumber Town (or if only Mafia remain)\n            winner = Faction.MAFIA\n\n        # Add neutral win conditions here if applicable\n\n        if winner:\n            self.game_over = True\n            self.winner = winner\n            self.phase = GamePhase.GAME_OVER\n            self.log_message(\"system\", f\"Game Over! Winner: {winner.value.upper()}\")\n            self.final_player_roles = {p.name: p.role.name for p in self.players}\n            self.log_hidden(\"system\", f\"Final Roles: {self.final_player_roles}\")\n            return True\n\n        return False\n\n    def log_message(self, sender: str, content: str, recipients: Optional[List[str]] = None):\n        \"\"\"Logs a message to the public game log.\"\"\"\n        # Recipients = None means public message\n        msg = {\"sender\": sender, \"content\": content, \"recipients\": recipients, \"phase\": self.phase, \"day\": self.day_count}\n        self.messages.append(msg)\n\n    def log_hidden(self, actor: str, info: str):\n        \"\"\"Logs information relevant to a specific actor or system process.\"\"\"\n        log_entry = {\n            \"actor\": actor,\n            \"info\": info,\n            \"phase\": self.phase,\n            \"day\": self.day_count,\n            \"turn\": self.turn_number_in_phase\n        }\n        self.hidden_log.append(log_entry)\n\n    def get_player_observation(self, player_name: str) -> Dict[str, Any]:\n         \"\"\"Generates the observation dictionary for a specific player.\"\"\"\n         player = self.get_player(player_name)\n         if not player or not player.alive:\n             return {} # Or return a specific \"you are dead\" state\n\n         # Filter messages visible to this player\n         visible_messages = []\n         for msg in self.messages:\n             # Public messages or whispers sent to/by the player\n             is_recipient = msg[\"recipients\"] is None or player_name in msg[\"recipients\"]\n             is_sender = msg[\"sender\"] == player_name and msg[\"recipients\"] is not None # Show own whispers\n             if is_recipient or is_sender:\n                 # Maybe format message differently if whisper?\n                 if msg[\"recipients\"] and len(msg[\"recipients\"]) == 1 and is_recipient and not is_sender:\n                     formatted_content = f\"(Whisper from {msg['sender']}): {msg['content']}\"\n                 elif is_sender:\n                     formatted_content = f\"(Whisper to {msg['recipients'][0]}): {msg['content']}\"\n                 else:\n                      formatted_content = f\"{msg['sender']}: {msg['content']}\"\n                 visible_messages.append(formatted_content)\n\n         # Include relevant game state info\n         obs = {\n             \"game_id\": self.game_id,\n             \"player_name\": player.name,\n             \"role\": player.role.name,\n             \"role_description\": player.role.get_role_description(),\n             \"faction\": player.faction.value,\n             \"phase\": self.phase.name,\n             \"day\": self.day_count,\n             \"turn\": self.turn_number_in_phase,\n             \"is_current_turn\": self.current_player_turn == player.name,\n             \"alive_players\": sorted(list(self.alive_players)),\n             \"dead_players\": sorted(list(self.dead_players)),\n             # Provide recent messages\n             \"messages\": visible_messages[-20:], # Limit history size\n             \"can_speak\": player.can_speak(),\n             \"can_act_tonight\": player.can_act_at_night() and self.phase == GamePhase.NIGHT,\n             \"player_on_trial\": self.player_on_trial,\n             \"votes_for_accusation\": self.votes_for_accusation, # {voter: target}\n             \"accusation_counts\": self.accusation_counts,     # {target: count}\n             # \"token_budget\": self.discussion_token_budgets.get(player.name, 0), # If using tokens\n             \"memory\": player.memory, # Include cop results, etc.\n             \"is_roleblocked\": player.is_roleblocked, # Let player know if blocked last night\n             \"protected_by\": player.protected_by, # Let player know if protected last night\n         }\n         return obs",
  "player.py": "from typing import Optional, Dict, List, Any\n# Import the base Role class and Faction enum\nfrom mafia.mechanics.roles import Role\nfrom mafia.enums import Faction\n# Import GameState for type hinting only to avoid circular dependency\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from mafia.game_state import GameState\n\n\nclass Player:\n    # Role hint uses the class, not the enum\n    def __init__(self, name: str, role: Role):\n        self.name: str = name\n        self.role: Role = role\n        # Faction comes directly from the role object\n        self.faction: Faction = self.role.faction\n        self.alive: bool = True\n\n        # Night action state\n        self.night_target: Optional[str] = None # Who the player chose to target\n        self.is_roleblocked: bool = False\n        self.protected_by: Optional[str] = None # Who protected this player (e.g., Doctor's name)\n\n        # Day state\n        self.vote: Optional[str] = None\n        self.discussion_tokens: int = 0 # Handled by environment/config\n        self.can_speak_today: bool = True # For effects like Blackmailer\n\n        # Action tracking & Memory\n        self.has_accused_today: bool = False\n        self.predictions: Dict[str, str] = {} # target_name -> predicted_role_name\n        self.questions_asked_today: Dict[str, int] = {} # target_name -> count\n        self.whispers_sent_today: Dict[str, str] = {} # target_name -> last_whisper_content\n        # Memory for roles like Cop\n        self.memory: List[Dict[str, Any]] = []\n\n    def reset_for_new_game(self):\n        \"\"\"Resets player state for the start of a new game.\"\"\"\n        self.alive = True\n        self.reset_night_state()\n        self.reset_day_state()\n        self.memory.clear()\n        self.predictions.clear()\n        # Role is assigned at init, faction derives from it\n\n    def reset_night_state(self):\n        \"\"\"Resets state relevant to the night phase.\"\"\"\n        self.night_target = None\n        self.is_roleblocked = False\n        self.protected_by = None\n\n    def reset_day_state(self):\n        \"\"\"Resets state relevant to the day phase.\"\"\"\n        self.vote = None\n        # discussion_tokens might be reset by environment based on config\n        self.has_accused_today = False\n        self.questions_asked_today.clear()\n        self.whispers_sent_today.clear()\n        self.can_speak_today = True # Reset blacklist effect\n\n    def can_act_at_night(self) -> bool:\n        \"\"\"Check if player is alive and their role has a night action.\"\"\"\n        return self.alive and self.role.can_act_at_night()\n\n    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Performs the player's role-specific night action.\n        Assumes self.night_target has been set by the agent.\n        Returns the action dict or None.\n        \"\"\"\n        if not self.can_act_at_night() or self.is_roleblocked:\n            if self.is_roleblocked:\n                 self.log_hidden(game_state, \"Tried to act but was roleblocked.\")\n            return None\n        # Pass the chosen target to the role's action method\n        return self.role.night_action(self, game_state, self.night_target)\n\n    def can_speak(self) -> bool:\n        # Add check for blacklist/mute effects\n        return self.alive and self.can_speak_today # Add token check if using budgets: and self.discussion_tokens > 0\n\n    # --- Day Actions ---\n    # Note: These methods now mostly validate and log,\n    # the core logic resides in the Environment or GameState update methods.\n\n    def accuse(self, target: str, game_state: 'GameState'):\n        if not self.can_speak() or self.has_accused_today:\n            self.log_hidden(game_state, f\"Attempted to accuse {target} but couldn't (already accused or cannot speak).\")\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to accuse {target} but they are dead or invalid.\")\n            return False\n\n        # Logic to handle accusation (e.g., trigger voting phase) should be in Environment/GameState\n        self.log_hidden(game_state, f\"Accused {target}\")\n        game_state.messages.append(f\"{self.name} accuses {target}!\")\n        self.has_accused_today = True # Limit accusations if desired\n        return True\n\n    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState'):\n        # Prediction is mainly for agent's internal state or analysis\n        if not self.alive: return False\n        target_player = game_state.get_player(target)\n        if not target_player: return False # Predict only existing players\n\n        self.predictions[target] = predicted_role_name\n        self.log_hidden(game_state, f\"Predicted {target} as {predicted_role_name}\")\n        # Optional: Public message? game_state.messages.append(f\"{self.name} predicts {target} is a {predicted_role_name}.\")\n        return True\n\n    def question(self, target: str, question_text: str, game_state: 'GameState'):\n        if not self.can_speak():\n             self.log_hidden(game_state, f\"Attempted to question {target} but cannot speak.\")\n             return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to question {target} but they are dead or invalid.\")\n            return False\n\n        # Actual questioning/response logic handled by environment turn manager + agents\n        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1\n        # self.discussion_tokens -= 1 # Decrement if using token budgets\n        self.log_hidden(game_state, f\"Asked {target}: {question_text}\")\n        game_state.messages.append(f\"{self.name} asks {target}: \\\"{question_text}\\\"\")\n        return True\n\n    def whisper(self, target: str, whisper_text: str, game_state: 'GameState'):\n        # Whispering might have specific rules (e.g., only Mafia, limits)\n        if not self.alive: return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to whisper {target} but they are dead or invalid.\")\n            return False\n\n        # Check game rules for whisper permissions if needed\n        # e.g., if self.faction != Faction.MAFIA and not game_state.config.allow_all_whispers: return False\n\n        self.whispers_sent_today[target] = whisper_text\n        self.log_hidden(game_state, f\"Whispered to {target}: {whisper_text}\")\n        # Add to messages, but potentially filtered based on recipient\n        # Using a dedicated messaging system is better here. Assume game_state.messages is public for now.\n        game_state.messages.append(f\"[WHISPER] {self.name} to {target}\") # Content hidden in public log\n        # Need a way for target agent to see the whisper content in their observation\n        return True\n\n    def vote_for(self, target: str, game_state: 'GameState'):\n        if not self.alive: return False\n        # Allow voting for dead players? Assume no for now.\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n             self.log_hidden(game_state, f\"Attempted to vote for {target} but they are dead or invalid.\")\n             return False\n\n        # Actual vote tallying happens in GameState/Environment\n        old_vote = self.vote\n        self.vote = target\n        if old_vote and old_vote != target:\n            log_msg = f\"Changed vote from {old_vote} to {target}\"\n            public_msg = f\"{self.name} changed vote to {target}.\"\n        elif not old_vote:\n            log_msg = f\"Voted for {target}\"\n            public_msg = f\"{self.name} voted for {target}.\"\n        else: # Voted for same person again\n            return True # No change needed\n\n        self.log_hidden(game_state, log_msg)\n        game_state.messages.append(public_msg)\n        # Signal environment to update vote counts\n        game_state.update_vote_counts(self.name, old_vote, target)\n        return True\n\n    def log_hidden(self, game_state: 'GameState', info: str):\n        \"\"\"Logs information to the game's hidden log associated with this player.\"\"\"\n        # Ensure game_state has this method or handle logging directly\n        game_state.log_hidden(self.name, info)\n\n\n    def __repr__(self):\n        status = 'Dead' if not self.alive else 'Alive'\n        return f\"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>\"\n",
  "rewards.py": "# mafia/rewards.py\nfrom typing import Dict\nfrom mafia.enums import Faction\n\n\ndef assign_endgame_rewards(game_state) -> Dict[str, float]:\n    \"\"\"\n    Assign final rewards to agents based on game outcome.\n    Town agents get +1 for town win, -1 otherwise. Same for mafia.\n    \"\"\"\n    rewards = {}\n    for player in game_state.players:\n        if player.faction.value == game_state.winner:\n            rewards[player.name] = 1.0\n        else:\n            rewards[player.name] = -1.0\n    return rewards\n\n\ndef assign_predict_role_reward(predicted: str, actual: str) -> float:\n    return 0.5 if predicted == actual else -0.25\n\n\ndef assign_vote_reward(voter, target, game_state) -> float:\n    \"\"\"\n    +1 if town correctly votes out mafia\n    -1 if town votes town\n    +0.5 if mafia avoids being voted\n    \"\"\"\n    if not game_state.is_alive(target):  # Lynched\n        if voter.faction == Faction.TOWN:\n            if game_state.get_player(target).faction == Faction.MAFIA:\n                return 1.0\n            else:\n                return -1.0\n        elif voter.faction == Faction.MAFIA:\n            if game_state.get_player(target).faction == Faction.MAFIA:\n                return -1.0\n            else:\n                return 0.5\n    return 0.0\n\n\ndef assign_speaking_reward(agent_name: str, token_used: int) -> float:\n    \"\"\"\n    Optional: Reward for verbosity, or penalize excess verbosity.\n    For now, neutral. Could be tuned.\n    \"\"\"\n    return 0.0\n\n\ndef assign_question_reward(asker, target, game_state) -> float:\n    \"\"\"\n    +0.2 for engaging others; could scale if target is mafia and asker is town\n    \"\"\"\n    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:\n        return 0.4\n    return 0.2\n",
  "simulation.py": "import os\nimport json\nfrom tqdm import tqdm\n# Use correct Environment class name\nfrom mafia.environment import MafiaEnvironment\n# Import role classes and helper\nfrom mafia.mechanics.roles import get_role_class, Role\nfrom mafia.player import Player\n# Keep TokenTracker import, assume it exists or create dummy\n# from mafia.utils.token_cost import TokenTracker # If using\n# Import agent classes\nfrom mafia.agents.rule_agent import RuleBasedAgent # Assuming this will exist\nfrom mafia.agents.llm_agent import LLMAPIClientAgent # Import the LLM agent\nfrom typing import Dict, List\nimport uuid\n\n# Dummy Token Tracker if needed\nclass TokenTracker:\n    def __init__(self): self.usage = {}\n    def update(self, *args, **kwargs): pass\n    def to_dict(self): return self.usage\n\ndef create_players_from_config(config: Dict) -> List[Player]:\n    \"\"\"Creates Player objects based on a configuration dictionary.\"\"\"\n    players = []\n    roles_config = config.get(\"roles\", []) # e.g., [{\"name\": \"Player1\", \"role\": \"Cop\"}, ...]\n    if not roles_config: # Fallback to default if config is empty/missing roles\n        roles_setup = [\n            (\"Player1\", \"Cop\"), (\"Player2\", \"Doctor\"), (\"Player3\", \"Villager\"),\n            (\"Player4\", \"Godfather\"), (\"Player5\", \"Goon\")\n        ]\n        print(\"Warning: Using default 5-player role setup.\")\n    else:\n        roles_setup = [(p_cfg[\"name\"], p_cfg[\"role\"]) for p_cfg in roles_config]\n\n    for name, role_name in roles_setup:\n        RoleClass = get_role_class(role_name)\n        if not RoleClass:\n             raise ValueError(f\"Unknown role name '{role_name}' in configuration.\")\n        role_instance = RoleClass()\n        player = Player(name=name, role=role_instance)\n\n        # --- Agent Assignment ---\n        # Example: Assign agents based on config or default to RuleBased\n        agent_type = config.get(\"agent_mapping\", {}).get(name, \"rule\") # Default to rule-based\n\n        if agent_type.lower() == \"llm\":\n            # TODO: Get model name, system prompt from config\n            model_name = config.get(\"llm_config\", {}).get(\"model\", \"gpt-4\") # Example default\n            system_prompt_key = config.get(\"llm_config\", {}).get(\"system_prompt_key\", \"default_mafia\")\n            # Need a way to load system prompts based on key\n            system_prompt = f\"You are {name}, playing Mafia as {role_instance.name}. {role_instance.get_role_description()}\" # Basic example\n            agent = LLMAPIClientAgent(name=name, model=model_name, system_prompt=system_prompt)\n            print(f\"Assigning LLM Agent ({model_name}) to {name}\")\n        else: # Default to RuleBasedAgent\n             # RuleBasedAgent needs to be implemented\n            agent = RuleBasedAgent(name=name, player_role=role_instance.name)\n            print(f\"Assigning Rule Agent to {name}\")\n\n        # Link agent to player (though environment might manage this)\n        player.agent = agent # Store agent reference if needed directly by player, otherwise managed by env/runner\n        players.append(player)\n\n    return players\n\n\ndef run_simulation(game_config: Dict, agent_config: Dict) -> Dict:\n    \"\"\"Runs a single game simulation and returns the final state.\"\"\"\n    print(f\"\\n--- Starting Simulation Game ID: {game_config.get('game_id', 'N/A')} ---\")\n\n    # Combine configs or pass separately\n    full_config = {**game_config, \"agents\": agent_config} # Example merge\n\n    # Create players based on combined config\n    players = create_players_from_config(full_config) # Pass merged config\n\n    # Initialize environment\n    # Pass game_config to environment if it needs rules like GF detectability\n    env = MafiaEnvironment(players=players, config=full_config)\n    token_tracker = TokenTracker() # Initialize token tracker if used\n\n    # --- Game Loop ---\n    max_steps = full_config.get(\"max_steps\", 100) # Limit game length\n    step_count = 0\n    while not env.state.game_over and step_count < max_steps:\n        step_count += 1\n        print(f\"\\n=== Day {env.state.day_count} | Phase: {env.state.phase.name} | Turn: {env.state.turn_number_in_phase} ===\")\n        current_player_name = env.get_current_player_name() # Needs implementation in Env\n\n        if not current_player_name:\n            # Environment handles transition or phase resolution automatically\n             print(\"Environment resolving phase...\")\n             env.step_phase() # Needs implementation in Env\n             continue # Go to next loop iteration to check game state\n\n        player = env.state.get_player(current_player_name)\n        if not player or not player.alive:\n             print(f\"Skipping turn for {current_player_name} (dead or invalid).\")\n             env.advance_turn() # Needs implementation in Env\n             continue\n\n        agent = player.agent # Get agent associated with the player\n\n        # Get observation for the current player\n        observation = env.get_observation(current_player_name) # Needs implementation in Env\n\n        # Agent decides action\n        print(f\"--- {current_player_name}'s Turn ({agent.__class__.__name__}) ---\")\n        action = agent.act(observation) # Agent returns action dict\n        print(f\"Action chosen: {action}\")\n\n        # Environment processes action\n        success = env.process_player_action(current_player_name, action) # Needs implementation in Env\n        if not success:\n            print(f\"Action {action} failed or was invalid.\")\n\n        # Optional: Track tokens\n        # token_tracker.update(current_player_name, observation, action)\n\n        # Environment potentially advances turn or phase based on action\n        # This might happen inside process_player_action or require a separate env.advance() call\n\n    print(f\"\\n--- Game Over ---\")\n    print(f\"Winner: {env.state.winner.value if env.state.winner else 'Draw/Timeout'}\")\n    print(f\"Ended on Day {env.state.day_count}, Phase {env.state.phase.name}\")\n\n    # Log final state and return results\n    final_state_summary = log_game_summary(env.state) # Use analysis function\n    final_state_summary[\"tokens_used\"] = token_tracker.to_dict() # Add token info if tracked\n    return final_state_summary\n\n\ndef run_multiple_simulations(num_games=10, config_path=\"config/default_game.json\", save_dir=\"data/episodes\"):\n    \"\"\"Runs multiple simulations based on a config file.\"\"\"\n    os.makedirs(save_dir, exist_ok=True)\n\n    # Load base configuration (needs implementation)\n    # base_game_config = load_config_from_file(config_path)\n    # base_agent_config = base_game_config.get(\"agent_config\", {}) # Separate agent config if needed\n    base_game_config = {\"roles\": [ # Example default config\n             {\"name\": \"Player1\", \"role\": \"Cop\"}, {\"name\": \"Player2\", \"role\": \"Doctor\"},\n             {\"name\": \"Player3\", \"role\": \"Villager\"}, {\"name\": \"Player4\", \"role\": \"Godfather\"},\n             {\"name\": \"Player5\", \"role\": \"Goon\"}\n         ],\n        \"agent_mapping\": {\"Player1\": \"llm\", \"Player4\": \"llm\"}, # P1 & P4 are LLMs\n        \"llm_config\": {\"model\": \"gpt-3.5-turbo\"} # Example LLM config\n     }\n    base_agent_config = {} # Agent specific settings if needed\n\n\n    game_results = []\n    for i in tqdm(range(num_games), desc=\"Simulating Games\"):\n        game_id = str(uuid.uuid4())\n        current_game_config = {**base_game_config, \"game_id\": game_id}\n        # Add variations here if doing experiments (e.g., change roles, prompts)\n\n        try:\n            result = run_simulation(current_game_config, base_agent_config)\n            game_results.append(result)\n\n            # Save individual game logs as JSONL\n            log_path = os.path.join(save_dir, \"games_log.jsonl\")\n            with open(log_path, \"a\") as f:\n                json.dump(result, f)\n                f.write(\"\\n\")\n\n        except Exception as e:\n            print(f\"\\n!!!!!! Error during simulation {game_id} !!!!!!\")\n            print(f\"Error: {e}\")\n            # Log error state if possible\n            error_info = {\"game_id\": game_id, \"status\": \"error\", \"error_message\": str(e)}\n            log_path = os.path.join(save_dir, \"games_log.jsonl\")\n            with open(log_path, \"a\") as f:\n                json.dump(error_info, f)\n                f.write(\"\\n\")\n\n\n    print(f\"\\n--- Simulation Run Complete ---\")\n    print(f\"Saved {len(game_results)} game logs to {os.path.join(save_dir, 'games_log.jsonl')}\")\n\n    # --- Optional: Compute and print aggregate metrics ---\n    # win_rates = compute_win_rate(game_results)\n    # avg_tokens = compute_average_tokens(game_results)\n    # avg_accuracy = compute_average_role_accuracy(game_results)\n    # print(\"\\nAggregate Metrics:\")\n    # print(f\"Win Rates: {win_rates}\")\n    # print(f\"Avg Tokens: {avg_tokens}\")\n    # print(f\"Avg Role Accuracy: {avg_accuracy}\")\n\n\n# Helper for loading config (placeholder)\ndef load_config_from_file(path: str) -> Dict:\n     print(f\"Warning: Config loading not implemented. Using defaults. Tried path: {path}\")\n     # Implement actual JSON/YAML loading here\n     return {}\n\n\n# Need log_game_summary, compute_* from evaluation module\n# Placeholder if not implemented yet\ndef log_game_summary(game_state): return {\"game_id\": game_state.game_id, \"winner\": game_state.winner.value if game_state.winner else None, \"final_roles\": game_state.final_player_roles}\n# def compute_win_rate(results): return {}\n# def compute_average_tokens(results): return {}\n# def compute_average_role_accuracy(results): return 0.0\n\n\nif __name__ == \"__main__\":\n    # Example of how to run\n    run_multiple_simulations(num_games=5, save_dir=\"output/sim_results\")\n",
  "__init__.py": "",
  "agents\\base.py": "# mafia/agents/base.py\nfrom abc import ABC, abstractmethod\n\nclass BaseAgent(ABC):\n    def __init__(self, name: str):\n        self.name = name\n\n    @abstractmethod\n    def act(self, observation: dict) -> dict:\n        \"\"\"\n        Returns an action dict like {\"action\": \"accuse\", \"target\": \"Player3\"}\n        \"\"\"\n        pass\n",
  "agents\\llm_agent.py": "# mafia/agents/llm_agent.py\nimport os\nimport openai\nfrom mafia.agents.base import BaseAgent\nfrom mafia.prompts.mafia_template import format_prompt, parse_response\n\nclass LLMAPIClientAgent(BaseAgent):\n    def __init__(self, name: str, model: str = \"gpt-4\", system_prompt: str = None):\n        super().__init__(name)\n        self.model = model\n        self.system_prompt = system_prompt or \"You are playing the game Mafia. Reason carefully.\"\n        self.client = openai.ChatCompletion  # Can be monkey-patched for DeepSeek etc.\n\n    def act(self, observation: dict) -> dict:\n        prompt = format_prompt(self.name, observation)\n        messages = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        response = self.client.create(\n            model=self.model,\n            messages=messages,\n            temperature=0.7,\n        )\n        raw = response.choices[0].message.content.strip()\n        return parse_response(raw)\n",
  "agents\\rule_agent.py": "",
  "agents\\__init__.py": "",
  "evaluation\\analysis.py": "# mafia/evaluation/analysis.py\nfrom typing import List, Dict\n\ndef log_game_summary(game_state) -> Dict:\n    \"\"\"\n    Logs key metrics and summary data from a completed game.\n    Returns a structured dictionary with faction, winners, predictions, etc.\n    \"\"\"\n    summary = {\n        \"game_id\": game_state.game_id,\n        \"winner\": game_state.winner,\n        \"day_count\": game_state.day_count,\n        \"players\": [],\n        \"predictions\": [],\n        \"votes\": [],\n        \"whispers\": [],\n        \"questions\": [],\n        \"accusations\": [],\n    }\n\n    for player in game_state.players:\n        summary[\"players\"].append({\n            \"name\": player.name,\n            \"role\": player.role.name,\n            \"faction\": player.faction.value,\n            \"alive\": player.alive,\n        })\n\n        for target, role in player.predicted_roles.items():\n            summary[\"predictions\"].append({\n                \"predictor\": player.name,\n                \"target\": target,\n                \"predicted_role\": role\n            })\n\n        if player.vote:\n            summary[\"votes\"].append({\n                \"voter\": player.name,\n                \"voted_for\": player.vote\n            })\n\n        for target, whisper_text in player.whispers_sent.items():\n            summary[\"whispers\"].append({\n                \"from\": player.name,\n                \"to\": target,\n                \"content\": whisper_text\n            })\n\n        for target, count in player.questions_asked.items():\n            summary[\"questions\"].append({\n                \"asker\": player.name,\n                \"target\": target,\n                \"times\": count\n            })\n\n        if player.has_accused:\n            summary[\"accusations\"].append(player.name)\n\n    return summary\n",
  "evaluation\\metrics.py": "# mafia/evaluation/metrics.py\nfrom collections import defaultdict\nfrom typing import Dict, List\n\n\ndef compute_win_rate(games: List[Dict]) -> Dict[str, float]:\n    \"\"\"\n    Returns the win rate for each faction based on finished games.\n    \"\"\"\n    results = defaultdict(int)\n    for game in games:\n        results[game[\"winner\"]] += 1\n    total = sum(results.values())\n    return {faction: wins / total for faction, wins in results.items()}\n\n\ndef compute_average_tokens(games: List[Dict]) -> Dict[str, float]:\n    \"\"\"\n    Returns the average number of tokens used by each agent across games.\n    \"\"\"\n    token_totals = defaultdict(int)\n    token_counts = defaultdict(int)\n    for game in games:\n        for agent, tokens in game[\"tokens\"].items():\n            token_totals[agent] += tokens.get(\"input\", 0) + tokens.get(\"output\", 0)\n            token_counts[agent] += 1\n    return {\n        agent: token_totals[agent] / token_counts[agent]\n        for agent in token_totals\n    }\n\n\ndef compute_average_role_accuracy(games: List[Dict]) -> float:\n    \"\"\"\n    Computes how often role predictions were correct.\n    \"\"\"\n    correct = 0\n    total = 0\n    for game in games:\n        for entry in game[\"hidden_log\"]:\n            if \"Predicted\" in entry[\"info\"]:\n                # Format: \"Predicted X as Y\"\n                parts = entry[\"info\"].split()\n                predicted_role = parts[-1]\n                target = parts[1]\n                actual_role = None\n                for player in game[\"players\"]:\n                    if player[\"name\"] == target:\n                        actual_role = player[\"role\"]\n                        break\n                if actual_role:\n                    total += 1\n                    if predicted_role == actual_role:\n                        correct += 1\n    return correct / total if total else 0.0\n",
  "mechanics\\messaging.py": "# mafia/mechanics/messaging.py\nfrom typing import Dict, List, Optional, Tuple\nfrom mafia.enums import Phase\n\nclass Message:\n    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):\n        self.sender = sender              # Who sent the message\n        self.content = content            # What was said (raw text or structured)\n        self.target = target              # If whispering or targeting another player\n        self.private = private            # Whisper if True, public otherwise\n\n    def render(self) -> str:\n        if self.private:\n            return f\"[WHISPER] {self.sender} \u2192 {self.target}: {self.content}\"\n        elif self.target:\n            return f\"{self.sender} \u2192 {self.target}: {self.content}\"\n        return f\"{self.sender}: {self.content}\"\n\n\nclass MessagingSystem:\n    def __init__(self):\n        self.history: List[Message] = []\n\n    def send_public(self, sender: str, content: str):\n        msg = Message(sender=sender, content=content)\n        self.history.append(msg)\n        return msg\n\n    def send_private(self, sender: str, recipient: str, content: str):\n        msg = Message(sender=sender, content=content, target=recipient, private=True)\n        self.history.append(msg)\n        return msg\n\n    def get_visible_messages(self, player_name: str, phase: Phase) -> List[str]:\n        visible = []\n        for msg in self.history:\n            if not msg.private:\n                visible.append(msg.render())\n            elif msg.private and (msg.sender == player_name or msg.target == player_name):\n                visible.append(msg.render())\n        return visible\n\n    def get_all_messages(self) -> List[str]:\n        return [msg.render() for msg in self.history]\n\n    def clear(self):\n        self.history.clear()\n\n    def get_log_data(self) -> List[Dict]:\n        return [{\n            \"sender\": msg.sender,\n            \"target\": msg.target,\n            \"private\": msg.private,\n            \"content\": msg.content\n        } for msg in self.history]\n",
  "mechanics\\night.py": "# mafia/mechanics/night.py\n\nfrom mafia.enums import RoleType\nfrom mafia.game_state import GameState\n\ndef resolve_night_phase(game_state: GameState):\n    \"\"\"\n    Resolves all night actions in the game. This includes mafia kills,\n    investigations, roleblocks, protections, etc. Follows a standard resolution order.\n    \"\"\"\n    # Stage 1: Apply roleblocks\n    roleblocked = set()\n    for actor, action in game_state.night_actions.items():\n        if action.get(\"type\") == \"roleblock\":\n            target = action.get(\"target\")\n            roleblocked.add(target)\n\n    # Stage 2: Apply protection\n    protected = set()\n    for actor, action in game_state.night_actions.items():\n        if action.get(\"type\") == \"protect\":\n            target = action.get(\"target\")\n            if target not in roleblocked:\n                protected.add(target)\n\n    # Stage 3: Apply mafia kills (Godfather priority)\n    kill_targets = []\n    for actor, action in game_state.night_actions.items():\n        if action.get(\"type\") == \"kill\":\n            if actor in roleblocked:\n                continue\n            target = action.get(\"target\")\n            if target not in protected:\n                kill_targets.append(target)\n\n    for target in kill_targets:\n        if game_state.is_alive(target):\n            game_state.kill_player(target)\n            game_state.messages.append(f\"{target} was killed during the night.\")\n\n    # Stage 4: Investigations (e.g., Cop)\n    for actor, action in game_state.night_actions.items():\n        if action.get(\"type\") == \"investigate\" and actor not in roleblocked:\n            target = action.get(\"target\")\n            player_obj = game_state.get_player(target)\n            result = {\n                \"target\": target,\n                \"alignment\": player_obj.role.alignment if player_obj else \"unknown\"\n            }\n            investigator = game_state.get_player(actor)\n            if investigator:\n                investigator.memory.append(result)\n\n    # Stage 5: Cleanup\n    game_state.night_actions.clear()\n",
  "mechanics\\phases.py": "# mafia/mechanics/phases.py\n\nfrom mafia.enums import Phase\nfrom mafia.game_state import GameState\nfrom mafia.player import Player\nfrom mafia.mechanics.roles import Role\n\n\ndef transition_to_day(game_state: GameState):\n    \"\"\"\n    Executes night actions and moves the game to the day phase.\n    This includes resolving kills, roleblocks, protections, and logging.\n    \"\"\"\n    # Resolve night actions\n    kills = []\n    protections = set()\n\n    for actor_name, action in game_state.night_actions.items():\n        player = game_state.get_player(actor_name)\n        if not player or not player.can_act():\n            continue\n\n        if 'kill' in action:\n            target = action['kill']\n            if target:\n                kills.append(target.name)\n                game_state.log_hidden(actor_name, f\"Attempted kill on {target.name}\")\n\n        if 'investigation' in action:\n            result = action['investigation']\n            game_state.log_hidden(actor_name, f\"Investigated: {result}\")\n\n        if 'protect' in action:\n            target = action['protect']\n            if target:\n                protections.add(target.name)\n                game_state.log_hidden(actor_name, f\"Protected {target.name}\")\n\n        if 'roleblock' in action:\n            target = action['roleblock']\n            if target:\n                target.is_roleblocked = True\n                game_state.log_hidden(actor_name, f\"Roleblocked {target.name}\")\n\n    # Resolve kills unless protected\n    for target_name in kills:\n        if target_name not in protections and game_state.is_alive(target_name):\n            game_state.kill_player(target_name)\n            game_state.messages.append(f\"{target_name} was found dead in the morning.\")\n            game_state.log_hidden(\"system\", f\"{target_name} died during the night\")\n\n    # Reset states\n    for player in game_state.players:\n        player.reset_night_state()\n        player.reset_day_state()\n\n    game_state.reset_votes()\n    game_state.reset_discussion_state()\n    game_state.night_actions.clear()\n    game_state.day_count += 1\n    game_state.phase = Phase.DAY\n\n\ndef transition_to_night(game_state: GameState):\n    \"\"\"\n    Ends the day phase, processes votes, and transitions to night.\n    Includes resolving lynch and updating alive/dead lists.\n    \"\"\"\n    # Process lynch\n    if game_state.accused_player:\n        votes_for_lynch = sum(game_state.lynch_confirm_votes.values())\n        total_alive = len(game_state.alive_players)\n\n        if votes_for_lynch > total_alive // 2:\n            game_state.kill_player(game_state.accused_player)\n            game_state.messages.append(f\"{game_state.accused_player} was lynched.\")\n            game_state.log_hidden(\"system\", f\"{game_state.accused_player} was lynched by majority\")\n        else:\n            game_state.messages.append(f\"Nobody was lynched today.\")\n\n    game_state.phase = Phase.NIGHT\n    game_state.reset_votes()\n    game_state.reset_discussion_state()\n",
  "mechanics\\roles.py": "from abc import ABC, abstractmethod\n# Corrected import path assuming roles.py is inside mechanics\nfrom mafia.enums import Faction\nfrom typing import Optional, TYPE_CHECKING, Dict, Any\n\n# Avoid circular import for type hinting\nif TYPE_CHECKING:\n    from mafia.player import Player\n    from mafia.game_state import GameState\n\n\nclass Role(ABC):\n    def __init__(self, name: str, faction: Faction):\n        self.name = name\n        self.faction = faction\n        # Add alignment based on faction for consistency if needed elsewhere\n        self.alignment = faction # Simple mapping for now\n\n    @abstractmethod\n    def get_role_description(self) -> str:\n        \"\"\"Return a string describing the role's abilities and goals.\"\"\"\n        pass\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Executes the role's night action.\n        Target selection logic is handled by the Agent/Player, passed via target_name.\n        Returns a dictionary representing the action taken or None.\n        \"\"\"\n        return None # Default: No night action\n\n    def can_act_at_night(self) -> bool:\n        \"\"\"Checks if the role has a meaningful night action.\"\"\"\n        # Check if the night_action method is overridden from the base class\n        return self.__class__.night_action != Role.night_action\n\n    def __repr__(self):\n        # Use self.faction directly as it's an attribute\n        return f\"<{self.faction.value}:{self.name}>\"\n\n# ------------------- TOWN ROLES -------------------\n\nclass Villager(Role):\n    def __init__(self):\n        # Use direct value for consistency, or reference an enum if preferred\n        super().__init__(\"Villager\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are a Villager. You have no special abilities. Find and lynch the Mafia.\"\n\n    # night_action is inherited as None\n\nclass Cop(Role):\n    def __init__(self):\n        super().__init__(\"Cop\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia).\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n\n        if target_player and target_player.alive:\n            # Simplified: Godfather reads as Town unless detectable=True (add later)\n            is_mafia = target_player.role.faction == Faction.MAFIA\n            # Handle Godfather detection rule here if needed\n            # Example: if isinstance(target_player.role, Godfather) and not game_state.config.get(\"godfather_detectable\", False):\n            #     result_faction = Faction.TOWN\n            # else:\n            result_faction = Faction.MAFIA if is_mafia else Faction.TOWN\n\n            result_info = f\"Investigated {target_player.name}: Result {result_faction.value}\"\n            player.log_hidden(game_state, f\"\\uD83D\\uDD0E {result_info}\")\n            # Store result in player's memory\n            player.memory.append({\n                \"type\": \"investigation_result\",\n                \"day\": game_state.day_count,\n                \"target\": target_player.name,\n                \"result\": result_faction.value\n            })\n            # Action registered for logging/tracking, actual info given via memory\n            return {\"type\": \"investigate\", \"target\": target_player.name, \"result\": result_faction.value}\n        elif target_name:\n             player.log_hidden(game_state, f\"\\uD83D\\uDD0E Tried to investigate {target_name}, but they were not found or dead.\")\n        return None\n\nclass Doctor(Role):\n    def __init__(self):\n        super().__init__(\"Doctor\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are the Doctor. Each night, you can choose one player to protect from death.\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n\n        if target_player and target_player.alive:\n            # Protection handled centrally in night resolution based on this action\n            player.log_hidden(game_state, f\"\\uD83E\\uDE78 Protected {target_player.name}\")\n            return {\"type\": \"protect\", \"target\": target_player.name}\n        elif target_name:\n            player.log_hidden(game_state, f\"\\uD83E\\uDE78 Tried to protect {target_name}, but they were not found or dead.\")\n        return None\n\n# ------------------- MAFIA ROLES -------------------\n\nclass Goon(Role):\n    def __init__(self):\n        super().__init__(\"Goon\", Faction.MAFIA)\n\n    def get_role_description(self) -> str:\n        return \"You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day.\"\n\n    # night_action is inherited as None (kill decision by Godfather)\n\nclass Godfather(Role):\n    def __init__(self):\n        super().__init__(\"Godfather\", Faction.MAFIA)\n        self.appears_as = Faction.TOWN # To cops, unless detectable\n\n    def get_role_description(self) -> str:\n        return (\"You are the Godfather. You appear as Town to the Cop. \"\n                \"Each night, choose a target for the Mafia to kill. \"\n                \"If you die, a Goon will be promoted.\")\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n\n        if target_player and target_player.alive:\n            player.log_hidden(game_state, f\"\\uD83D\\uDD2A Ordered kill on {target_player.name}\")\n            # Action registered, actual kill resolved centrally\n            return {\"type\": \"kill\", \"target\": target_player.name}\n        elif target_name:\n             player.log_hidden(game_state, f\"\\uD83D\\uDD2A Tried to order kill on {target_name}, but they were not found or dead.\")\n        return None\n\n# Add other roles (RoleBlocker, Consigliere, etc.) here following the pattern...\n\n# Helper function to get a role class from its name string (used in simulation setup)\n# Place this at the end of the file or in a separate utility file\nROLE_CLASS_MAP = {\n    \"villager\": Villager,\n    \"cop\": Cop,\n    \"doctor\": Doctor,\n    \"goon\": Goon,\n    \"godfather\": Godfather,\n    # Add other roles here...\n}\n\ndef get_role_class(role_name: str) -> Optional[type[Role]]:\n    return ROLE_CLASS_MAP.get(role_name.lower())",
  "mechanics\\voting.py": "# mafia/mechanics/voting.py\nfrom typing import Dict, Optional\nfrom mafia.enums import Phase\nfrom mafia.game_state import GameState\n\n\ndef cast_vote(game_state: GameState, voter: str, target: str) -> None:\n    \"\"\"Player casts or changes vote for someone.\"\"\"\n    if game_state.phase != Phase.DAY or voter not in game_state.alive_players:\n        return\n\n    # Remove old vote if it exists\n    if voter in game_state.voting_targets:\n        prev_target = game_state.voting_targets[voter]\n        if prev_target != target:\n            game_state.messages.append(f\"{voter} changed their vote from {prev_target} to {target}.\")\n    else:\n        game_state.messages.append(f\"{voter} has voted for {target}.\")\n\n    game_state.voting_targets[voter] = target\n    check_accusation_threshold(game_state)\n\n\ndef retract_vote(game_state: GameState, voter: str) -> None:\n    \"\"\"Player retracts their vote.\"\"\"\n    if voter in game_state.voting_targets:\n        prev = game_state.voting_targets.pop(voter)\n        game_state.messages.append(f\"{voter} retracted their vote on {prev}.\")\n\n\ndef check_accusation_threshold(game_state: GameState, threshold: float = 0.5) -> None:\n    \"\"\"Automatically trigger accusation if a player reaches vote threshold.\"\"\"\n    vote_counts: Dict[str, int] = {}\n    for target in game_state.voting_targets.values():\n        vote_counts[target] = vote_counts.get(target, 0) + 1\n\n    total_voters = len(game_state.alive_players)\n    for target, count in vote_counts.items():\n        if count / total_voters >= threshold and game_state.accused_player != target:\n            game_state.accused_player = target\n            game_state.messages.append(f\"{target} has been accused and must now defend themselves.\")\n\n\ndef confirm_lynch_vote(game_state: GameState, voter: str, confirm: bool) -> None:\n    \"\"\"Player confirms or denies the lynch after accusation.\"\"\"\n    if game_state.phase != Phase.DAY or not game_state.accused_player:\n        return\n\n    game_state.lynch_confirm_votes[voter] = confirm\n    yes_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if vote)\n    no_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if not vote)\n\n    total_voters = len(game_state.alive_players)\n    if yes_votes > total_voters // 2:\n        game_state.messages.append(f\"{game_state.accused_player} has been lynched by majority vote.\")\n        game_state.kill_player(game_state.accused_player)\n        game_state.reset_votes()\n    elif no_votes >= total_voters // 2:\n        game_state.messages.append(f\"{game_state.accused_player} has survived the vote.\")\n        game_state.reset_votes()\n\n\n# --------------------------\n# Whisper Mechanics\n# --------------------------\n\ndef whisper(game_state: GameState, sender: str, recipient: str, message: str) -> None:\n    \"\"\"Send a whisper from one player to another. Hidden from all other agents.\"\"\"\n    if sender not in game_state.alive_players or recipient not in game_state.alive_players:\n        return\n\n    # Track hidden message to sender and recipient\n    for player in game_state.players:\n        if player.name in {sender, recipient}:\n            player.log_hidden(game_state, f\"[WHISPER] {sender} \u2192 {recipient}: {message}\")\n        else:\n            player.log_hidden(game_state, f\"[WHISPER] {sender} \u2192 {recipient}: <hidden>\")\n\n    # Log public metadata\n    game_state.messages.append(f\"{sender} whispered to {recipient}.\")\n\n\n# --------------------------\n# Voting Visibility\n# --------------------------\n\ndef get_vote_visibility(game_state: GameState) -> Dict[str, str]:\n    \"\"\"Return a dict of current votes (publicly visible for now).\"\"\"\n    return {voter: target for voter, target in game_state.voting_targets.items()}\n",
  "mechanics\\__init__.py": "",
  "prompts\\mafia_template.py": "def format_prompt(name: str, obs: dict) -> str:\n    # Format as readable context for the agent\n    lines = [f\"Day {obs['day']} | Phase: {obs['phase']}\"]\n    lines.append(\"Alive: \" + \", \".join(obs[\"alive\"]))\n    lines.append(\"Dead: \" + \", \".join(obs[\"dead\"]))\n    lines.append(\"Messages:\")\n    lines.extend(obs[\"messages\"])\n    lines.append(\"What do you do next? Choose one action:\")\n    return \"\\n\".join(lines)\n\ndef parse_response(response: str) -> dict:\n    \"\"\"\n    Expects LLM to return something like:\n    <action> accuse </action> <target> Player3 </target>\n    \"\"\"\n    import re\n    act = re.search(r\"<action>(.*?)</action>\", response)\n    tgt = re.search(r\"<target>(.*?)</target>\", response)\n    return {\n        \"action\": act.group(1).strip().lower() if act else \"pass\",\n        \"target\": tgt.group(1).strip() if tgt else None\n    }\n",
  "utils\\token_cost.py": ""
}