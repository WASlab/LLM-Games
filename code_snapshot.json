{
  "config.py": "",
  "enums.py": "from enum import Enum\n\nclass Faction(Enum):\n    TOWN = \"town\"\n    MAFIA = \"mafia\"\n    NEUTRAL = \"neutral\" # Reserved for extensibility\n\nclass GamePhase(Enum):\n    NIGHT = \"night\"\n    DAY_DISCUSSION = \"day_discussion\"\n    VOTING = \"voting\"\n    DEFENSE = \"defense\" # Optional phase if accusation needs defense\n    FINAL_VOTE = \"final_vote\" # Optional phase for final lynch decision\n    GAME_OVER = \"game_over\"\n\nclass VoteType(Enum):\n    ACCUSATION = \"accusation\" # Initial vote during day\n    FINAL_GUILTY = \"final_guilty\" # Vote during final lynch\n    FINAL_INNOCENT = \"final_innocent\" # Vote during final lynch\n    SKIP = \"skip\" # Abstain from voting",
  "environment.py": "# === Updated mafia/environment.py ===\nimport random\nfrom collections import deque\nfrom typing import Dict, List, Optional, Any, Tuple\n\n# Use correct imports based on unified role system and previous refactoring\nfrom mafia.game_state import GameState\nfrom mafia.player import Player\nfrom mafia.enums import GamePhase, Faction\n# Import specific roles if needed for logic (e.g., Cop speaks first)\nfrom mafia.mechanics.roles import Cop\n# Assume rewards and token tracking utilities exist\n# from mafia.rewards import compute_rewards, assign_vote_reward, ...\n# from mafia.utils.token_cost import track_tokens # If using\n\n# Dummy Token Tracker if not implemented\nclass TokenTracker:\n    def __init__(self): self.usage = {}\n    def update(self, *args, **kwargs): pass\n    def to_dict(self): return self.usage\n\n# Dummy compute_rewards if not implemented\ndef compute_rewards(state): return {}\n\nclass MafiaEnvironment:\n    \"\"\"\n    Manages the overall flow, phases, and action resolution of a Mafia game.\n    \"\"\"\n    def __init__(self, players: List[Player], config: Dict[str, Any]):\n        self.config = config\n        # Ensure players list is shuffled initially unless order matters for setup\n        # random.shuffle(players)\n        self.state = GameState(players=players, game_config=config)\n        self.state.initialize()\n\n        # Turn management for day phase\n        self._speaker_queue: deque[str] = deque()\n        self._question_queue: deque[Tuple[str, str]] = deque() # (Questioner, Questioned) tuples\n        self._turns_taken_this_round: Set[str] = set() # Track who spoke in current round-robin\n        self._consecutive_passes: int = 0\n\n        # Configuration flags\n        self.lynch_defense_enabled: bool = self.config.get(\"lynch_defense_enabled\", True)\n        self.cop_speaks_first: bool = self.config.get(\"cop_speaks_first\", False)\n        # Add token budget config if using tokens\n\n        self.token_tracker = TokenTracker() # If using\n\n    # --- Core Simulation Interface ---\n\n    def step_phase(self) -> bool:\n        \"\"\"\n        Advances the game by one logical phase or step.\n        Returns True if the game ended, False otherwise.\n        \"\"\"\n        if self.state.game_over:\n            return True\n\n        current_phase = self.state.phase\n\n        if current_phase == GamePhase.NIGHT:\n            self._resolve_night()\n            self._transition_to_day()\n        elif current_phase == GamePhase.DAY_DISCUSSION:\n            # Day discussion is more complex, managed turn-by-turn\n            # The simulation loop should call process_player_action or advance_turn\n            # This method might just check if discussion should end and transition\n            if self._check_discussion_end():\n                self._transition_to_voting() # Or trial if accusation happened\n        elif current_phase == GamePhase.VOTING:\n            # Logic to handle voting actions if needed, or transition after timer/all voted\n            # For simplicity, assume voting logic is handled within _resolve_day/process_player_action\n             pass # Voting might resolve as part of day discussion end\n        elif current_phase == GamePhase.DEFENSE:\n            # Handle defense turn\n            self._run_defense() # Let accused speak\n            self._transition_to_final_vote()\n        elif current_phase == GamePhase.FINAL_VOTE:\n            # Handle final lynch votes\n            self._resolve_lynch() # Use final votes\n            self._transition_to_night()\n        # Add other phases if necessary\n\n        # Check for game end after phase actions\n        return self.state.check_game_end()\n\n\n    def get_current_player_name(self) -> Optional[str]:\n        \"\"\"Returns the name of the player whose turn it is to act.\"\"\"\n        return self.state.current_player_turn\n\n    def get_observation(self, player_name: str) -> Dict[str, Any]:\n        \"\"\"Generates the observation for the specified player.\"\"\"\n        return self.state.get_player_observation(player_name)\n\n    def advance_turn(self):\n        \"\"\"Advances to the next player's turn during the day discussion.\"\"\"\n        if self.state.phase != GamePhase.DAY_DISCUSSION:\n            self.state.current_player_turn = None\n            return\n\n        # Prioritize question queue\n        if self._question_queue:\n            questioner, questioned = self._question_queue.popleft()\n            # Questioned player speaks next\n            self.state.current_player_turn = questioned\n            self.state.log_hidden(\"system\", f\"Turn advanced to {questioned} (answering {questioner})\")\n            # We might need state to know they are answering a question\n            self.state.turn_context = {\"answering_question_from\": questioner}\n            return\n\n        # If no questions pending, continue normal speaker queue\n        self.state.turn_context = None # Clear context\n        if not self._speaker_queue:\n            # If queue is empty, check if discussion should end or start new round\n            if self._check_discussion_end():\n                self._transition_to_voting()\n                return\n            else:\n                 # Start a new round-robin\n                self._start_new_discussion_round()\n                if not self._speaker_queue: # No one left to speak\n                     self._transition_to_voting()\n                     return\n\n        # Get next speaker from queue\n        next_speaker = self._speaker_queue.popleft()\n        self.state.current_player_turn = next_speaker\n        self.state.turn_number_in_phase += 1 # Increment turn counter\n        self.state.log_hidden(\"system\", f\"Turn advanced to {next_speaker}\")\n\n\n    def process_player_action(self, player_name: str, action: Dict[str, Any]) -> bool:\n        \"\"\"Processes an action submitted by a player's agent.\"\"\"\n        player = self.state.get_player(player_name)\n        if not player or not player.alive or self.state.current_player_turn != player_name:\n            self.state.log_hidden(player_name, f\"Attempted action {action} but not their turn or dead.\")\n            return False # Not their turn or player invalid\n\n        action_type = action.get(\"action\")\n        target = action.get(\"target\")\n        content = action.get(\"content\")\n        success = False\n\n        self.state.log_hidden(player_name, f\"Received action: {action}\")\n        self.token_tracker.update(player_name, action_type, content) # Track tokens/action\n\n        # --- Night Actions ---\n        if self.state.phase == GamePhase.NIGHT:\n            if player.can_act_at_night():\n                # Agent should decide target, store it, environment reads it here?\n                # Or action dict contains target directly\n                player.night_target = target # Store target chosen by agent\n                # Submit the *intended* action based on role, Environment resolves later\n                intended_action = player.perform_night_action(self.state)\n                if intended_action:\n                    self.state.register_night_action(player_name, intended_action)\n                    success = True\n                else:\n                     self.state.log_hidden(player_name, \"Submitted no valid night action or was blocked.\")\n                     # Still counts as their turn ending\n                     success = True # Turn processed, even if no action\n            else:\n                 self.state.log_hidden(player_name,\"Attempted night action, but role cannot act.\")\n                 success = True # Turn processed\n\n        # --- Day Discussion Actions ---\n        elif self.state.phase == GamePhase.DAY_DISCUSSION:\n            self._consecutive_passes = 0 # Reset pass counter on any action other than pass\n            if action_type == \"pass\":\n                self.state.log_message(player_name, f\"{player_name} passes.\")\n                self._consecutive_passes += 1\n                success = True\n            elif action_type == \"accuse\" and target:\n                # Check if an accusation has already happened this day if limiting\n                if self.state.player_on_trial:\n                     self.state.log_hidden(player_name, \"Tried to accuse, but someone is already on trial.\")\n                else:\n                    success = player.accuse(target, self.state)\n                    if success:\n                        # Accusation successful, potentially triggers voting phase\n                        self.state.player_on_trial = target\n                        # Don't transition immediately, let round finish? Or transition now?\n                        # Let's transition after the action completes.\n            elif action_type == \"vote\" and target:\n                 # Allow voting during discussion phase\n                 success = player.vote_for(target, self.state)\n            elif action_type == \"question\" and target and content:\n                 # Limit questions per player per day? Assume 1 for now.\n                 if player.questions_asked_today.get(target, 0) < 1 :\n                     success = player.question(target, content, self.state)\n                     if success:\n                         # Add questioned player to the question queue\n                         self._question_queue.append((player_name, target))\n                         self.state.log_hidden(\"system\", f\"{target} added to question queue by {player_name}\")\n                         # Questioner gets another turn immediately after questioned?\n                         # Per description: \"person who questioned is able to then respond\"\n                         # Let's add questioner after questioned in queue\n                         self._question_queue.append((player_name, player_name)) # Special tuple marker?\n\n                 else:\n                      self.state.log_hidden(player_name, f\"Attempted to question {target} again, limit reached.\")\n            elif action_type == \"predict\" and target and content:\n                 success = player.predict_role(target, content, self.state)\n            elif action_type == \"whisper\" and target and content:\n                 success = player.whisper(target, content, self.state)\n                 # Need to ensure whisper content gets to target's next observation\n            else:\n                 # Default speak action / generic message\n                 if content:\n                     self.state.log_message(player_name, content)\n                     success = True\n                 else: # Invalid action format\n                      self.state.log_hidden(player_name, f\"Submitted invalid action format: {action}\")\n\n            # Mark turn as taken for this round-robin cycle\n            self._turns_taken_this_round.add(player_name)\n\n        # --- Voting Phase Actions ---\n        elif self.state.phase == GamePhase.VOTING:\n             if action_type == \"vote\" and target == self.state.player_on_trial:\n                  # Allow voting only for the player on trial\n                  success = player.vote_for(target, self.state)\n                  # Might need separate vote tally: self.state.votes_for_lynch[player_name] = True/False?\n                  # Or stick with player.vote attribute? Let's use dedicated dict for final lynch\n                  is_guilty_vote = action.get(\"vote_type\") == VoteType.FINAL_GUILTY # Assuming action includes this\n                  self.state.votes_for_lynch[player_name] = is_guilty_vote\n                  success = True # Mark action processed\n             else:\n                  self.state.log_hidden(player_name, f\"Invalid action {action} during Voting phase.\")\n\n\n        # --- Defense Phase Action ---\n        elif self.state.phase == GamePhase.DEFENSE:\n             if player_name == self.state.player_on_trial and content:\n                 self.state.log_message(player_name, f\"(Defense): {content}\")\n                 success = True\n             else:\n                 self.state.log_hidden(player_name, f\"Tried to speak during defense, but not on trial.\")\n\n\n        # --- Final Vote Phase Action ---\n        elif self.state.phase == GamePhase.FINAL_VOTE:\n             if action_type == \"vote\":\n                 vote_type_str = action.get(\"vote_type\", \"\").lower()\n                 if vote_type_str == \"final_guilty\":\n                     self.state.votes_for_lynch[player_name] = True\n                     self.state.log_message(player_name, f\"votes GUILTY on {self.state.player_on_trial}.\")\n                     success = True\n                 elif vote_type_str == \"final_innocent\":\n                     self.state.votes_for_lynch[player_name] = False\n                     self.state.log_message(player_name, f\"votes INNOCENT on {self.state.player_on_trial}.\")\n                     success = True\n                 else:\n                      self.state.log_hidden(player_name, f\"Invalid vote type '{vote_type_str}' during final vote.\")\n             else:\n                 self.state.log_hidden(player_name, f\"Invalid action {action} during Final Vote phase.\")\n\n\n        # --- Post-Action ---\n        if success:\n            # Advance turn only if action was successful and in discussion phase\n            if self.state.phase == GamePhase.DAY_DISCUSSION:\n                 # Check if accusation triggers immediate phase change\n                 if self.state.player_on_trial and action_type == \"accuse\":\n                     self._transition_to_voting() # Or defense if enabled\n                 else:\n                     self.advance_turn()\n        else:\n            self.state.log_hidden(player_name, f\"Action {action} failed processing.\")\n            # Do not advance turn if action failed? Or advance anyway? Let's advance.\n            if self.state.phase == GamePhase.DAY_DISCUSSION:\n                 self.advance_turn()\n\n        return success\n\n\n    # --- Private Phase Logic Methods ---\n\n    def _resolve_night(self):\n        \"\"\"Resolves all submitted night actions according to standard order.\"\"\"\n        self.state.log_message(\"system\", \"Night ends. Resolving actions...\")\n        self.state.night_action_results.clear() # Clear previous results\n        submitted_actions = self.state.night_actions_submitted\n\n        # --- Action Resolution Order ---\n        # 1. Roleblocks / Disruptions (e.g., Blackmailer blocks speaking)\n        roleblocked_players: Set[str] = set()\n        blackmailed_players: Set[str] = set()\n        # TODO: Add Roleblocker role and logic\n        # for actor, action in submitted_actions.items():\n        #     if action.get(\"type\") == \"roleblock\" and self.state.is_alive(actor):\n        #         target = action.get(\"target\")\n        #         if self.state.is_alive(target):\n        #             roleblocked_players.add(target)\n        #             self.state.log_hidden(actor, f\"Roleblocked {target}\")\n        #     elif action.get(\"type\") == \"blackmail\" # ... etc ...\n\n        # Apply roleblocks to players\n        for rb_target in roleblocked_players:\n             player = self.state.get_player(rb_target)\n             if player: player.is_roleblocked = True\n\n        # Apply other effects like blackmail\n        # for bm_target in blackmailed_players: ... player.can_speak_today = False ...\n\n\n        # 2. Protections (e.g., Doctor)\n        protected_players: Dict[str, str] = {} # target -> protector_name\n        for actor, action in submitted_actions.items():\n            if not self.state.is_alive(actor) or actor in roleblocked_players: continue # Dead or blocked\n            if action.get(\"type\") == \"protect\":\n                target = action.get(\"target\")\n                if self.state.is_alive(target):\n                    # Allow multiple protects? For now, last one counts or first? Let's say first.\n                    if target not in protected_players:\n                         protected_players[target] = actor\n                         # Store who protected them on the player object\n                         target_player = self.state.get_player(target)\n                         if target_player: target_player.protected_by = actor\n                         self.state.log_hidden(actor, f\"Successfully protected {target}\")\n\n        # 3. Kills (e.g., Mafia Godfather)\n        kill_attempts: List[Tuple[str, str]] = [] # (killer_name, target_name)\n        for actor, action in submitted_actions.items():\n             if not self.state.is_alive(actor) or actor in roleblocked_players: continue\n             if action.get(\"type\") == \"kill\":\n                  target = action.get(\"target\")\n                  if self.state.is_alive(target):\n                      kill_attempts.append((actor, target))\n                      self.state.log_hidden(actor, f\"Attempting kill on {target}\")\n\n        # Resolve kills vs protections\n        successful_kills: Set[str] = set()\n        for killer, target in kill_attempts:\n            if target not in protected_players:\n                 successful_kills.add(target)\n                 self.state.log_hidden(killer, f\"Kill on {target} successful (not protected).\")\n            else:\n                 protector = protected_players[target]\n                 self.state.log_hidden(killer, f\"Kill on {target} failed (protected by {protector}).\")\n                 self.state.log_hidden(protector, f\"Your protection on {target} worked!\")\n                 # Optionally notify killer / protector in results\n\n        # Apply kills\n        deaths_this_night = []\n        for target_to_die in successful_kills:\n             if self.state.is_alive(target_to_die): # Check again in case multiple kills target same person\n                  self.state.kill_player(target_to_die, reason=\"killed during night\")\n                  deaths_this_night.append(target_to_die)\n\n\n        # 4. Investigations (e.g., Cop, Consigliere)\n        # Note: Results were already stored in player memory during perform_night_action\n        # This step is mainly for logging or cross-referencing if needed.\n        for actor, action in submitted_actions.items():\n             if not self.state.is_alive(actor) or actor in roleblocked_players: continue\n             if action.get(\"type\") == \"investigate\":\n                  target = action.get(\"target\")\n                  result = action.get(\"result\") # Get result stored earlier\n                  self.state.log_hidden(actor, f\"Investigation result for {target}: {result}\")\n                  # Store in night_action_results for environment access if needed\n                  self.state.night_action_results[actor] = action\n\n\n        # 5. Other Night Actions (e.g., Consigliere role check, Blackmailer)\n\n\n        # Announce deaths\n        if deaths_this_night:\n             # Sort for consistent output\n             announce_deaths = \", \".join(sorted(deaths_this_night))\n             self.state.log_message(\"system\", f\"The sun rises. The following people were found dead: {announce_deaths}.\")\n        else:\n             self.state.log_message(\"system\", \"The sun rises. Miraculously, everyone survived the night!\")\n\n\n    def _transition_to_day(self):\n        \"\"\"Resets night states and prepares for the day phase.\"\"\"\n        self.state.log_hidden(\"system\", \"Transitioning to Day phase.\")\n        # Reset player night states AFTER resolution but before day starts\n        for player in self.state.players:\n            player.reset_night_state() # Clears roleblock status etc. for next night\n\n        self.state.phase = GamePhase.DAY_DISCUSSION\n        self.state.day_count += 1\n        self.state.reset_day_phase_state() # Clear votes, trial status, etc.\n        self._start_new_discussion_round() # Setup speaker queue\n        self.state.log_message(\"system\", f\"Day {self.state.day_count} begins. Discuss and vote!\")\n\n\n    def _start_new_discussion_round(self):\n        \"\"\"Sets up the speaker queue for a round of discussion.\"\"\"\n        self.state.log_hidden(\"system\", \"Starting new discussion round.\")\n        self._speaker_queue.clear()\n        self._turns_taken_this_round.clear()\n        self._question_queue.clear() # Clear pending questions? Or let them persist? Let's clear.\n        self.state.turn_context = None\n        self._consecutive_passes = 0\n\n        # Get list of alive players, potentially ordered\n        alive_player_names = sorted(list(self.state.alive_players)) # Sort for consistency\n\n        # Optional: Cop speaks first\n        if self.cop_speaks_first:\n             cop_player = None\n             for name in alive_player_names:\n                 player = self.state.get_player(name)\n                 if player and isinstance(player.role, Cop):\n                     cop_player = name\n                     break\n             if cop_player:\n                 alive_player_names.remove(cop_player)\n                 alive_player_names.insert(0, cop_player)\n                 self.state.log_hidden(\"system\", f\"Cop ({cop_player}) will speak first.\")\n\n        self._speaker_queue.extend(alive_player_names)\n        self.state.turn_number_in_phase = 0 # Reset turn count for new round\n        self.advance_turn() # Set the first speaker\n\n    def _check_discussion_end(self) -> bool:\n        \"\"\"Checks if the discussion phase should end.\"\"\"\n        # Condition 1: Everyone alive has passed consecutively\n        if self._consecutive_passes >= len(self.state.alive_players):\n            self.state.log_hidden(\"system\", \"Discussion ending: Everyone passed.\")\n            return True\n\n        # Condition 2: Everyone alive has had a turn this round and queue is empty\n        # (Avoids infinite loop if someone leaves mid-round? Check count vs set size)\n        if not self._speaker_queue and not self._question_queue and len(self._turns_taken_this_round) >= len(self.state.alive_players):\n             self.state.log_hidden(\"system\", \"Discussion ending: Round complete, queues empty.\")\n             return True\n\n        # Condition 3: Accusation successful (handled in process_player_action)\n        if self.state.player_on_trial:\n             # This state means discussion ended due to accusation\n             self.state.log_hidden(\"system\", f\"Discussion ended: {self.state.player_on_trial} was accused.\")\n             return True\n\n        # Condition 4: Timer / Max Turns / Token Budget (TODO)\n        # if self.state.turn_number_in_phase >= self.config.get(\"max_day_turns\", 20): ...\n\n        return False\n\n\n    def _transition_to_voting(self):\n         \"\"\"Moves from discussion to voting on the accused player.\"\"\"\n         if not self.state.player_on_trial:\n             # If discussion ended without accusation (everyone passed), skip to night\n             self.state.log_message(\"system\", \"No one was put on trial today.\")\n             self._transition_to_night()\n             return\n\n         self.state.log_message(\"system\", f\"{self.state.player_on_trial} is on trial!\")\n         self.state.votes_for_lynch.clear() # Clear final lynch votes\n\n         if self.lynch_defense_enabled:\n             self.state.phase = GamePhase.DEFENSE\n             self.state.current_player_turn = self.state.player_on_trial # Accused speaks\n             self.state.log_message(\"system\", f\"{self.state.player_on_trial}, you may make your defense.\")\n         else:\n             # Skip defense, go directly to final vote\n             self._transition_to_final_vote()\n\n\n    def _run_defense(self):\n        \"\"\"Placeholder for logic during the defense phase (mostly waiting for the accused agent).\"\"\"\n        # The simulation loop needs to call process_player_action for the accused player.\n        # Once they submit their defense (or pass), we transition.\n        # For now, assume defense happens instantly or is handled by simulation loop tick.\n        self.state.log_hidden(\"system\", f\"Defense phase for {self.state.player_on_trial}.\")\n        # After defense speech (or pass):\n        # _transition_to_final_vote() will be called\n\n\n    def _transition_to_final_vote(self):\n        \"\"\"Moves to the final guilty/innocent voting phase.\"\"\"\n        self.state.phase = GamePhase.FINAL_VOTE\n        self.state.current_player_turn = None # Or iterate through voters? Assume simultaneous for now\n        self.state.votes_for_lynch.clear() # Ensure votes are fresh for final decision\n        self.state.log_message(\"system\", f\"Final voting begins for {self.state.player_on_trial}. Vote Guilty or Innocent.\")\n        # The simulation loop needs to collect votes from all alive players in this phase.\n\n\n    def _resolve_lynch(self):\n        \"\"\"Tally final votes and execute the lynch if majority guilty.\"\"\"\n        if not self.state.player_on_trial:\n            self.state.log_hidden(\"system\", \"Lynch resolution skipped: No player on trial.\")\n            return\n\n        votes = self.state.votes_for_lynch\n        guilty_votes = sum(1 for is_guilty in votes.values() if is_guilty)\n        innocent_votes = len(votes) - guilty_votes # Assumes everyone voted\n        total_alive = len(self.state.alive_players)\n        needed_for_guilty = total_alive // 2 + 1\n\n        self.state.log_message(\"system\", f\"Vote Results for {self.state.player_on_trial}: Guilty={guilty_votes}, Innocent={innocent_votes} (Need {needed_for_guilty} for guilty)\")\n        self.state.log_hidden(\"system\", f\"Final votes: {votes}\")\n\n        if guilty_votes >= needed_for_guilty:\n            target = self.state.player_on_trial\n            self.state.log_message(\"system\", f\"The town has decided to lynch {target}!\")\n            self.state.kill_player(target, reason=\"lynched\")\n        else:\n            self.state.log_message(\"system\", f\"The town has decided to spare {self.state.player_on_trial}.\")\n\n        # Reset trial state after resolution\n        self.state.player_on_trial = None\n\n\n    def _transition_to_night(self):\n        \"\"\"Resets day states and prepares for the night phase.\"\"\"\n        self.state.log_hidden(\"system\", \"Transitioning to Night phase.\")\n\n        # Resolve lynch if it hasn't happened yet (e.g., if skipping phases)\n        if self.state.player_on_trial and self.state.phase != GamePhase.NIGHT:\n             self._resolve_lynch()\n\n        # Check game end again after potential lynch\n        if self.state.check_game_end():\n            return\n\n        # Reset states for the upcoming night\n        self.state.phase = GamePhase.NIGHT\n        self.state.reset_night_phase_state() # Clear submitted actions etc.\n        # No specific player turn at night start; agents submit actions simultaneously (conceptually)\n        self.state.current_player_turn = None\n        self.state.log_message(\"system\", \"Night falls. Choose your actions carefully...\")\n\n    # --- Utility ---\n    # Removed old _process_votes, _process_lynch, act, _get_observations as logic is integrated\n    # Removed old step method\n\n    def apply_rewards(self):\n        \"\"\"Computes and potentially stores rewards based on the current state.\"\"\"\n        # Placeholder: Actual reward calculation might happen at specific events or end of game\n        rewards = compute_rewards(self.state)\n        self.state.log_hidden(\"system\", f\"Computed rewards (not stored): {rewards}\")\n        # Store rewards in state or return them if needed by simulation runner",
  "export.py": "# export.py\nimport os\nimport json\n\ndef collect_python_files(root_dir: str) -> dict:\n    file_structure = {}\n\n    for dirpath, _, filenames in os.walk(root_dir):\n        for file in filenames:\n            if file.endswith('.py'):\n                full_path = os.path.join(dirpath, file)\n                rel_path = os.path.relpath(full_path, root_dir)\n                with open(full_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                file_structure[rel_path] = content\n\n    return file_structure\n\ndef export_to_json(output_path=\"code_snapshot.json\", root=\"mafia\"):\n    all_files = collect_python_files(root)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        json.dump(all_files, f, indent=2)\n\ndef export_to_text(output_path=\"code_snapshot.txt\", root=\"mafia\"):\n    all_files = collect_python_files(root)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        for path, content in all_files.items():\n            f.write(f\"# === {path} ===\\n\")\n            f.write(content + \"\\n\\n\")\n\nif __name__ == \"__main__\":\n    export_to_json()\n    export_to_text()\n    print(\"\u2705 Codebase exported to 'code_snapshot.json' and 'code_snapshot.txt'\")\n",
  "game_state.py": "from dataclasses import dataclass, field\nfrom typing import List, Dict, Optional, Set, Any\n# Use correct imports based on unified role system\nfrom mafia.enums import GamePhase, Faction\nfrom mafia.player import Player\n# Import specific role classes only if needed for specific logic (like promotion)\nfrom mafia.mechanics.roles import Goon, Godfather, get_role_class # Added get_role_class\nimport uuid\n\n@dataclass\nclass GameState:\n    players: List[Player]\n    game_config: Dict[str, Any] = field(default_factory=dict) # For rules like godfather_detectable\n    phase: GamePhase = GamePhase.NIGHT\n    day_count: int = 0\n    turn_number_in_phase: int = 0 # Track turns within day/night\n    current_player_turn: Optional[str] = None # Whose turn it is to act\n\n    alive_players: Set[str] = field(default_factory=set)\n    dead_players: Set[str] = field(default_factory=set)\n\n    messages: List[Dict[str, Any]] = field(default_factory=list) # Store message dicts, not just strings\n    hidden_log: List[Dict[str, Any]] = field(default_factory=list)\n\n    # Day phase state\n    votes_for_accusation: Dict[str, str] = field(default_factory=dict) # voter -> target\n    accusation_counts: Dict[str, int] = field(default_factory=dict) # target -> count\n    player_on_trial: Optional[str] = None\n    votes_for_lynch: Dict[str, bool] = field(default_factory=dict) # voter -> guilty (True) or innocent (False)\n\n    # Discussion state\n    discussion_token_budgets: Dict[str, int] = field(default_factory=dict) # Optional\n\n    # Night phase state\n    # Stores chosen actions before resolution: player_name -> {\"action_type\": \"kill\", \"target\": \"PlayerB\", ...}\n    night_actions_submitted: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n    # Stores resolved outcomes of actions: player_name -> {\"action_type\": \"investigate\", \"result\": \"mafia\", ...}\n    night_action_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n\n\n    game_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    game_over: bool = False\n    winner: Optional[Faction] = None # Store winning Faction enum\n    final_player_roles: Dict[str, str] = field(default_factory=dict) # player_name -> role_name\n\n    def initialize(self):\n        \"\"\"Called at game start to set up.\"\"\"\n        self.alive_players = {p.name for p in self.players}\n        self.dead_players = set()\n        self.day_count = 0\n        self.phase = GamePhase.NIGHT # Start at night\n        self.game_over = False\n        self.winner = None\n        self.messages.clear()\n        self.hidden_log.clear()\n        self.final_player_roles.clear()\n\n        # Initialize player states\n        for player in self.players:\n            player.reset_for_new_game()\n            # Set initial token budgets based on config if needed\n            # self.discussion_token_budgets[player.name] = self.game_config.get(\"initial_tokens\", 0)\n\n        self.log_message(\"system\", \"Game started.\")\n        self.log_hidden(\"system\", f\"Game ID: {self.game_id}\")\n        self.log_hidden(\"system\", f\"Initial Roles: { {p.name: p.role.name for p in self.players} }\")\n\n\n    def get_player(self, name: str) -> Optional[Player]:\n        for p in self.players:\n            if p.name == name:\n                return p\n        return None\n\n    def is_alive(self, name: str) -> bool:\n        return name in self.alive_players\n\n    def kill_player(self, name: str, reason: str = \"killed\"):\n        \"\"\"Marks a player as dead and handles consequences like GF promotion.\"\"\"\n        if name not in self.alive_players:\n            return # Already dead or invalid\n\n        player = self.get_player(name)\n        if not player: return # Should not happen\n\n        self.alive_players.discard(name)\n        self.dead_players.add(name)\n        player.alive = False\n        self.log_message(\"system\", f\"{name} ({player.role.name}) has died ({reason}).\")\n        self.log_hidden(\"system\", f\"{name} died. Reason: {reason}\")\n\n        # Check for Godfather death and promote a Goon\n        if isinstance(player.role, Godfather):\n            # Find the first alive Goon to promote\n            promoted_goon: Optional[Player] = None\n            for p in self.players:\n                 # Check using isinstance and ensure they are alive\n                if p.name in self.alive_players and isinstance(p.role, Goon):\n                    promoted_goon = p\n                    break\n\n            if promoted_goon:\n                # Change the role object of the promoted player\n                new_role = Godfather()\n                promoted_goon.role = new_role\n                promoted_goon.faction = new_role.faction # Ensure faction is updated if needed\n                msg = f\"{promoted_goon.name} has been promoted to Godfather!\"\n                self.log_message(\"system\", msg)\n                self.log_hidden(promoted_goon.name, f\"Promoted to Godfather after {name}'s death\")\n            else:\n                 self.log_hidden(\"system\", f\"Godfather {name} died, but no Goons available to promote.\")\n\n        # Check for game end after death\n        self.check_game_end()\n\n\n    def reset_night_phase_state(self):\n        self.night_actions_submitted.clear()\n        self.night_action_results.clear()\n        self.turn_number_in_phase = 0\n        self.current_player_turn = None\n        for p_name in self.alive_players:\n            player = self.get_player(p_name)\n            if player: player.reset_night_state()\n\n\n    def reset_day_phase_state(self):\n        self.votes_for_accusation.clear()\n        self.accusation_counts.clear()\n        self.player_on_trial = None\n        self.votes_for_lynch.clear()\n        self.turn_number_in_phase = 0\n        self.current_player_turn = None # Or set to first speaker\n        for p_name in self.alive_players:\n            player = self.get_player(p_name)\n            if player: player.reset_day_state()\n\n    def update_vote_counts(self, voter: str, old_target: Optional[str], new_target: str):\n        \"\"\"Updates accusation counts when a vote changes.\"\"\"\n        if old_target and old_target in self.accusation_counts:\n            self.accusation_counts[old_target] -= 1\n            if self.accusation_counts[old_target] <= 0:\n                del self.accusation_counts[old_target]\n\n        self.accusation_counts[new_target] = self.accusation_counts.get(new_target, 0) + 1\n        self.votes_for_accusation[voter] = new_target\n\n\n    def register_night_action(self, actor_name: str, action: Dict[str, Any]):\n        \"\"\"Stores the intended night action from a player.\"\"\"\n        if not self.is_alive(actor_name): return\n        self.night_actions_submitted[actor_name] = action\n        self.log_hidden(actor_name, f\"Submitted night action: {action}\")\n\n    # resolve_night_actions is now primarily handled by the Environment\n\n    def check_game_end(self) -> bool:\n        \"\"\"Checks if a win condition has been met.\"\"\"\n        if self.game_over: return True # Already ended\n\n        mafia_alive = {p.name for p in self.players if p.alive and p.faction == Faction.MAFIA}\n        town_alive = {p.name for p in self.players if p.alive and p.faction == Faction.TOWN}\n        # Add other factions (Neutral) if they exist\n\n        winner = None\n        if not mafia_alive:\n            winner = Faction.TOWN # Town wins if all Mafia are dead\n        elif len(mafia_alive) >= len(town_alive):\n            # Mafia wins if they equal or outnumber Town (or if only Mafia remain)\n            winner = Faction.MAFIA\n\n        # Add neutral win conditions here if applicable\n\n        if winner:\n            self.game_over = True\n            self.winner = winner\n            self.phase = GamePhase.GAME_OVER\n            self.log_message(\"system\", f\"Game Over! Winner: {winner.value.upper()}\")\n            self.final_player_roles = {p.name: p.role.name for p in self.players}\n            self.log_hidden(\"system\", f\"Final Roles: {self.final_player_roles}\")\n            return True\n\n        return False\n\n    def log_message(self, sender: str, content: str, recipients: Optional[List[str]] = None):\n        \"\"\"Logs a message to the public game log.\"\"\"\n        # Recipients = None means public message\n        msg = {\"sender\": sender, \"content\": content, \"recipients\": recipients, \"phase\": self.phase, \"day\": self.day_count}\n        self.messages.append(msg)\n\n    def log_hidden(self, actor: str, info: str):\n        \"\"\"Logs information relevant to a specific actor or system process.\"\"\"\n        log_entry = {\n            \"actor\": actor,\n            \"info\": info,\n            \"phase\": self.phase,\n            \"day\": self.day_count,\n            \"turn\": self.turn_number_in_phase\n        }\n        self.hidden_log.append(log_entry)\n\n    def get_player_observation(self, player_name: str) -> Dict[str, Any]:\n         \"\"\"Generates the observation dictionary for a specific player.\"\"\"\n         player = self.get_player(player_name)\n         if not player or not player.alive:\n             return {} # Or return a specific \"you are dead\" state\n\n         # Filter messages visible to this player\n         visible_messages = []\n         for msg in self.messages:\n             # Public messages or whispers sent to/by the player\n             is_recipient = msg[\"recipients\"] is None or player_name in msg[\"recipients\"]\n             is_sender = msg[\"sender\"] == player_name and msg[\"recipients\"] is not None # Show own whispers\n             if is_recipient or is_sender:\n                 # Maybe format message differently if whisper?\n                 if msg[\"recipients\"] and len(msg[\"recipients\"]) == 1 and is_recipient and not is_sender:\n                     formatted_content = f\"(Whisper from {msg['sender']}): {msg['content']}\"\n                 elif is_sender:\n                     formatted_content = f\"(Whisper to {msg['recipients'][0]}): {msg['content']}\"\n                 else:\n                      formatted_content = f\"{msg['sender']}: {msg['content']}\"\n                 visible_messages.append(formatted_content)\n\n         # Include relevant game state info\n         obs = {\n             \"game_id\": self.game_id,\n             \"player_name\": player.name,\n             \"role\": player.role.name,\n             \"role_description\": player.role.get_role_description(),\n             \"faction\": player.faction.value,\n             \"phase\": self.phase.name,\n             \"day\": self.day_count,\n             \"turn\": self.turn_number_in_phase,\n             \"is_current_turn\": self.current_player_turn == player.name,\n             \"alive_players\": sorted(list(self.alive_players)),\n             \"dead_players\": sorted(list(self.dead_players)),\n             # Provide recent messages\n             \"messages\": visible_messages[-20:], # Limit history size\n             \"can_speak\": player.can_speak(),\n             \"can_act_tonight\": player.can_act_at_night() and self.phase == GamePhase.NIGHT,\n             \"player_on_trial\": self.player_on_trial,\n             \"votes_for_accusation\": self.votes_for_accusation, # {voter: target}\n             \"accusation_counts\": self.accusation_counts,     # {target: count}\n             # \"token_budget\": self.discussion_token_budgets.get(player.name, 0), # If using tokens\n             \"memory\": player.memory, # Include cop results, etc.\n             \"is_roleblocked\": player.is_roleblocked, # Let player know if blocked last night\n             \"protected_by\": player.protected_by, # Let player know if protected last night\n         }\n         return obs",
  "player.py": "from typing import Optional, Dict, List, Any\n# Import the base Role class and Faction enum\nfrom mafia.mechanics.roles import Role\nfrom mafia.enums import Faction\n# Import GameState for type hinting only to avoid circular dependency\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from mafia.game_state import GameState\n\n\nclass Player:\n    # Role hint uses the class, not the enum\n    def __init__(self, name: str, role: Role):\n        self.name: str = name\n        self.role: Role = role\n        # Faction comes directly from the role object\n        self.faction: Faction = self.role.faction\n        self.alive: bool = True\n\n        # Night action state\n        self.night_target: Optional[str] = None # Who the player chose to target\n        self.is_roleblocked: bool = False\n        self.protected_by: Optional[str] = None # Who protected this player (e.g., Doctor's name)\n\n        # Day state\n        self.vote: Optional[str] = None\n        self.discussion_tokens: int = 0 # Handled by environment/config\n        self.can_speak_today: bool = True # For effects like Blackmailer\n\n        # Action tracking & Memory\n        self.has_accused_today: bool = False\n        self.predictions: Dict[str, str] = {} # target_name -> predicted_role_name\n        self.questions_asked_today: Dict[str, int] = {} # target_name -> count\n        self.whispers_sent_today: Dict[str, str] = {} # target_name -> last_whisper_content\n        # Memory for roles like Cop\n        self.memory: List[Dict[str, Any]] = []\n\n    def reset_for_new_game(self):\n        \"\"\"Resets player state for the start of a new game.\"\"\"\n        self.alive = True\n        self.reset_night_state()\n        self.reset_day_state()\n        self.memory.clear()\n        self.predictions.clear()\n        # Role is assigned at init, faction derives from it\n\n    def reset_night_state(self):\n        \"\"\"Resets state relevant to the night phase.\"\"\"\n        self.night_target = None\n        self.is_roleblocked = False\n        self.protected_by = None\n\n    def reset_day_state(self):\n        \"\"\"Resets state relevant to the day phase.\"\"\"\n        self.vote = None\n        # discussion_tokens might be reset by environment based on config\n        self.has_accused_today = False\n        self.questions_asked_today.clear()\n        self.whispers_sent_today.clear()\n        self.can_speak_today = True # Reset blacklist effect\n\n    def can_act_at_night(self) -> bool:\n        \"\"\"Check if player is alive and their role has a night action.\"\"\"\n        return self.alive and self.role.can_act_at_night()\n\n    def perform_night_action(self, game_state: 'GameState') -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Performs the player's role-specific night action.\n        Assumes self.night_target has been set by the agent.\n        Returns the action dict or None.\n        \"\"\"\n        if not self.can_act_at_night() or self.is_roleblocked:\n            if self.is_roleblocked:\n                 self.log_hidden(game_state, \"Tried to act but was roleblocked.\")\n            return None\n        # Pass the chosen target to the role's action method\n        return self.role.night_action(self, game_state, self.night_target)\n\n    def can_speak(self) -> bool:\n        # Add check for blacklist/mute effects\n        return self.alive and self.can_speak_today # Add token check if using budgets: and self.discussion_tokens > 0\n\n    # --- Day Actions ---\n    # Note: These methods now mostly validate and log,\n    # the core logic resides in the Environment or GameState update methods.\n\n    def accuse(self, target: str, game_state: 'GameState'):\n        if not self.can_speak() or self.has_accused_today:\n            self.log_hidden(game_state, f\"Attempted to accuse {target} but couldn't (already accused or cannot speak).\")\n            return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to accuse {target} but they are dead or invalid.\")\n            return False\n\n        # Logic to handle accusation (e.g., trigger voting phase) should be in Environment/GameState\n        self.log_hidden(game_state, f\"Accused {target}\")\n        game_state.messages.append(f\"{self.name} accuses {target}!\")\n        self.has_accused_today = True # Limit accusations if desired\n        return True\n\n    def predict_role(self, target: str, predicted_role_name: str, game_state: 'GameState'):\n        # Prediction is mainly for agent's internal state or analysis\n        if not self.alive: return False\n        target_player = game_state.get_player(target)\n        if not target_player: return False # Predict only existing players\n\n        self.predictions[target] = predicted_role_name\n        self.log_hidden(game_state, f\"Predicted {target} as {predicted_role_name}\")\n        # Optional: Public message? game_state.messages.append(f\"{self.name} predicts {target} is a {predicted_role_name}.\")\n        return True\n\n    def question(self, target: str, question_text: str, game_state: 'GameState'):\n        if not self.can_speak():\n             self.log_hidden(game_state, f\"Attempted to question {target} but cannot speak.\")\n             return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to question {target} but they are dead or invalid.\")\n            return False\n\n        # Actual questioning/response logic handled by environment turn manager + agents\n        self.questions_asked_today[target] = self.questions_asked_today.get(target, 0) + 1\n        # self.discussion_tokens -= 1 # Decrement if using token budgets\n        self.log_hidden(game_state, f\"Asked {target}: {question_text}\")\n        game_state.messages.append(f\"{self.name} asks {target}: \\\"{question_text}\\\"\")\n        return True\n\n    def whisper(self, target: str, whisper_text: str, game_state: 'GameState'):\n        # Whispering might have specific rules (e.g., only Mafia, limits)\n        if not self.alive: return False\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n            self.log_hidden(game_state, f\"Attempted to whisper {target} but they are dead or invalid.\")\n            return False\n\n        # Check game rules for whisper permissions if needed\n        # e.g., if self.faction != Faction.MAFIA and not game_state.config.allow_all_whispers: return False\n\n        self.whispers_sent_today[target] = whisper_text\n        self.log_hidden(game_state, f\"Whispered to {target}: {whisper_text}\")\n        # Add to messages, but potentially filtered based on recipient\n        # Using a dedicated messaging system is better here. Assume game_state.messages is public for now.\n        game_state.messages.append(f\"[WHISPER] {self.name} to {target}\") # Content hidden in public log\n        # Need a way for target agent to see the whisper content in their observation\n        return True\n\n    def vote_for(self, target: str, game_state: 'GameState'):\n        if not self.alive: return False\n        # Allow voting for dead players? Assume no for now.\n        target_player = game_state.get_player(target)\n        if not target_player or not target_player.alive:\n             self.log_hidden(game_state, f\"Attempted to vote for {target} but they are dead or invalid.\")\n             return False\n\n        # Actual vote tallying happens in GameState/Environment\n        old_vote = self.vote\n        self.vote = target\n        if old_vote and old_vote != target:\n            log_msg = f\"Changed vote from {old_vote} to {target}\"\n            public_msg = f\"{self.name} changed vote to {target}.\"\n        elif not old_vote:\n            log_msg = f\"Voted for {target}\"\n            public_msg = f\"{self.name} voted for {target}.\"\n        else: # Voted for same person again\n            return True # No change needed\n\n        self.log_hidden(game_state, log_msg)\n        game_state.messages.append(public_msg)\n        # Signal environment to update vote counts\n        game_state.update_vote_counts(self.name, old_vote, target)\n        return True\n\n    def log_hidden(self, game_state: 'GameState', info: str):\n        \"\"\"Logs information to the game's hidden log associated with this player.\"\"\"\n        # Ensure game_state has this method or handle logging directly\n        game_state.log_hidden(self.name, info)\n\n\n    def __repr__(self):\n        status = 'Dead' if not self.alive else 'Alive'\n        return f\"<Player: {self.name} | Role: {self.role.name} | Faction: {self.faction.value} | Status: {status}>\"\n",
  "rewards.py": "# mafia/rewards.py\nfrom typing import Dict\nfrom mafia.enums import Faction\n\n\ndef assign_endgame_rewards(game_state) -> Dict[str, float]:\n    \"\"\"\n    Assign final rewards to agents based on game outcome.\n    Town agents get +1 for town win, -1 otherwise. Same for mafia.\n    \"\"\"\n    rewards = {}\n    for player in game_state.players:\n        if player.faction.value == game_state.winner:\n            rewards[player.name] = 1.0\n        else:\n            rewards[player.name] = -1.0\n    return rewards\n\n\ndef assign_predict_role_reward(predicted: str, actual: str) -> float:\n    return 0.5 if predicted == actual else -0.25\n\n\ndef assign_vote_reward(voter, target, game_state) -> float:\n    \"\"\"\n    +1 if town correctly votes out mafia\n    -1 if town votes town\n    +0.5 if mafia avoids being voted\n    \"\"\"\n    if not game_state.is_alive(target):  # Lynched\n        if voter.faction == Faction.TOWN:\n            if game_state.get_player(target).faction == Faction.MAFIA:\n                return 1.0\n            else:\n                return -1.0\n        elif voter.faction == Faction.MAFIA:\n            if game_state.get_player(target).faction == Faction.MAFIA:\n                return -1.0\n            else:\n                return 0.5\n    return 0.0\n\n\ndef assign_speaking_reward(agent_name: str, token_used: int) -> float:\n    \"\"\"\n    Optional: Reward for verbosity, or penalize excess verbosity.\n    For now, neutral. Could be tuned.\n    \"\"\"\n    return 0.0\n\n\ndef assign_question_reward(asker, target, game_state) -> float:\n    \"\"\"\n    +0.2 for engaging others; could scale if target is mafia and asker is town\n    \"\"\"\n    if asker.faction == Faction.TOWN and target.faction == Faction.MAFIA:\n        return 0.4\n    return 0.2\n",
  "simulation.py": "import os\nimport json\nfrom tqdm import tqdm\n# Use correct Environment class name\nfrom mafia.environment import MafiaEnvironment\n# Import role classes and helper\nfrom mafia.mechanics.roles import get_role_class, Role\nfrom mafia.player import Player\n# Keep TokenTracker import, assume it exists or create dummy\n# from mafia.utils.token_cost import TokenTracker # If using\n# Import agent classes\nfrom mafia.agents.rule_agent import RuleBasedAgent # Assuming this will exist\nfrom mafia.agents.llm_agent import LLMAPIClientAgent # Import the LLM agent\nfrom typing import Dict, List\nimport uuid\n\n# Dummy Token Tracker if needed\nclass TokenTracker:\n    def __init__(self): self.usage = {}\n    def update(self, *args, **kwargs): pass\n    def to_dict(self): return self.usage\n\ndef create_players_from_config(config: Dict) -> List[Player]:\n    \"\"\"Creates Player objects based on a configuration dictionary.\"\"\"\n    players = []\n    roles_config = config.get(\"roles\", []) # e.g., [{\"name\": \"Player1\", \"role\": \"Cop\"}, ...]\n    if not roles_config: # Fallback to default if config is empty/missing roles\n        roles_setup = [\n            (\"Player1\", \"Cop\"), (\"Player2\", \"Doctor\"), (\"Player3\", \"Villager\"),\n            (\"Player4\", \"Godfather\"), (\"Player5\", \"Goon\")\n        ]\n        print(\"Warning: Using default 5-player role setup.\")\n    else:\n        roles_setup = [(p_cfg[\"name\"], p_cfg[\"role\"]) for p_cfg in roles_config]\n\n    for name, role_name in roles_setup:\n        RoleClass = get_role_class(role_name)\n        if not RoleClass:\n             raise ValueError(f\"Unknown role name '{role_name}' in configuration.\")\n        role_instance = RoleClass()\n        player = Player(name=name, role=role_instance)\n\n        # --- Agent Assignment ---\n        # Example: Assign agents based on config or default to RuleBased\n        agent_type = config.get(\"agent_mapping\", {}).get(name, \"rule\") # Default to rule-based\n\n        if agent_type.lower() == \"llm\":\n            # TODO: Get model name, system prompt from config\n            model_name = config.get(\"llm_config\", {}).get(\"model\", \"gpt-4\") # Example default\n            system_prompt_key = config.get(\"llm_config\", {}).get(\"system_prompt_key\", \"default_mafia\")\n            # Need a way to load system prompts based on key\n            system_prompt = f\"You are {name}, playing Mafia as {role_instance.name}. {role_instance.get_role_description()}\" # Basic example\n            agent = LLMAPIClientAgent(name=name, model=model_name, system_prompt=system_prompt)\n            print(f\"Assigning LLM Agent ({model_name}) to {name}\")\n        else: # Default to RuleBasedAgent\n             # RuleBasedAgent needs to be implemented\n            agent = RuleBasedAgent(name=name, player_role=role_instance.name)\n            print(f\"Assigning Rule Agent to {name}\")\n\n        # Link agent to player (though environment might manage this)\n        player.agent = agent # Store agent reference if needed directly by player, otherwise managed by env/runner\n        players.append(player)\n\n    return players\n\n\ndef run_simulation(game_config: Dict, agent_config: Dict) -> Dict:\n    \"\"\"Runs a single game simulation and returns the final state.\"\"\"\n    print(f\"\\n--- Starting Simulation Game ID: {game_config.get('game_id', 'N/A')} ---\")\n\n    # Combine configs or pass separately\n    full_config = {**game_config, \"agents\": agent_config} # Example merge\n\n    # Create players based on combined config\n    players = create_players_from_config(full_config) # Pass merged config\n\n    # Initialize environment\n    # Pass game_config to environment if it needs rules like GF detectability\n    env = MafiaEnvironment(players=players, config=full_config)\n    token_tracker = TokenTracker() # Initialize token tracker if used\n\n    # --- Game Loop ---\n    max_steps = full_config.get(\"max_steps\", 100) # Limit game length\n    step_count = 0\n    while not env.state.game_over and step_count < max_steps:\n        step_count += 1\n        print(f\"\\n=== Day {env.state.day_count} | Phase: {env.state.phase.name} | Turn: {env.state.turn_number_in_phase} ===\")\n        current_player_name = env.get_current_player_name() # Needs implementation in Env\n\n        if not current_player_name:\n            # Environment handles transition or phase resolution automatically\n             print(\"Environment resolving phase...\")\n             env.step_phase() # Needs implementation in Env\n             continue # Go to next loop iteration to check game state\n\n        player = env.state.get_player(current_player_name)\n        if not player or not player.alive:\n             print(f\"Skipping turn for {current_player_name} (dead or invalid).\")\n             env.advance_turn() # Needs implementation in Env\n             continue\n\n        agent = player.agent # Get agent associated with the player\n\n        # Get observation for the current player\n        observation = env.get_observation(current_player_name) # Needs implementation in Env\n\n        # Agent decides action\n        print(f\"--- {current_player_name}'s Turn ({agent.__class__.__name__}) ---\")\n        action = agent.act(observation) # Agent returns action dict\n        print(f\"Action chosen: {action}\")\n\n        # Environment processes action\n        success = env.process_player_action(current_player_name, action) # Needs implementation in Env\n        if not success:\n            print(f\"Action {action} failed or was invalid.\")\n\n        # Optional: Track tokens\n        # token_tracker.update(current_player_name, observation, action)\n\n        # Environment potentially advances turn or phase based on action\n        # This might happen inside process_player_action or require a separate env.advance() call\n\n    print(f\"\\n--- Game Over ---\")\n    print(f\"Winner: {env.state.winner.value if env.state.winner else 'Draw/Timeout'}\")\n    print(f\"Ended on Day {env.state.day_count}, Phase {env.state.phase.name}\")\n\n    # Log final state and return results\n    final_state_summary = log_game_summary(env.state) # Use analysis function\n    final_state_summary[\"tokens_used\"] = token_tracker.to_dict() # Add token info if tracked\n    return final_state_summary\n\n\ndef run_multiple_simulations(num_games=10, config_path=\"config/default_game.json\", save_dir=\"data/episodes\"):\n    \"\"\"Runs multiple simulations based on a config file.\"\"\"\n    os.makedirs(save_dir, exist_ok=True)\n\n    # Load base configuration (needs implementation)\n    # base_game_config = load_config_from_file(config_path)\n    # base_agent_config = base_game_config.get(\"agent_config\", {}) # Separate agent config if needed\n    base_game_config = {\"roles\": [ # Example default config\n             {\"name\": \"Player1\", \"role\": \"Cop\"}, {\"name\": \"Player2\", \"role\": \"Doctor\"},\n             {\"name\": \"Player3\", \"role\": \"Villager\"}, {\"name\": \"Player4\", \"role\": \"Godfather\"},\n             {\"name\": \"Player5\", \"role\": \"Goon\"}\n         ],\n        \"agent_mapping\": {\"Player1\": \"llm\", \"Player4\": \"llm\"}, # P1 & P4 are LLMs\n        \"llm_config\": {\"model\": \"gpt-3.5-turbo\"} # Example LLM config\n     }\n    base_agent_config = {} # Agent specific settings if needed\n\n\n    game_results = []\n    for i in tqdm(range(num_games), desc=\"Simulating Games\"):\n        game_id = str(uuid.uuid4())\n        current_game_config = {**base_game_config, \"game_id\": game_id}\n        # Add variations here if doing experiments (e.g., change roles, prompts)\n\n        try:\n            result = run_simulation(current_game_config, base_agent_config)\n            game_results.append(result)\n\n            # Save individual game logs as JSONL\n            log_path = os.path.join(save_dir, \"games_log.jsonl\")\n            with open(log_path, \"a\") as f:\n                json.dump(result, f)\n                f.write(\"\\n\")\n\n        except Exception as e:\n            print(f\"\\n!!!!!! Error during simulation {game_id} !!!!!!\")\n            print(f\"Error: {e}\")\n            # Log error state if possible\n            error_info = {\"game_id\": game_id, \"status\": \"error\", \"error_message\": str(e)}\n            log_path = os.path.join(save_dir, \"games_log.jsonl\")\n            with open(log_path, \"a\") as f:\n                json.dump(error_info, f)\n                f.write(\"\\n\")\n\n\n    print(f\"\\n--- Simulation Run Complete ---\")\n    print(f\"Saved {len(game_results)} game logs to {os.path.join(save_dir, 'games_log.jsonl')}\")\n\n    # --- Optional: Compute and print aggregate metrics ---\n    # win_rates = compute_win_rate(game_results)\n    # avg_tokens = compute_average_tokens(game_results)\n    # avg_accuracy = compute_average_role_accuracy(game_results)\n    # print(\"\\nAggregate Metrics:\")\n    # print(f\"Win Rates: {win_rates}\")\n    # print(f\"Avg Tokens: {avg_tokens}\")\n    # print(f\"Avg Role Accuracy: {avg_accuracy}\")\n\n\n# Helper for loading config (placeholder)\ndef load_config_from_file(path: str) -> Dict:\n     print(f\"Warning: Config loading not implemented. Using defaults. Tried path: {path}\")\n     # Implement actual JSON/YAML loading here\n     return {}\n\n\n# Need log_game_summary, compute_* from evaluation module\n# Placeholder if not implemented yet\ndef log_game_summary(game_state): return {\"game_id\": game_state.game_id, \"winner\": game_state.winner.value if game_state.winner else None, \"final_roles\": game_state.final_player_roles}\n# def compute_win_rate(results): return {}\n# def compute_average_tokens(results): return {}\n# def compute_average_role_accuracy(results): return 0.0\n\n\nif __name__ == \"__main__\":\n    # Example of how to run\n    run_multiple_simulations(num_games=5, save_dir=\"output/sim_results\")\n",
  "__init__.py": "",
  "agents\\base.py": "# mafia/agents/base.py\nfrom abc import ABC, abstractmethod\n\nclass BaseAgent(ABC):\n    def __init__(self, name: str):\n        self.name = name\n\n    @abstractmethod\n    def act(self, observation: dict) -> dict:\n        \"\"\"\n        Returns an action dict like {\"action\": \"accuse\", \"target\": \"Player3\"}\n        \"\"\"\n        pass\n",
  "agents\\llm_agent.py": "# mafia/agents/llm_agent.py\nimport os\nimport openai\nfrom mafia.agents.base import BaseAgent\nfrom mafia.prompts.mafia_template import format_prompt, parse_response\n\nclass LLMAPIClientAgent(BaseAgent):\n    def __init__(self, name: str, model: str = \"gpt-4\", system_prompt: str = None):\n        super().__init__(name)\n        self.model = model\n        self.system_prompt = system_prompt or \"You are playing the game Mafia. Reason carefully.\"\n        self.client = openai.ChatCompletion  # Can be monkey-patched for DeepSeek etc.\n\n    def act(self, observation: dict) -> dict:\n        prompt = format_prompt(self.name, observation)\n        messages = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        response = self.client.create(\n            model=self.model,\n            messages=messages,\n            temperature=0.7,\n        )\n        raw = response.choices[0].message.content.strip()\n        return parse_response(raw)\n",
  "agents\\rule_agent.py": "",
  "agents\\__init__.py": "",
  "evaluation\\analysis.py": "# mafia/evaluation/analysis.py\nfrom typing import List, Dict\n\ndef log_game_summary(game_state) -> Dict:\n    \"\"\"\n    Logs key metrics and summary data from a completed game.\n    Returns a structured dictionary with faction, winners, predictions, etc.\n    \"\"\"\n    summary = {\n        \"game_id\": game_state.game_id,\n        \"winner\": game_state.winner,\n        \"day_count\": game_state.day_count,\n        \"players\": [],\n        \"predictions\": [],\n        \"votes\": [],\n        \"whispers\": [],\n        \"questions\": [],\n        \"accusations\": [],\n    }\n\n    for player in game_state.players:\n        summary[\"players\"].append({\n            \"name\": player.name,\n            \"role\": player.role.name,\n            \"faction\": player.faction.value,\n            \"alive\": player.alive,\n        })\n\n        for target, role in player.predicted_roles.items():\n            summary[\"predictions\"].append({\n                \"predictor\": player.name,\n                \"target\": target,\n                \"predicted_role\": role\n            })\n\n        if player.vote:\n            summary[\"votes\"].append({\n                \"voter\": player.name,\n                \"voted_for\": player.vote\n            })\n\n        for target, whisper_text in player.whispers_sent.items():\n            summary[\"whispers\"].append({\n                \"from\": player.name,\n                \"to\": target,\n                \"content\": whisper_text\n            })\n\n        for target, count in player.questions_asked.items():\n            summary[\"questions\"].append({\n                \"asker\": player.name,\n                \"target\": target,\n                \"times\": count\n            })\n\n        if player.has_accused:\n            summary[\"accusations\"].append(player.name)\n\n    return summary\n",
  "evaluation\\metrics.py": "# mafia/evaluation/metrics.py\nfrom collections import defaultdict\nfrom typing import Dict, List\n\n\ndef compute_win_rate(games: List[Dict]) -> Dict[str, float]:\n    \"\"\"\n    Returns the win rate for each faction based on finished games.\n    \"\"\"\n    results = defaultdict(int)\n    for game in games:\n        results[game[\"winner\"]] += 1\n    total = sum(results.values())\n    return {faction: wins / total for faction, wins in results.items()}\n\n\ndef compute_average_tokens(games: List[Dict]) -> Dict[str, float]:\n    \"\"\"\n    Returns the average number of tokens used by each agent across games.\n    \"\"\"\n    token_totals = defaultdict(int)\n    token_counts = defaultdict(int)\n    for game in games:\n        for agent, tokens in game[\"tokens\"].items():\n            token_totals[agent] += tokens.get(\"input\", 0) + tokens.get(\"output\", 0)\n            token_counts[agent] += 1\n    return {\n        agent: token_totals[agent] / token_counts[agent]\n        for agent in token_totals\n    }\n\n\ndef compute_average_role_accuracy(games: List[Dict]) -> float:\n    \"\"\"\n    Computes how often role predictions were correct.\n    \"\"\"\n    correct = 0\n    total = 0\n    for game in games:\n        for entry in game[\"hidden_log\"]:\n            if \"Predicted\" in entry[\"info\"]:\n                # Format: \"Predicted X as Y\"\n                parts = entry[\"info\"].split()\n                predicted_role = parts[-1]\n                target = parts[1]\n                actual_role = None\n                for player in game[\"players\"]:\n                    if player[\"name\"] == target:\n                        actual_role = player[\"role\"]\n                        break\n                if actual_role:\n                    total += 1\n                    if predicted_role == actual_role:\n                        correct += 1\n    return correct / total if total else 0.0\n",
  "mechanics\\messaging.py": "# mafia/mechanics/messaging.py\nfrom typing import Dict, List, Optional, Tuple\nfrom mafia.enums import Phase\n\nclass Message:\n    def __init__(self, sender: str, content: str, target: Optional[str] = None, private: bool = False):\n        self.sender = sender              # Who sent the message\n        self.content = content            # What was said (raw text or structured)\n        self.target = target              # If whispering or targeting another player\n        self.private = private            # Whisper if True, public otherwise\n\n    def render(self) -> str:\n        if self.private:\n            return f\"[WHISPER] {self.sender} \u2192 {self.target}: {self.content}\"\n        elif self.target:\n            return f\"{self.sender} \u2192 {self.target}: {self.content}\"\n        return f\"{self.sender}: {self.content}\"\n\n\nclass MessagingSystem:\n    def __init__(self):\n        self.history: List[Message] = []\n\n    def send_public(self, sender: str, content: str):\n        msg = Message(sender=sender, content=content)\n        self.history.append(msg)\n        return msg\n\n    def send_private(self, sender: str, recipient: str, content: str):\n        msg = Message(sender=sender, content=content, target=recipient, private=True)\n        self.history.append(msg)\n        return msg\n\n    def get_visible_messages(self, player_name: str, phase: Phase) -> List[str]:\n        visible = []\n        for msg in self.history:\n            if not msg.private:\n                visible.append(msg.render())\n            elif msg.private and (msg.sender == player_name or msg.target == player_name):\n                visible.append(msg.render())\n        return visible\n\n    def get_all_messages(self) -> List[str]:\n        return [msg.render() for msg in self.history]\n\n    def clear(self):\n        self.history.clear()\n\n    def get_log_data(self) -> List[Dict]:\n        return [{\n            \"sender\": msg.sender,\n            \"target\": msg.target,\n            \"private\": msg.private,\n            \"content\": msg.content\n        } for msg in self.history]\n",
  "mechanics\\roles.py": "from abc import ABC, abstractmethod\n# Corrected import path assuming roles.py is inside mechanics\nfrom mafia.enums import Faction\nfrom typing import Optional, TYPE_CHECKING, Dict, Any\n\n# Avoid circular import for type hinting\nif TYPE_CHECKING:\n    from mafia.player import Player\n    from mafia.game_state import GameState\n\n\nclass Role(ABC):\n    def __init__(self, name: str, faction: Faction):\n        self.name = name\n        self.faction = faction\n        # Add alignment based on faction for consistency if needed elsewhere\n        self.alignment = faction # Simple mapping for now\n\n    @abstractmethod\n    def get_role_description(self) -> str:\n        \"\"\"Return a string describing the role's abilities and goals.\"\"\"\n        pass\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Executes the role's night action.\n        Target selection logic is handled by the Agent/Player, passed via target_name.\n        Returns a dictionary representing the action taken or None.\n        \"\"\"\n        return None # Default: No night action\n\n    def can_act_at_night(self) -> bool:\n        \"\"\"Checks if the role has a meaningful night action.\"\"\"\n        # Check if the night_action method is overridden from the base class\n        return self.__class__.night_action != Role.night_action\n\n    def __repr__(self):\n        # Use self.faction directly as it's an attribute\n        return f\"<{self.faction.value}:{self.name}>\"\n\n# ------------------- TOWN ROLES -------------------\n\nclass Villager(Role):\n    def __init__(self):\n        # Use direct value for consistency, or reference an enum if preferred\n        super().__init__(\"Villager\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are a Villager. You have no special abilities. Find and lynch the Mafia.\"\n\n    # night_action is inherited as None\n\nclass Cop(Role):\n    def __init__(self):\n        super().__init__(\"Cop\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are the Cop. Each night, you can investigate one player to determine their faction (Town or Mafia).\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n\n        if target_player and target_player.alive:\n            # Simplified: Godfather reads as Town unless detectable=True (add later)\n            is_mafia = target_player.role.faction == Faction.MAFIA\n            # Handle Godfather detection rule here if needed\n            # Example: if isinstance(target_player.role, Godfather) and not game_state.config.get(\"godfather_detectable\", False):\n            #     result_faction = Faction.TOWN\n            # else:\n            result_faction = Faction.MAFIA if is_mafia else Faction.TOWN\n\n            result_info = f\"Investigated {target_player.name}: Result {result_faction.value}\"\n            player.log_hidden(game_state, f\"\\uD83D\\uDD0E {result_info}\")\n            # Store result in player's memory\n            player.memory.append({\n                \"type\": \"investigation_result\",\n                \"day\": game_state.day_count,\n                \"target\": target_player.name,\n                \"result\": result_faction.value\n            })\n            # Action registered for logging/tracking, actual info given via memory\n            return {\"type\": \"investigate\", \"target\": target_player.name, \"result\": result_faction.value}\n        elif target_name:\n             player.log_hidden(game_state, f\"\\uD83D\\uDD0E Tried to investigate {target_name}, but they were not found or dead.\")\n        return None\n\nclass Doctor(Role):\n    def __init__(self):\n        super().__init__(\"Doctor\", Faction.TOWN)\n\n    def get_role_description(self) -> str:\n        return \"You are the Doctor. Each night, you can choose one player to protect from death.\"\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n\n        if target_player and target_player.alive:\n            # Protection handled centrally in night resolution based on this action\n            player.log_hidden(game_state, f\"\\uD83E\\uDE78 Protected {target_player.name}\")\n            return {\"type\": \"protect\", \"target\": target_player.name}\n        elif target_name:\n            player.log_hidden(game_state, f\"\\uD83E\\uDE78 Tried to protect {target_name}, but they were not found or dead.\")\n        return None\n\n# ------------------- MAFIA ROLES -------------------\n\nclass Goon(Role):\n    def __init__(self):\n        super().__init__(\"Goon\", Faction.MAFIA)\n\n    def get_role_description(self) -> str:\n        return \"You are a Mafia Goon. Work with your team to kill Town members at night and avoid getting lynched during the day.\"\n\n    # night_action is inherited as None (kill decision by Godfather)\n\nclass Godfather(Role):\n    def __init__(self):\n        super().__init__(\"Godfather\", Faction.MAFIA)\n        self.appears_as = Faction.TOWN # To cops, unless detectable\n\n    def get_role_description(self) -> str:\n        return (\"You are the Godfather. You appear as Town to the Cop. \"\n                \"Each night, choose a target for the Mafia to kill. \"\n                \"If you die, a Goon will be promoted.\")\n\n    def night_action(self, player: 'Player', game_state: 'GameState', target_name: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        target_player = game_state.get_player(target_name) if target_name else None\n\n        if target_player and target_player.alive:\n            player.log_hidden(game_state, f\"\\uD83D\\uDD2A Ordered kill on {target_player.name}\")\n            # Action registered, actual kill resolved centrally\n            return {\"type\": \"kill\", \"target\": target_player.name}\n        elif target_name:\n             player.log_hidden(game_state, f\"\\uD83D\\uDD2A Tried to order kill on {target_name}, but they were not found or dead.\")\n        return None\n\n# Add other roles (RoleBlocker, Consigliere, etc.) here following the pattern...\n\n# Helper function to get a role class from its name string (used in simulation setup)\n# Place this at the end of the file or in a separate utility file\nROLE_CLASS_MAP = {\n    \"villager\": Villager,\n    \"cop\": Cop,\n    \"doctor\": Doctor,\n    \"goon\": Goon,\n    \"godfather\": Godfather,\n    # Add other roles here...\n}\n\ndef get_role_class(role_name: str) -> Optional[type[Role]]:\n    return ROLE_CLASS_MAP.get(role_name.lower())",
  "mechanics\\voting.py": "# mafia/mechanics/voting.py\nfrom typing import Dict, Optional\nfrom mafia.enums import Phase\nfrom mafia.game_state import GameState\n\n\ndef cast_vote(game_state: GameState, voter: str, target: str) -> None:\n    \"\"\"Player casts or changes vote for someone.\"\"\"\n    if game_state.phase != Phase.DAY or voter not in game_state.alive_players:\n        return\n\n    # Remove old vote if it exists\n    if voter in game_state.voting_targets:\n        prev_target = game_state.voting_targets[voter]\n        if prev_target != target:\n            game_state.messages.append(f\"{voter} changed their vote from {prev_target} to {target}.\")\n    else:\n        game_state.messages.append(f\"{voter} has voted for {target}.\")\n\n    game_state.voting_targets[voter] = target\n    check_accusation_threshold(game_state)\n\n\ndef retract_vote(game_state: GameState, voter: str) -> None:\n    \"\"\"Player retracts their vote.\"\"\"\n    if voter in game_state.voting_targets:\n        prev = game_state.voting_targets.pop(voter)\n        game_state.messages.append(f\"{voter} retracted their vote on {prev}.\")\n\n\ndef check_accusation_threshold(game_state: GameState, threshold: float = 0.5) -> None:\n    \"\"\"Automatically trigger accusation if a player reaches vote threshold.\"\"\"\n    vote_counts: Dict[str, int] = {}\n    for target in game_state.voting_targets.values():\n        vote_counts[target] = vote_counts.get(target, 0) + 1\n\n    total_voters = len(game_state.alive_players)\n    for target, count in vote_counts.items():\n        if count / total_voters >= threshold and game_state.accused_player != target:\n            game_state.accused_player = target\n            game_state.messages.append(f\"{target} has been accused and must now defend themselves.\")\n\n\ndef confirm_lynch_vote(game_state: GameState, voter: str, confirm: bool) -> None:\n    \"\"\"Player confirms or denies the lynch after accusation.\"\"\"\n    if game_state.phase != Phase.DAY or not game_state.accused_player:\n        return\n\n    game_state.lynch_confirm_votes[voter] = confirm\n    yes_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if vote)\n    no_votes = sum(1 for vote in game_state.lynch_confirm_votes.values() if not vote)\n\n    total_voters = len(game_state.alive_players)\n    if yes_votes > total_voters // 2:\n        game_state.messages.append(f\"{game_state.accused_player} has been lynched by majority vote.\")\n        game_state.kill_player(game_state.accused_player)\n        game_state.reset_votes()\n    elif no_votes >= total_voters // 2:\n        game_state.messages.append(f\"{game_state.accused_player} has survived the vote.\")\n        game_state.reset_votes()\n\n\n# --------------------------\n# Whisper Mechanics\n# --------------------------\n\ndef whisper(game_state: GameState, sender: str, recipient: str, message: str) -> None:\n    \"\"\"Send a whisper from one player to another. Hidden from all other agents.\"\"\"\n    if sender not in game_state.alive_players or recipient not in game_state.alive_players:\n        return\n\n    # Track hidden message to sender and recipient\n    for player in game_state.players:\n        if player.name in {sender, recipient}:\n            player.log_hidden(game_state, f\"[WHISPER] {sender} \u2192 {recipient}: {message}\")\n        else:\n            player.log_hidden(game_state, f\"[WHISPER] {sender} \u2192 {recipient}: <hidden>\")\n\n    # Log public metadata\n    game_state.messages.append(f\"{sender} whispered to {recipient}.\")\n\n\n# --------------------------\n# Voting Visibility\n# --------------------------\n\ndef get_vote_visibility(game_state: GameState) -> Dict[str, str]:\n    \"\"\"Return a dict of current votes (publicly visible for now).\"\"\"\n    return {voter: target for voter, target in game_state.voting_targets.items()}\n",
  "mechanics\\__init__.py": "",
  "prompts\\mafia_template.py": "def format_prompt(name: str, obs: dict) -> str:\n    # Format as readable context for the agent\n    lines = [f\"Day {obs['day']} | Phase: {obs['phase']}\"]\n    lines.append(\"Alive: \" + \", \".join(obs[\"alive\"]))\n    lines.append(\"Dead: \" + \", \".join(obs[\"dead\"]))\n    lines.append(\"Messages:\")\n    lines.extend(obs[\"messages\"])\n    lines.append(\"What do you do next? Choose one action:\")\n    return \"\\n\".join(lines)\n\ndef parse_response(response: str) -> dict:\n    \"\"\"\n    Expects LLM to return something like:\n    <action> accuse </action> <target> Player3 </target>\n    \"\"\"\n    import re\n    act = re.search(r\"<action>(.*?)</action>\", response)\n    tgt = re.search(r\"<target>(.*?)</target>\", response)\n    return {\n        \"action\": act.group(1).strip().lower() if act else \"pass\",\n        \"target\": tgt.group(1).strip() if tgt else None\n    }\n",
  "utils\\token_cost.py": ""
}